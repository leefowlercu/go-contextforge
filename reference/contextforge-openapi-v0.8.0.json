{
  "openapi": "3.1.0",
  "info": {
    "title": "MCP_Gateway",
    "description": "A FastAPI-based MCP Gateway with federation support",
    "version": "0.8.0"
  },
  "paths": {
    "/health": {
      "get": {
        "summary": "Healthcheck",
        "description": "Perform a basic health check to verify database connectivity.\n\nArgs:\n    db: SQLAlchemy session dependency.\n\nReturns:\n    A dictionary with the health status and optional error message.",
        "operationId": "healthcheck_health_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/ready": {
      "get": {
        "summary": "Readiness Check",
        "description": "Perform a readiness check to verify if the application is ready to receive traffic.\n\nArgs:\n    db: SQLAlchemy session dependency.\n\nReturns:\n    JSONResponse with status 200 if ready, 503 if not.",
        "operationId": "readiness_check_ready_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/health/security": {
      "get": {
        "tags": [
          "health"
        ],
        "summary": "Security Health",
        "description": "Get the security configuration health status.\n\nArgs:\n    request (Request): The incoming HTTP request containing headers for authentication.\n\nReturns:\n    dict: A dictionary containing the overall security health status, score,\n        individual checks, warning count, and timestamp. Warnings are included\n        only if authentication passes or when running in development mode.\n\nRaises:\n    HTTPException: If authentication is required and the request does not\n        include a valid bearer token in the Authorization header.",
        "operationId": "security_health_health_security_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/version": {
      "get": {
        "tags": [
          "meta"
        ],
        "summary": "Diagnostics (auth required)",
        "description": "Serve diagnostics as JSON, full HTML, or partial HTML.\n\nMain endpoint that gathers all diagnostic information and returns it in the\nrequested format. Requires authentication via HTTP Basic Auth or session.\n\nThe endpoint supports three output formats:\n- JSON (default): Machine-readable diagnostic data\n- Full HTML: Complete HTML page with styled tables\n- Partial HTML: HTML fragment for embedding (when partial=True)\n\nArgs:\n    request (Request): The incoming FastAPI request object.\n    fmt (Optional[str]): Query parameter to force format ('html' for HTML output).\n    partial (Optional[bool]): Query parameter to request partial HTML fragment.\n    _user: Injected authenticated user from require_auth dependency.\n\nReturns:\n    Response: JSONResponse with diagnostic data, or HTMLResponse with formatted page.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import Mock, AsyncMock, patch\n    >>> from fastapi import Request\n    >>> from fastapi.responses import JSONResponse, HTMLResponse\n    >>>\n    >>> # Create mock request\n    >>> mock_request = Mock(spec=Request)\n    >>> mock_request.headers = {\"accept\": \"application/json\"}\n    >>>\n    >>> # Test JSON response (default)\n    >>> async def test_json():\n    ...     with patch('mcpgateway.version.REDIS_AVAILABLE', False):\n    ...         with patch('mcpgateway.version._build_payload') as mock_build:\n    ...             mock_build.return_value = {\"test\": \"data\"}\n    ...             response = await version_endpoint(mock_request, fmt=None, partial=False, _user=\"testuser\")\n    ...             return response\n    >>>\n    >>> response = asyncio.run(test_json())\n    >>> isinstance(response, JSONResponse)\n    True\n\n    >>> # Test HTML response with fmt parameter\n    >>> async def test_html_fmt():\n    ...     with patch('mcpgateway.version.REDIS_AVAILABLE', False):\n    ...         with patch('mcpgateway.version._build_payload') as mock_build:\n    ...             with patch('mcpgateway.version._render_html') as mock_render:\n    ...                 mock_build.return_value = {\"test\": \"data\"}\n    ...                 mock_render.return_value = \"<html>test</html>\"\n    ...                 response = await version_endpoint(mock_request, fmt=\"html\", partial=False, _user=\"testuser\")\n    ...                 return response\n    >>>\n    >>> response = asyncio.run(test_html_fmt())\n    >>> isinstance(response, HTMLResponse)\n    True\n\n    >>> # Test with Redis available\n    >>> async def test_with_redis():\n    ...     mock_redis = AsyncMock()\n    ...     mock_redis.ping = AsyncMock(return_value=True)\n    ...     mock_redis.info = AsyncMock(return_value={\"redis_version\": \"7.0.5\"})\n    ...\n    ...     with patch('mcpgateway.version.REDIS_AVAILABLE', True):\n    ...         with patch('mcpgateway.version.settings') as mock_settings:\n    ...             mock_settings.cache_type = \"redis\"\n    ...             mock_settings.redis_url = \"redis://localhost:6379\"\n    ...             with patch('mcpgateway.version.aioredis.Redis.from_url', return_value=mock_redis):\n    ...                 with patch('mcpgateway.version._build_payload') as mock_build:\n    ...                     mock_build.return_value = {\"redis\": {\"version\": \"7.0.5\"}}\n    ...                     response = await version_endpoint(mock_request, _user=\"testuser\")\n    ...                     # Verify Redis was checked\n    ...                     mock_redis.ping.assert_called_once()\n    ...                     mock_redis.info.assert_called_once()\n    ...                     # Verify payload was built with Redis info\n    ...                     mock_build.assert_called_once_with(\"7.0.5\", True)\n    ...                     return response\n    >>>\n    >>> response = asyncio.run(test_with_redis())\n    >>> isinstance(response, JSONResponse)\n    True",
        "operationId": "version_endpoint_version_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "fmt",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Fmt"
            }
          },
          {
            "name": "partial",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "null"
                }
              ],
              "default": false,
              "title": "Partial"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocol/initialize": {
      "post": {
        "tags": [
          "Protocol"
        ],
        "summary": "Initialize",
        "description": "Initialize a protocol.\n\nThis endpoint handles the initialization process of a protocol by accepting\na JSON request body and processing it. The `require_auth` dependency ensures that\nthe user is authenticated before proceeding.\n\nArgs:\n    request (Request): The incoming request object containing the JSON body.\n    user (str): The authenticated user (from `require_auth` dependency).\n\nReturns:\n    InitializeResult: The result of the initialization process.\n\nRaises:\n    HTTPException: If the request body contains invalid JSON, a 400 Bad Request error is raised.",
        "operationId": "initialize_protocol_initialize_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InitializeResult"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBearer": []
          }
        ]
      }
    },
    "/protocol/ping": {
      "post": {
        "tags": [
          "Protocol"
        ],
        "summary": "Ping",
        "description": "Handle a ping request according to the MCP specification.\n\nThis endpoint expects a JSON-RPC request with the method \"ping\" and responds\nwith a JSON-RPC response containing an empty result, as required by the protocol.\n\nArgs:\n    request (Request): The incoming FastAPI request.\n    user (str): The authenticated user (dependency injection).\n\nReturns:\n    JSONResponse: A JSON-RPC response with an empty result or an error response.\n\nRaises:\n    HTTPException: If the request method is not \"ping\".",
        "operationId": "ping_protocol_ping_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        },
        "security": [
          {
            "HTTPBearer": []
          }
        ]
      }
    },
    "/protocol/notifications": {
      "post": {
        "tags": [
          "Protocol"
        ],
        "summary": "Handle Notification",
        "description": "Handles incoming notifications from clients. Depending on the notification method,\ndifferent actions are taken (e.g., logging initialization, cancellation, or messages).\n\nArgs:\n    request (Request): The incoming request containing the notification data.\n    user (str): The authenticated user making the request.",
        "operationId": "handle_notification_protocol_notifications_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        },
        "security": [
          {
            "HTTPBearer": []
          }
        ]
      }
    },
    "/protocol/completion/complete": {
      "post": {
        "tags": [
          "Protocol"
        ],
        "summary": "Handle Completion",
        "description": "Handles the completion of tasks by processing a completion request.\n\nArgs:\n    request (Request): The incoming request with completion data.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    The result of the completion process.",
        "operationId": "handle_completion_protocol_completion_complete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/protocol/sampling/createMessage": {
      "post": {
        "tags": [
          "Protocol"
        ],
        "summary": "Handle Sampling",
        "description": "Handles the creation of a new message for sampling.\n\nArgs:\n    request (Request): The incoming request with sampling data.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    The result of the message creation process.",
        "operationId": "handle_sampling_protocol_sampling_createMessage_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tools/": {
      "get": {
        "tags": [
          "Tools"
        ],
        "summary": "List Tools",
        "description": "List all registered tools with team-based filtering and pagination support.\n\nArgs:\n    cursor: Pagination cursor for fetching the next set of results\n    include_inactive: Whether to include inactive tools in the results\n    tags: Comma-separated list of tags to filter by (e.g., \"api,data\")\n    team_id: Optional team ID to filter tools by specific team\n    visibility: Optional visibility filter (private, team, public)\n    db: Database session\n    apijsonpath: JSON path modifier to filter or transform the response\n    user: Authenticated user with permissions\n\nReturns:\n    List of tools or modified result based on jsonpath",
        "operationId": "list_tools_tools__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by team ID",
              "title": "Team Id"
            },
            "description": "Filter by team ID"
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by visibility: private, team, public",
              "title": "Visibility"
            },
            "description": "Filter by visibility: private, team, public"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JsonPathModifier"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ToolRead"
                      }
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "additionalProperties": true
                      }
                    },
                    {
                      "type": "object",
                      "additionalProperties": true
                    },
                    {
                      "type": "array",
                      "items": {}
                    }
                  ],
                  "title": "Response List Tools Tools  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Create Tool",
        "description": "Creates a new tool in the system with team assignment support.\n\nArgs:\n    tool (ToolCreate): The data needed to create the tool.\n    request (Request): The FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the tool to.\n    visibility (str): Tool visibility (private, team, public).\n    db (Session): The database session dependency.\n    user: The authenticated user making the request.\n\nReturns:\n    ToolRead: The created tool data.\n\nRaises:\n    HTTPException: If the tool name already exists or other validation errors occur.",
        "operationId": "create_tool_tools__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_tool_tools__post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tools": {
      "get": {
        "tags": [
          "Tools"
        ],
        "summary": "List Tools",
        "description": "List all registered tools with team-based filtering and pagination support.\n\nArgs:\n    cursor: Pagination cursor for fetching the next set of results\n    include_inactive: Whether to include inactive tools in the results\n    tags: Comma-separated list of tags to filter by (e.g., \"api,data\")\n    team_id: Optional team ID to filter tools by specific team\n    visibility: Optional visibility filter (private, team, public)\n    db: Database session\n    apijsonpath: JSON path modifier to filter or transform the response\n    user: Authenticated user with permissions\n\nReturns:\n    List of tools or modified result based on jsonpath",
        "operationId": "list_tools_tools_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by team ID",
              "title": "Team Id"
            },
            "description": "Filter by team ID"
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by visibility: private, team, public",
              "title": "Visibility"
            },
            "description": "Filter by visibility: private, team, public"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JsonPathModifier"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ToolRead"
                      }
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "additionalProperties": true
                      }
                    },
                    {
                      "type": "object",
                      "additionalProperties": true
                    },
                    {
                      "type": "array",
                      "items": {}
                    }
                  ],
                  "title": "Response List Tools Tools Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Create Tool",
        "description": "Creates a new tool in the system with team assignment support.\n\nArgs:\n    tool (ToolCreate): The data needed to create the tool.\n    request (Request): The FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the tool to.\n    visibility (str): Tool visibility (private, team, public).\n    db (Session): The database session dependency.\n    user: The authenticated user making the request.\n\nReturns:\n    ToolRead: The created tool data.\n\nRaises:\n    HTTPException: If the tool name already exists or other validation errors occur.",
        "operationId": "create_tool_tools_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_tool_tools_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tools/{tool_id}": {
      "get": {
        "tags": [
          "Tools"
        ],
        "summary": "Get Tool",
        "description": "Retrieve a tool by ID, optionally applying a JSONPath post-filter.\n\nArgs:\n    tool_id: The numeric ID of the tool.\n    db:     Active SQLAlchemy session (dependency).\n    user:   Authenticated username (dependency).\n    apijsonpath: Optional JSON-Path modifier supplied in the body.\n\nReturns:\n    The raw ``ToolRead`` model **or** a JSON-transformed ``dict`` if\n    a JSONPath filter/mapping was supplied.\n\nRaises:\n    HTTPException: If the tool does not exist or the transformation fails.",
        "operationId": "get_tool_tools__tool_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/JsonPathModifier"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "anyOf": [
                    {
                      "$ref": "#/components/schemas/ToolRead"
                    },
                    {
                      "type": "object",
                      "additionalProperties": true
                    }
                  ],
                  "title": "Response Get Tool Tools  Tool Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Tools"
        ],
        "summary": "Update Tool",
        "description": "Updates an existing tool with new data.\n\nArgs:\n    tool_id (str): The ID of the tool to update.\n    tool (ToolUpdate): The updated tool information.\n    request (Request): The FastAPI request object for metadata extraction.\n    db (Session): The database session dependency.\n    user (str): The authenticated user making the request.\n\nReturns:\n    ToolRead: The updated tool data.\n\nRaises:\n    HTTPException: If an error occurs during the update.",
        "operationId": "update_tool_tools__tool_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ToolUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Tools"
        ],
        "summary": "Delete Tool",
        "description": "Permanently deletes a tool by ID.\n\nArgs:\n    tool_id (str): The ID of the tool to delete.\n    db (Session): The database session dependency.\n    user (str): The authenticated user making the request.\n\nReturns:\n    Dict[str, str]: A confirmation message upon successful deletion.\n\nRaises:\n    HTTPException: If an error occurs during deletion.",
        "operationId": "delete_tool_tools__tool_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Tool Tools  Tool Id  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tools/{tool_id}/toggle": {
      "post": {
        "tags": [
          "Tools"
        ],
        "summary": "Toggle Tool Status",
        "description": "Activates or deactivates a tool.\n\nArgs:\n    tool_id (str): The ID of the tool to toggle.\n    activate (bool): Whether to activate (`True`) or deactivate (`False`) the tool.\n    db (Session): The database session dependency.\n    user (str): The authenticated user making the request.\n\nReturns:\n    Dict[str, Any]: The status, message, and updated tool data.\n\nRaises:\n    HTTPException: If an error occurs during status toggling.",
        "operationId": "toggle_tool_status_tools__tool_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "activate",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Activate"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Toggle Tool Status Tools  Tool Id  Toggle Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/resources/templates/list": {
      "get": {
        "tags": [
          "Resources"
        ],
        "summary": "List Resource Templates",
        "description": "List all available resource templates.\n\nArgs:\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    ListResourceTemplatesResult: A paginated list of resource templates.",
        "operationId": "list_resource_templates_resources_templates_list_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListResourceTemplatesResult"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/resources/{resource_id}/toggle": {
      "post": {
        "tags": [
          "Resources"
        ],
        "summary": "Toggle Resource Status",
        "description": "Activate or deactivate a resource by its ID.\n\nArgs:\n    resource_id (int): The ID of the resource.\n    activate (bool): True to activate, False to deactivate.\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    Dict[str, Any]: Status message and updated resource data.\n\nRaises:\n    HTTPException: If toggling fails.",
        "operationId": "toggle_resource_status_resources__resource_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Resource Id"
            }
          },
          {
            "name": "activate",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Activate"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Toggle Resource Status Resources  Resource Id  Toggle Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/resources/": {
      "get": {
        "tags": [
          "Resources"
        ],
        "summary": "List Resources",
        "description": "Retrieve a list of resources accessible to the user, with team filtering support.\n\nArgs:\n    cursor (Optional[str]): Optional cursor for pagination.\n    include_inactive (bool): Whether to include inactive resources.\n    tags (Optional[str]): Comma-separated list of tags to filter by.\n    team_id (Optional[str]): Filter by specific team ID.\n    visibility (Optional[str]): Filter by visibility (private, team, public).\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    List[ResourceRead]: List of resources the user has access to.",
        "operationId": "list_resources_resources__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visibility"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ResourceRead"
                  },
                  "title": "Response List Resources Resources  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Resources"
        ],
        "summary": "Create Resource",
        "description": "Create a new resource.\n\nArgs:\n    resource (ResourceCreate): Data for the new resource.\n    request (Request): FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the resource to.\n    visibility (str): Resource visibility level (private, team, public).\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    ResourceRead: The created resource.\n\nRaises:\n    HTTPException: On conflict or validation errors or IntegrityError.",
        "operationId": "create_resource_resources__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_resource_resources__post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/resources": {
      "get": {
        "tags": [
          "Resources"
        ],
        "summary": "List Resources",
        "description": "Retrieve a list of resources accessible to the user, with team filtering support.\n\nArgs:\n    cursor (Optional[str]): Optional cursor for pagination.\n    include_inactive (bool): Whether to include inactive resources.\n    tags (Optional[str]): Comma-separated list of tags to filter by.\n    team_id (Optional[str]): Filter by specific team ID.\n    visibility (Optional[str]): Filter by visibility (private, team, public).\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    List[ResourceRead]: List of resources the user has access to.",
        "operationId": "list_resources_resources_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visibility"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ResourceRead"
                  },
                  "title": "Response List Resources Resources Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Resources"
        ],
        "summary": "Create Resource",
        "description": "Create a new resource.\n\nArgs:\n    resource (ResourceCreate): Data for the new resource.\n    request (Request): FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the resource to.\n    visibility (str): Resource visibility level (private, team, public).\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    ResourceRead: The created resource.\n\nRaises:\n    HTTPException: On conflict or validation errors or IntegrityError.",
        "operationId": "create_resource_resources_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_resource_resources_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/resources/{resource_id}": {
      "get": {
        "tags": [
          "Resources"
        ],
        "summary": "Read Resource",
        "description": "Read a resource by its ID with plugin support.\n\nArgs:\n    resource_id (str): ID of the resource.\n    request (Request): FastAPI request object for context.\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    Any: The content of the resource.\n\nRaises:\n    HTTPException: If the resource cannot be found or read.",
        "operationId": "read_resource_resources__resource_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Read Resource Resources  Resource Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Resources"
        ],
        "summary": "Update Resource",
        "description": "Update a resource identified by its ID.\n\nArgs:\n    resource_id (str): ID of the resource.\n    resource (ResourceUpdate): New resource data.\n    request (Request): The FastAPI request object for metadata extraction.\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    ResourceRead: The updated resource.\n\nRaises:\n    HTTPException: If the resource is not found or update fails.",
        "operationId": "update_resource_resources__resource_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ResourceUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ResourceRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Resources"
        ],
        "summary": "Delete Resource",
        "description": "Delete a resource by its ID.\n\nArgs:\n    resource_id (str): ID of the resource to delete.\n    db (Session): Database session.\n    user (str): Authenticated user.\n\nReturns:\n    Dict[str, str]: Status message indicating deletion success.\n\nRaises:\n    HTTPException: If the resource is not found or deletion fails.",
        "operationId": "delete_resource_resources__resource_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Resource Resources  Resource Id  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/resources/subscribe/{resource_id}": {
      "post": {
        "tags": [
          "Resources"
        ],
        "summary": "Subscribe Resource",
        "description": "Subscribe to server-sent events (SSE) for a specific resource.\n\nArgs:\n    resource_id (str): ID of the resource to subscribe to.\n    user (str): Authenticated user.\n\nReturns:\n    StreamingResponse: A streaming response with event updates.",
        "operationId": "subscribe_resource_resources_subscribe__resource_id__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/prompts/{prompt_id}/toggle": {
      "post": {
        "tags": [
          "Prompts"
        ],
        "summary": "Toggle Prompt Status",
        "description": "Toggle the activation status of a prompt.\n\nArgs:\n    prompt_id: ID of the prompt to toggle.\n    activate: True to activate, False to deactivate.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Status message and updated prompt details.\n\nRaises:\n    HTTPException: If the toggle fails (e.g., prompt not found or database error); emitted with *400 Bad Request* status and an error message.",
        "operationId": "toggle_prompt_status_prompts__prompt_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Prompt Id"
            }
          },
          {
            "name": "activate",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Activate"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Toggle Prompt Status Prompts  Prompt Id  Toggle Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/prompts/": {
      "get": {
        "tags": [
          "Prompts"
        ],
        "summary": "List Prompts",
        "description": "List prompts accessible to the user, with team filtering support.\n\nArgs:\n    cursor: Cursor for pagination.\n    include_inactive: Include inactive prompts.\n    tags: Comma-separated list of tags to filter by.\n    team_id: Filter by specific team ID.\n    visibility: Filter by visibility (private, team, public).\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    List of prompt records the user has access to.",
        "operationId": "list_prompts_prompts__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visibility"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PromptRead"
                  },
                  "title": "Response List Prompts Prompts  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Prompts"
        ],
        "summary": "Create Prompt",
        "description": "Create a new prompt.\n\nArgs:\n    prompt (PromptCreate): Payload describing the prompt to create.\n    request (Request): The FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the prompt to.\n    visibility (str): Prompt visibility level (private, team, public).\n    db (Session): Active SQLAlchemy session.\n    user (str): Authenticated username.\n\nReturns:\n    PromptRead: The newly-created prompt.\n\nRaises:\n    HTTPException: * **409 Conflict** - another prompt with the same name already exists.\n        * **400 Bad Request** - validation or persistence error raised\n            by :pyclass:`~mcpgateway.services.prompt_service.PromptService`.",
        "operationId": "create_prompt_prompts__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_prompt_prompts__post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/prompts": {
      "get": {
        "tags": [
          "Prompts"
        ],
        "summary": "List Prompts",
        "description": "List prompts accessible to the user, with team filtering support.\n\nArgs:\n    cursor: Cursor for pagination.\n    include_inactive: Include inactive prompts.\n    tags: Comma-separated list of tags to filter by.\n    team_id: Filter by specific team ID.\n    visibility: Filter by visibility (private, team, public).\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    List of prompt records the user has access to.",
        "operationId": "list_prompts_prompts_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "cursor",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Cursor"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visibility"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PromptRead"
                  },
                  "title": "Response List Prompts Prompts Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Prompts"
        ],
        "summary": "Create Prompt",
        "description": "Create a new prompt.\n\nArgs:\n    prompt (PromptCreate): Payload describing the prompt to create.\n    request (Request): The FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the prompt to.\n    visibility (str): Prompt visibility level (private, team, public).\n    db (Session): Active SQLAlchemy session.\n    user (str): Authenticated username.\n\nReturns:\n    PromptRead: The newly-created prompt.\n\nRaises:\n    HTTPException: * **409 Conflict** - another prompt with the same name already exists.\n        * **400 Bad Request** - validation or persistence error raised\n            by :pyclass:`~mcpgateway.services.prompt_service.PromptService`.",
        "operationId": "create_prompt_prompts_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_prompt_prompts_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/prompts/{prompt_id}": {
      "post": {
        "tags": [
          "Prompts"
        ],
        "summary": "Get Prompt",
        "description": "Get a prompt by prompt_id with arguments.\n\nThis implements the prompts/get functionality from the MCP spec,\nwhich requires a POST request with arguments in the body.\n\n\nArgs:\n    prompt_id: ID of the prompt.\n    args: Template arguments.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Rendered prompt or metadata.\n\nRaises:\n    Exception: Re-raised if not a handled exception type.",
        "operationId": "get_prompt_prompts__prompt_id__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                },
                "default": {},
                "title": "Args"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Get Prompt Prompts  Prompt Id  Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Prompts"
        ],
        "summary": "Get Prompt No Args",
        "description": "Get a prompt by ID without arguments.\n\nThis endpoint is for convenience when no arguments are needed.\n\nArgs:\n    prompt_id: The ID of the prompt to retrieve\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    The prompt template information\n\nRaises:\n    Exception: Re-raised from prompt service.",
        "operationId": "get_prompt_no_args_prompts__prompt_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "title": "Response Get Prompt No Args Prompts  Prompt Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Prompts"
        ],
        "summary": "Update Prompt",
        "description": "Update (overwrite) an existing prompt definition.\n\nArgs:\n    prompt_id (str): Identifier of the prompt to update.\n    prompt (PromptUpdate): New prompt content and metadata.\n    request (Request): The FastAPI request object for metadata extraction.\n    db (Session): Active SQLAlchemy session.\n    user (str): Authenticated username.\n\nReturns:\n    PromptRead: The updated prompt object.\n\nRaises:\n    HTTPException: * **409 Conflict** - a different prompt with the same *name* already exists and is still active.\n        * **400 Bad Request** - validation or persistence error raised by :pyclass:`~mcpgateway.services.prompt_service.PromptService`.",
        "operationId": "update_prompt_prompts__prompt_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PromptUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PromptRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Prompts"
        ],
        "summary": "Delete Prompt",
        "description": "Delete a prompt by ID.\n\nArgs:\n    prompt_id: ID of the prompt.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Status message.\n\nRaises:\n    HTTPException: If the prompt is not found, a prompt error occurs, or an unexpected error occurs during deletion.",
        "operationId": "delete_prompt_prompts__prompt_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Prompt Prompts  Prompt Id  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/gateways/{gateway_id}/toggle": {
      "post": {
        "tags": [
          "Gateways"
        ],
        "summary": "Toggle Gateway Status",
        "description": "Toggle the activation status of a gateway.\n\nArgs:\n    gateway_id (str): String ID of the gateway to toggle.\n    activate (bool): ``True`` to activate, ``False`` to deactivate.\n    db (Session): Active SQLAlchemy session.\n    user (str): Authenticated username.\n\nReturns:\n    Dict[str, Any]: A dict containing the operation status, a message, and the updated gateway object.\n\nRaises:\n    HTTPException: Returned with **400 Bad Request** if the toggle operation fails (e.g., the gateway does not exist or the database raises an unexpected error).",
        "operationId": "toggle_gateway_status_gateways__gateway_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "activate",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Activate"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Toggle Gateway Status Gateways  Gateway Id  Toggle Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/gateways/": {
      "get": {
        "tags": [
          "Gateways"
        ],
        "summary": "List Gateways",
        "description": "List all gateways.\n\nArgs:\n    include_inactive: Include inactive gateways.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    List of gateway records.",
        "operationId": "list_gateways_gateways__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GatewayRead"
                  },
                  "title": "Response List Gateways Gateways  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Gateways"
        ],
        "summary": "Register Gateway",
        "description": "Register a new gateway.\n\nArgs:\n    gateway: Gateway creation data.\n    request: The FastAPI request object for metadata extraction.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Created gateway.",
        "operationId": "register_gateway_gateways__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GatewayCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GatewayRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/gateways": {
      "get": {
        "tags": [
          "Gateways"
        ],
        "summary": "List Gateways",
        "description": "List all gateways.\n\nArgs:\n    include_inactive: Include inactive gateways.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    List of gateway records.",
        "operationId": "list_gateways_gateways_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GatewayRead"
                  },
                  "title": "Response List Gateways Gateways Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Gateways"
        ],
        "summary": "Register Gateway",
        "description": "Register a new gateway.\n\nArgs:\n    gateway: Gateway creation data.\n    request: The FastAPI request object for metadata extraction.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Created gateway.",
        "operationId": "register_gateway_gateways_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GatewayCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GatewayRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/gateways/{gateway_id}": {
      "get": {
        "tags": [
          "Gateways"
        ],
        "summary": "Get Gateway",
        "description": "Retrieve a gateway by ID.\n\nArgs:\n    gateway_id: ID of the gateway.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Gateway data.",
        "operationId": "get_gateway_gateways__gateway_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GatewayRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Gateways"
        ],
        "summary": "Update Gateway",
        "description": "Update a gateway.\n\nArgs:\n    gateway_id: Gateway ID.\n    gateway: Gateway update data.\n    request (Request): The FastAPI request object for metadata extraction.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Updated gateway.",
        "operationId": "update_gateway_gateways__gateway_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GatewayUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GatewayRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Gateways"
        ],
        "summary": "Delete Gateway",
        "description": "Delete a gateway by ID.\n\nArgs:\n    gateway_id: ID of the gateway.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Status message.\n\nRaises:\n    HTTPException: If permission denied (403), gateway not found (404), or other gateway error (400).",
        "operationId": "delete_gateway_gateways__gateway_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Gateway Gateways  Gateway Id  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/roots/": {
      "get": {
        "tags": [
          "Roots"
        ],
        "summary": "List Roots",
        "description": "Retrieve a list of all registered roots.\n\nArgs:\n    user: Authenticated user.\n\nReturns:\n    List of Root objects.",
        "operationId": "list_roots_roots__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Root"
                  },
                  "title": "Response List Roots Roots  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Roots"
        ],
        "summary": "Add Root",
        "description": "Add a new root.\n\nArgs:\n    root: Root object containing URI and name.\n    user: Authenticated user.\n\nReturns:\n    The added Root object.",
        "operationId": "add_root_roots__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Root"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Root"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/roots": {
      "get": {
        "tags": [
          "Roots"
        ],
        "summary": "List Roots",
        "description": "Retrieve a list of all registered roots.\n\nArgs:\n    user: Authenticated user.\n\nReturns:\n    List of Root objects.",
        "operationId": "list_roots_roots_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Root"
                  },
                  "title": "Response List Roots Roots Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Roots"
        ],
        "summary": "Add Root",
        "description": "Add a new root.\n\nArgs:\n    root: Root object containing URI and name.\n    user: Authenticated user.\n\nReturns:\n    The added Root object.",
        "operationId": "add_root_roots_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Root"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Root"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/roots/{uri}": {
      "delete": {
        "tags": [
          "Roots"
        ],
        "summary": "Remove Root",
        "description": "Remove a registered root by URI.\n\nArgs:\n    uri: URI of the root to remove.\n    user: Authenticated user.\n\nReturns:\n    Status message indicating result.",
        "operationId": "remove_root_roots__uri__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "uri",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Uri"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Remove Root Roots  Uri  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/roots/changes": {
      "get": {
        "tags": [
          "Roots"
        ],
        "summary": "Subscribe Roots Changes",
        "description": "Subscribe to real-time changes in root list via Server-Sent Events (SSE).\n\nArgs:\n    user: Authenticated user.\n\nReturns:\n    StreamingResponse with event-stream media type.",
        "operationId": "subscribe_roots_changes_roots_changes_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rpc": {
      "post": {
        "tags": [
          "Utilities"
        ],
        "summary": "Handle Rpc",
        "description": "Handle RPC requests.\n\nArgs:\n    request (Request): The incoming FastAPI request.\n    db (Session): Database session.\n    user: The authenticated user (dict with RBAC context).\n\nReturns:\n    Response with the RPC result or error.\n\nRaises:\n    PluginError: If encounters issue with plugin\n    PluginViolationError: If plugin violated the request. Example - In case of OPA plugin, if the request is denied by policy.",
        "operationId": "handle_rpc_rpc_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rpc/": {
      "post": {
        "tags": [
          "Utilities"
        ],
        "summary": "Handle Rpc",
        "description": "Handle RPC requests.\n\nArgs:\n    request (Request): The incoming FastAPI request.\n    db (Session): Database session.\n    user: The authenticated user (dict with RBAC context).\n\nReturns:\n    Response with the RPC result or error.\n\nRaises:\n    PluginError: If encounters issue with plugin\n    PluginViolationError: If plugin violated the request. Example - In case of OPA plugin, if the request is denied by policy.",
        "operationId": "handle_rpc_rpc__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/sse": {
      "get": {
        "tags": [
          "Utilities"
        ],
        "summary": "Utility Sse Endpoint",
        "description": "Establish a Server-Sent Events (SSE) connection for real-time updates.\n\nArgs:\n    request (Request): The incoming HTTP request.\n    user (str): Authenticated username.\n\nReturns:\n    StreamingResponse: A streaming response that keeps the connection\n    open and pushes events to the client.\n\nRaises:\n    HTTPException: Returned with **500 Internal Server Error** if the SSE connection cannot be established or an unexpected error occurs while creating the transport.",
        "operationId": "utility_sse_endpoint_sse_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/message": {
      "post": {
        "tags": [
          "Utilities"
        ],
        "summary": "Utility Message Endpoint",
        "description": "Handle a JSON-RPC message directed to a specific SSE session.\n\nArgs:\n    request (Request): Incoming request containing the JSON-RPC payload.\n    user (str): Authenticated user.\n\nReturns:\n    JSONResponse: ``{\"status\": \"success\"}`` with HTTP 202 on success.\n\nRaises:\n    HTTPException: * **400 Bad Request** - ``session_id`` query parameter is missing or the payload cannot be parsed as JSON.\n        * **500 Internal Server Error** - An unexpected error occurs while broadcasting the message.",
        "operationId": "utility_message_endpoint_message_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/logging/setLevel": {
      "post": {
        "tags": [
          "Utilities"
        ],
        "summary": "Set Log Level",
        "description": "Update the server's log level at runtime.\n\nArgs:\n    request: HTTP request with log level JSON body.\n    user: Authenticated user.\n\nReturns:\n    None",
        "operationId": "set_log_level_logging_setLevel_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/": {
      "get": {
        "tags": [
          "Servers"
        ],
        "summary": "List Servers",
        "description": "Lists servers accessible to the user, with team filtering support.\n\nArgs:\n    include_inactive (bool): Whether to include inactive servers in the response.\n    tags (Optional[str]): Comma-separated list of tags to filter by.\n    team_id (Optional[str]): Filter by specific team ID.\n    visibility (Optional[str]): Filter by visibility (private, team, public).\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    List[ServerRead]: A list of server objects the user has access to.",
        "operationId": "list_servers_servers__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visibility"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ServerRead"
                  },
                  "title": "Response List Servers Servers  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Servers"
        ],
        "summary": "Create Server",
        "description": "Creates a new server.\n\nArgs:\n    server (ServerCreate): The data for the new server.\n    request (Request): The incoming request object for extracting metadata.\n    team_id (Optional[str]): Team ID to assign the server to.\n    visibility (str): Server visibility level (private, team, public).\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    ServerRead: The created server object.\n\nRaises:\n    HTTPException: If there is a conflict with the server name or other errors.",
        "operationId": "create_server_servers__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_server_servers__post"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers": {
      "get": {
        "tags": [
          "Servers"
        ],
        "summary": "List Servers",
        "description": "Lists servers accessible to the user, with team filtering support.\n\nArgs:\n    include_inactive (bool): Whether to include inactive servers in the response.\n    tags (Optional[str]): Comma-separated list of tags to filter by.\n    team_id (Optional[str]): Filter by specific team ID.\n    visibility (Optional[str]): Filter by visibility (private, team, public).\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    List[ServerRead]: A list of server objects the user has access to.",
        "operationId": "list_servers_servers_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Visibility"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ServerRead"
                  },
                  "title": "Response List Servers Servers Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Servers"
        ],
        "summary": "Create Server",
        "description": "Creates a new server.\n\nArgs:\n    server (ServerCreate): The data for the new server.\n    request (Request): The incoming request object for extracting metadata.\n    team_id (Optional[str]): Team ID to assign the server to.\n    visibility (str): Server visibility level (private, team, public).\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    ServerRead: The created server object.\n\nRaises:\n    HTTPException: If there is a conflict with the server name or other errors.",
        "operationId": "create_server_servers_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_server_servers_post"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/{server_id}": {
      "get": {
        "tags": [
          "Servers"
        ],
        "summary": "Get Server",
        "description": "Retrieves a server by its ID.\n\nArgs:\n    server_id (str): The ID of the server to retrieve.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    ServerRead: The server object with the specified ID.\n\nRaises:\n    HTTPException: If the server is not found.",
        "operationId": "get_server_servers__server_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Servers"
        ],
        "summary": "Update Server",
        "description": "Updates the information of an existing server.\n\nArgs:\n    server_id (str): The ID of the server to update.\n    server (ServerUpdate): The updated server data.\n    request (Request): The incoming request object containing metadata.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    ServerRead: The updated server object.\n\nRaises:\n    HTTPException: If the server is not found, there is a name conflict, or other errors.",
        "operationId": "update_server_servers__server_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ServerUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Servers"
        ],
        "summary": "Delete Server",
        "description": "Deletes a server by its ID.\n\nArgs:\n    server_id (str): The ID of the server to delete.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    Dict[str, str]: A success message indicating the server was deleted.\n\nRaises:\n    HTTPException: If the server is not found or there is an error.",
        "operationId": "delete_server_servers__server_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete Server Servers  Server Id  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/{server_id}/toggle": {
      "post": {
        "tags": [
          "Servers"
        ],
        "summary": "Toggle Server Status",
        "description": "Toggles the status of a server (activate or deactivate).\n\nArgs:\n    server_id (str): The ID of the server to toggle.\n    activate (bool): Whether to activate or deactivate the server.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    ServerRead: The server object after the status change.\n\nRaises:\n    HTTPException: If the server is not found or there is an error.",
        "operationId": "toggle_server_status_servers__server_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "activate",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Activate"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/{server_id}/sse": {
      "get": {
        "tags": [
          "Servers"
        ],
        "summary": "Sse Endpoint",
        "description": "Establishes a Server-Sent Events (SSE) connection for real-time updates about a server.\n\nArgs:\n    request (Request): The incoming request.\n    server_id (str): The ID of the server for which updates are received.\n    user (str): The authenticated user making the request.\n\nReturns:\n    The SSE response object for the established connection.\n\nRaises:\n    HTTPException: If there is an error in establishing the SSE connection.",
        "operationId": "sse_endpoint_servers__server_id__sse_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/{server_id}/message": {
      "post": {
        "tags": [
          "Servers"
        ],
        "summary": "Message Endpoint",
        "description": "Handles incoming messages for a specific server.\n\nArgs:\n    request (Request): The incoming message request.\n    server_id (str): The ID of the server receiving the message.\n    user (str): The authenticated user making the request.\n\nReturns:\n    JSONResponse: A success status after processing the message.\n\nRaises:\n    HTTPException: If there are errors processing the message.",
        "operationId": "message_endpoint_servers__server_id__message_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/{server_id}/tools": {
      "get": {
        "tags": [
          "Servers"
        ],
        "summary": "Server Get Tools",
        "description": "List tools for the server  with an option to include inactive tools.\n\nThis endpoint retrieves a list of tools from the database, optionally including\nthose that are inactive. The inactive filter helps administrators manage tools\nthat have been deactivated but not deleted from the system.\n\nArgs:\n    server_id (str): ID of the server\n    include_inactive (bool): Whether to include inactive tools in the results.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    List[ToolRead]: A list of tool records formatted with by_alias=True.",
        "operationId": "server_get_tools_servers__server_id__tools_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ToolRead"
                  },
                  "title": "Response Server Get Tools Servers  Server Id  Tools Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/{server_id}/resources": {
      "get": {
        "tags": [
          "Servers"
        ],
        "summary": "Server Get Resources",
        "description": "List resources for the server with an option to include inactive resources.\n\nThis endpoint retrieves a list of resources from the database, optionally including\nthose that are inactive. The inactive filter is useful for administrators who need\nto view or manage resources that have been deactivated but not deleted.\n\nArgs:\n    server_id (str): ID of the server\n    include_inactive (bool): Whether to include inactive resources in the results.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    List[ResourceRead]: A list of resource records formatted with by_alias=True.",
        "operationId": "server_get_resources_servers__server_id__resources_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ResourceRead"
                  },
                  "title": "Response Server Get Resources Servers  Server Id  Resources Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/servers/{server_id}/prompts": {
      "get": {
        "tags": [
          "Servers"
        ],
        "summary": "Server Get Prompts",
        "description": "List prompts for the server with an option to include inactive prompts.\n\nThis endpoint retrieves a list of prompts from the database, optionally including\nthose that are inactive. The inactive filter helps administrators see and manage\nprompts that have been deactivated but not deleted from the system.\n\nArgs:\n    server_id (str): ID of the server\n    include_inactive (bool): Whether to include inactive prompts in the results.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    List[PromptRead]: A list of prompt records formatted with by_alias=True.",
        "operationId": "server_get_prompts_servers__server_id__prompts_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PromptRead"
                  },
                  "title": "Response Server Get Prompts Servers  Server Id  Prompts Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/metrics": {
      "get": {
        "tags": [
          "Metrics"
        ],
        "summary": "Get Metrics",
        "description": "Retrieve aggregated metrics for all entity types (Tools, Resources, Servers, Prompts, A2A Agents).\n\nArgs:\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    A dictionary with keys for each entity type and their aggregated metrics.",
        "operationId": "get_metrics_metrics_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Metrics Metrics Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/metrics/reset": {
      "post": {
        "tags": [
          "Metrics"
        ],
        "summary": "Reset Metrics",
        "description": "Reset metrics for a specific entity type and optionally a specific entity ID,\nor perform a global reset if no entity is specified.\n\nArgs:\n    entity: One of \"tool\", \"resource\", \"server\", \"prompt\", \"a2a_agent\", or None for global reset.\n    entity_id: Specific entity ID to reset metrics for (optional).\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    A success message in a dictionary.\n\nRaises:\n    HTTPException: If an invalid entity type is specified.",
        "operationId": "reset_metrics_metrics_reset_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entity",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity"
            }
          },
          {
            "name": "entity_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "integer"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Reset Metrics Metrics Reset Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tags/": {
      "get": {
        "tags": [
          "Tags"
        ],
        "summary": "List Tags",
        "description": "Retrieve all unique tags across specified entity types.\n\nArgs:\n    entity_types: Comma-separated list of entity types to filter by\n                 (e.g., \"tools,resources,prompts,servers,gateways\").\n                 If not provided, returns tags from all entity types.\n    include_entities: Whether to include the list of entities that have each tag\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    List of TagInfo objects containing tag names, statistics, and optionally entities\n\nRaises:\n    HTTPException: If tag retrieval fails",
        "operationId": "list_tags_tags__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entity_types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Types"
            }
          },
          {
            "name": "include_entities",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Entities"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TagInfo"
                  },
                  "title": "Response List Tags Tags  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tags": {
      "get": {
        "tags": [
          "Tags"
        ],
        "summary": "List Tags",
        "description": "Retrieve all unique tags across specified entity types.\n\nArgs:\n    entity_types: Comma-separated list of entity types to filter by\n                 (e.g., \"tools,resources,prompts,servers,gateways\").\n                 If not provided, returns tags from all entity types.\n    include_entities: Whether to include the list of entities that have each tag\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    List of TagInfo objects containing tag names, statistics, and optionally entities\n\nRaises:\n    HTTPException: If tag retrieval fails",
        "operationId": "list_tags_tags_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entity_types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Types"
            }
          },
          {
            "name": "include_entities",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Entities"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TagInfo"
                  },
                  "title": "Response List Tags Tags Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tags/{tag_name}/entities": {
      "get": {
        "tags": [
          "Tags"
        ],
        "summary": "Get Entities By Tag",
        "description": "Get all entities that have a specific tag.\n\nArgs:\n    tag_name: The tag to search for\n    entity_types: Comma-separated list of entity types to filter by\n                 (e.g., \"tools,resources,prompts,servers,gateways\").\n                 If not provided, returns entities from all types.\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    List of TaggedEntity objects\n\nRaises:\n    HTTPException: If entity retrieval fails",
        "operationId": "get_entities_by_tag_tags__tag_name__entities_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tag_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tag Name"
            }
          },
          {
            "name": "entity_types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Types"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TaggedEntity"
                  },
                  "title": "Response Get Entities By Tag Tags  Tag Name  Entities Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/export": {
      "get": {
        "tags": [
          "Export/Import"
        ],
        "summary": "Export Configuration",
        "description": "Export gateway configuration to JSON format.\n\nArgs:\n    request: FastAPI request object for extracting root path\n    export_format: Export format (currently only 'json' supported)\n    types: Comma-separated list of entity types to include (tools,gateways,servers,prompts,resources,roots)\n    exclude_types: Comma-separated list of entity types to exclude\n    tags: Comma-separated list of tags to filter by\n    include_inactive: Whether to include inactive entities\n    include_dependencies: Whether to include dependent entities\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Export data in the specified format\n\nRaises:\n    HTTPException: If export fails",
        "operationId": "export_configuration_export_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "export_format",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": "json",
              "title": "Export Format"
            }
          },
          {
            "name": "types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Types"
            }
          },
          {
            "name": "exclude_types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Exclude Types"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "include_dependencies",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Include Dependencies"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Export Configuration Export Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/export/selective": {
      "post": {
        "tags": [
          "Export/Import"
        ],
        "summary": "Export Selective Configuration",
        "description": "Export specific entities by their IDs/names.\n\nArgs:\n    entity_selections: Dict mapping entity types to lists of IDs/names to export\n    include_dependencies: Whether to include dependent entities\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Selective export data\n\nRaises:\n    HTTPException: If export fails\n\nExample request body:\n    {\n        \"tools\": [\"tool1\", \"tool2\"],\n        \"servers\": [\"server1\"],\n        \"prompts\": [\"prompt1\"]\n    }",
        "operationId": "export_selective_configuration_export_selective_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_dependencies",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Include Dependencies"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "title": "Entity Selections"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Export Selective Configuration Export Selective Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/import": {
      "post": {
        "tags": [
          "Export/Import"
        ],
        "summary": "Import Configuration",
        "description": "Import configuration data with conflict resolution.\n\nArgs:\n    import_data: The configuration data to import\n    conflict_strategy: How to handle conflicts: skip, update, rename, fail\n    dry_run: If true, validate but don't make changes\n    rekey_secret: New encryption secret for cross-environment imports\n    selected_entities: Dict of entity types to specific entity names/ids to import\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Import status and results\n\nRaises:\n    HTTPException: If import fails or validation errors occur",
        "operationId": "import_configuration_import_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "conflict_strategy",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": "update",
              "title": "Conflict Strategy"
            }
          },
          {
            "name": "dry_run",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Dry Run"
            }
          },
          {
            "name": "rekey_secret",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Rekey Secret"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_import_configuration_import_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Import Configuration Import Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/import/status/{import_id}": {
      "get": {
        "tags": [
          "Export/Import"
        ],
        "summary": "Get Import Status",
        "description": "Get the status of an import operation.\n\nArgs:\n    import_id: The import operation ID\n    user: Authenticated user\n\nReturns:\n    Import status information\n\nRaises:\n    HTTPException: If import not found",
        "operationId": "get_import_status_import_status__import_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "import_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Import Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Import Status Import Status  Import Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/import/status": {
      "get": {
        "tags": [
          "Export/Import"
        ],
        "summary": "List Import Statuses",
        "description": "List all import operation statuses.\n\nArgs:\n    user: Authenticated user\n\nReturns:\n    List of import status information",
        "operationId": "list_import_statuses_import_status_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response List Import Statuses Import Status Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/import/cleanup": {
      "post": {
        "tags": [
          "Export/Import"
        ],
        "summary": "Cleanup Import Statuses",
        "description": "Clean up completed import statuses older than specified age.\n\nArgs:\n    max_age_hours: Maximum age in hours for keeping completed imports\n    user: Authenticated user\n\nReturns:\n    Cleanup results",
        "operationId": "cleanup_import_statuses_import_cleanup_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "max_age_hours",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 24,
              "title": "Max Age Hours"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Cleanup Import Statuses Import Cleanup Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/a2a/": {
      "get": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "List A2A Agents",
        "description": "Lists A2A agents user has access to with team filtering.\n\nArgs:\n    include_inactive (bool): Whether to include inactive agents in the response.\n    tags (Optional[str]): Comma-separated list of tags to filter by.\n    team_id (Optional[str]): Team ID to filter by.\n    visibility (Optional[str]): Visibility level to filter by.\n    skip (int): Number of agents to skip for pagination.\n    limit (int): Maximum number of agents to return.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    List[A2AAgentRead]: A list of A2A agent objects the user has access to.\n\nRaises:\n    HTTPException: If A2A service is not available.",
        "operationId": "list_a2a_agents_a2a__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by team ID",
              "title": "Team Id"
            },
            "description": "Filter by team ID"
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by visibility (private, team, public)",
              "title": "Visibility"
            },
            "description": "Filter by visibility (private, team, public)"
          },
          {
            "name": "skip",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of agents to skip for pagination",
              "default": 0,
              "title": "Skip"
            },
            "description": "Number of agents to skip for pagination"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of agents to return",
              "default": 100,
              "title": "Limit"
            },
            "description": "Maximum number of agents to return"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/A2AAgentRead"
                  },
                  "title": "Response List A2A Agents A2A  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "Create A2A Agent",
        "description": "Creates a new A2A agent.\n\nArgs:\n    agent (A2AAgentCreate): The data for the new agent.\n    request (Request): The FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the agent to.\n    visibility (str): Agent visibility level (private, team, public).\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    A2AAgentRead: The created agent object.\n\nRaises:\n    HTTPException: If there is a conflict with the agent name or other errors.",
        "operationId": "create_a2a_agent_a2a__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_a2a_agent_a2a__post"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/A2AAgentRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/a2a": {
      "get": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "List A2A Agents",
        "description": "Lists A2A agents user has access to with team filtering.\n\nArgs:\n    include_inactive (bool): Whether to include inactive agents in the response.\n    tags (Optional[str]): Comma-separated list of tags to filter by.\n    team_id (Optional[str]): Team ID to filter by.\n    visibility (Optional[str]): Visibility level to filter by.\n    skip (int): Number of agents to skip for pagination.\n    limit (int): Maximum number of agents to return.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    List[A2AAgentRead]: A list of A2A agent objects the user has access to.\n\nRaises:\n    HTTPException: If A2A service is not available.",
        "operationId": "list_a2a_agents_a2a_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by team ID",
              "title": "Team Id"
            },
            "description": "Filter by team ID"
          },
          {
            "name": "visibility",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by visibility (private, team, public)",
              "title": "Visibility"
            },
            "description": "Filter by visibility (private, team, public)"
          },
          {
            "name": "skip",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of agents to skip for pagination",
              "default": 0,
              "title": "Skip"
            },
            "description": "Number of agents to skip for pagination"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 1000,
              "minimum": 1,
              "description": "Maximum number of agents to return",
              "default": 100,
              "title": "Limit"
            },
            "description": "Maximum number of agents to return"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/A2AAgentRead"
                  },
                  "title": "Response List A2A Agents A2A Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "Create A2A Agent",
        "description": "Creates a new A2A agent.\n\nArgs:\n    agent (A2AAgentCreate): The data for the new agent.\n    request (Request): The FastAPI request object for metadata extraction.\n    team_id (Optional[str]): Team ID to assign the agent to.\n    visibility (str): Agent visibility level (private, team, public).\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    A2AAgentRead: The created agent object.\n\nRaises:\n    HTTPException: If there is a conflict with the agent name or other errors.",
        "operationId": "create_a2a_agent_a2a_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_create_a2a_agent_a2a_post"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/A2AAgentRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/a2a/{agent_id}": {
      "get": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "Get A2A Agent",
        "description": "Retrieves an A2A agent by its ID.\n\nArgs:\n    agent_id (str): The ID of the agent to retrieve.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    A2AAgentRead: The agent object with the specified ID.\n\nRaises:\n    HTTPException: If the agent is not found.",
        "operationId": "get_a2a_agent_a2a__agent_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/A2AAgentRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "Update A2A Agent",
        "description": "Updates the information of an existing A2A agent.\n\nArgs:\n    agent_id (str): The ID of the agent to update.\n    agent (A2AAgentUpdate): The updated agent data.\n    request (Request): The FastAPI request object for metadata extraction.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    A2AAgentRead: The updated agent object.\n\nRaises:\n    HTTPException: If the agent is not found, there is a name conflict, or other errors.",
        "operationId": "update_a2a_agent_a2a__agent_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/A2AAgentUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/A2AAgentRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "Delete A2A Agent",
        "description": "Deletes an A2A agent by its ID.\n\nArgs:\n    agent_id (str): The ID of the agent to delete.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    Dict[str, str]: A success message indicating the agent was deleted.\n\nRaises:\n    HTTPException: If the agent is not found or there is an error.",
        "operationId": "delete_a2a_agent_a2a__agent_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  },
                  "title": "Response Delete A2A Agent A2A  Agent Id  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/a2a/{agent_id}/toggle": {
      "post": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "Toggle A2A Agent Status",
        "description": "Toggles the status of an A2A agent (activate or deactivate).\n\nArgs:\n    agent_id (str): The ID of the agent to toggle.\n    activate (bool): Whether to activate or deactivate the agent.\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    A2AAgentRead: The agent object after the status change.\n\nRaises:\n    HTTPException: If the agent is not found or there is an error.",
        "operationId": "toggle_a2a_agent_status_a2a__agent_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "activate",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Activate"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/A2AAgentRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/a2a/{agent_name}/invoke": {
      "post": {
        "tags": [
          "A2A Agents"
        ],
        "summary": "Invoke A2A Agent",
        "description": "Invokes an A2A agent with the specified parameters.\n\nArgs:\n    agent_name (str): The name of the agent to invoke.\n    parameters (Dict[str, Any]): Parameters for the agent interaction.\n    interaction_type (str): Type of interaction (query, execute, etc.).\n    db (Session): The database session used to interact with the data store.\n    user (str): The authenticated user making the request.\n\nReturns:\n    Dict[str, Any]: The response from the A2A agent.\n\nRaises:\n    HTTPException: If the agent is not found or there is an error during invocation.",
        "operationId": "invoke_a2a_agent_a2a__agent_name__invoke_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Name"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/Body_invoke_a2a_agent_a2a__agent_name__invoke_post"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Invoke A2A Agent A2A  Agent Name  Invoke Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/well-known": {
      "get": {
        "tags": [
          "well-known"
        ],
        "summary": "Get Well Known Status",
        "description": "Get status of well-known URI configuration.\n\nArgs:\n    user: Authenticated user from dependency injection.\n\nReturns:\n    Dict containing well-known configuration status and available files.",
        "operationId": "get_well_known_status_admin_well_known_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Well Known Status Admin Well Known Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/email/login": {
      "post": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Login",
        "description": "Authenticate user with email and password.\n\nArgs:\n    login_request: Login credentials\n    request: FastAPI request object\n    db: Database session\n\nReturns:\n    AuthenticationResponse: Access token and user info\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(login)\n    True\n\nRaises:\n    HTTPException: If authentication fails\n\nExamples:\n    Request JSON:\n        {\n          \"email\": \"user@example.com\",\n          \"password\": \"secure_password\"\n        }",
        "operationId": "login_auth_email_login_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmailLoginRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthenticationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/email/register": {
      "post": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Register",
        "description": "Register a new user account.\n\nArgs:\n    registration_request: Registration information\n    request: FastAPI request object\n    db: Database session\n\nReturns:\n    AuthenticationResponse: Access token and user info\n\nRaises:\n    HTTPException: If registration fails\n\nExamples:\n    Request JSON:\n        {\n          \"email\": \"new@example.com\",\n          \"password\": \"secure_password\",\n          \"full_name\": \"New User\"\n        }",
        "operationId": "register_auth_email_register_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmailRegistrationRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthenticationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/email/change-password": {
      "post": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Change Password",
        "description": "Change user's password.\n\nArgs:\n    password_request: Old and new passwords\n    request: FastAPI request object\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    SuccessResponse: Success confirmation\n\nRaises:\n    HTTPException: If password change fails\n\nExamples:\n    Request JSON (with Bearer token in Authorization header):\n        {\n          \"old_password\": \"current_password\",\n          \"new_password\": \"new_secure_password\"\n        }",
        "operationId": "change_password_auth_email_change_password_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ChangePasswordRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBearer": []
          }
        ]
      }
    },
    "/auth/email/me": {
      "get": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Get Current User Profile",
        "description": "Get current user's profile information.\n\nArgs:\n    current_user: Currently authenticated user\n\nReturns:\n    EmailUserResponse: User profile information\n\nRaises:\n    HTTPException: If user authentication fails\n\nExamples:\n    >>> # GET /auth/email/me\n    >>> # Headers: Authorization: Bearer <token>",
        "operationId": "get_current_user_profile_auth_email_me_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmailUserResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBearer": []
          }
        ]
      }
    },
    "/auth/email/events": {
      "get": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Get Auth Events",
        "description": "Get authentication events for the current user.\n\nArgs:\n    limit: Maximum number of events to return\n    offset: Number of events to skip\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    List[AuthEventResponse]: Authentication events\n\nRaises:\n    HTTPException: If user authentication fails\n\nExamples:\n    >>> # GET /auth/email/events?limit=10&offset=0\n    >>> # Headers: Authorization: Bearer <token>",
        "operationId": "get_auth_events_auth_email_events_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AuthEventResponse"
                  },
                  "title": "Response Get Auth Events Auth Email Events Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/email/admin/users": {
      "get": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "List Users",
        "description": "List all users (admin only).\n\nArgs:\n    limit: Maximum number of users to return\n    offset: Number of users to skip\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    UserListResponse: List of users with pagination\n\nRaises:\n    HTTPException: If user is not admin\n\nExamples:\n    >>> # GET /auth/email/admin/users?limit=10&offset=0\n    >>> # Headers: Authorization: Bearer <admin_token>",
        "operationId": "list_users_auth_email_admin_users_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 100,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Create User",
        "description": "Create a new user account (admin only).\n\nArgs:\n    user_request: User creation information\n    current_user: Currently authenticated admin user\n    db: Database session\n\nReturns:\n    EmailUserResponse: Created user information\n\nRaises:\n    HTTPException: If user creation fails\n\nExamples:\n    Request JSON:\n        {\n          \"email\": \"newuser@example.com\",\n          \"password\": \"secure_password\",\n          \"full_name\": \"New User\",\n          \"is_admin\": false\n        }",
        "operationId": "create_user_auth_email_admin_users_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmailRegistrationRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmailUserResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/email/admin/events": {
      "get": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "List All Auth Events",
        "description": "List authentication events for all users (admin only).\n\nArgs:\n    limit: Maximum number of events to return\n    offset: Number of events to skip\n    user_email: Filter events by specific user email\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    List[AuthEventResponse]: Authentication events\n\nRaises:\n    HTTPException: If user is not admin\n\nExamples:\n    >>> # GET /auth/email/admin/events?limit=50&user_email=user@example.com\n    >>> # Headers: Authorization: Bearer <admin_token>",
        "operationId": "list_all_auth_events_auth_email_admin_events_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 100,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          },
          {
            "name": "user_email",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "User Email"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/AuthEventResponse"
                  },
                  "title": "Response List All Auth Events Auth Email Admin Events Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/email/admin/users/{user_email}": {
      "get": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Get User",
        "description": "Get user by email (admin only).\n\nArgs:\n    user_email: Email of user to retrieve\n    current_user: Currently authenticated admin user\n    db: Database session\n\nReturns:\n    EmailUserResponse: User information\n\nRaises:\n    HTTPException: If user not found",
        "operationId": "get_user_auth_email_admin_users__user_email__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmailUserResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Update User",
        "description": "Update user information (admin only).\n\nArgs:\n    user_email: Email of user to update\n    user_request: Updated user information\n    current_user: Currently authenticated admin user\n    db: Database session\n\nReturns:\n    EmailUserResponse: Updated user information\n\nRaises:\n    HTTPException: If user not found or update fails",
        "operationId": "update_user_auth_email_admin_users__user_email__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/EmailRegistrationRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/EmailUserResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Email Authentication"
        ],
        "summary": "Delete User",
        "description": "Delete/deactivate user (admin only).\n\nArgs:\n    user_email: Email of user to delete\n    current_user: Currently authenticated admin user\n    db: Database session\n\nReturns:\n    SuccessResponse: Success confirmation\n\nRaises:\n    HTTPException: If user not found or deletion fails",
        "operationId": "delete_user_auth_email_admin_users__user_email__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/auth/login": {
      "post": {
        "tags": [
          "Main Authentication",
          "Authentication"
        ],
        "summary": "Login",
        "description": "Authenticate user and return session JWT token.\n\nThis endpoint provides Tier 1 authentication for session-based access.\nThe returned JWT token should be used for UI access and API key management.\n\nArgs:\n    login_request: Login credentials (email/username + password)\n    request: FastAPI request object\n    db: Database session\n\nReturns:\n    AuthenticationResponse: Session JWT token and user info\n\nRaises:\n    HTTPException: If authentication fails\n\nExamples:\n    Email format (recommended):\n        {\n          \"email\": \"admin@example.com\",\n          \"password\": \"ChangeMe_12345678$\"\n        }\n\n    Username format (compatibility):\n        {\n          \"username\": \"admin@example.com\",\n          \"password\": \"ChangeMe_12345678$\"\n        }",
        "operationId": "login_auth_login_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/LoginRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthenticationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/": {
      "post": {
        "tags": [
          "Teams"
        ],
        "summary": "Create Team",
        "description": "Create a new team.\n\nArgs:\n    request: Team creation request data\n    current_user_ctx: Currently authenticated user context\n\nReturns:\n    TeamResponse: Created team data\n\nRaises:\n    HTTPException: If team creation fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(create_team)\n    True",
        "operationId": "create_team_teams__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TeamCreateRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Teams"
        ],
        "summary": "List Teams",
        "description": "List teams visible to the caller.\n\n- Administrators see all non-personal teams (paginated)\n- Regular users see only teams they are a member of (paginated client-side)\n\nArgs:\n    skip: Number of teams to skip for pagination\n    limit: Maximum number of teams to return\n    current_user_ctx: Current user context with permissions and database session\n\nReturns:\n    TeamListResponse: List of teams and total count\n\nRaises:\n    HTTPException: If there's an error listing teams\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(list_teams)\n    True",
        "operationId": "list_teams_teams__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "skip",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of teams to skip",
              "default": 0,
              "title": "Skip"
            },
            "description": "Number of teams to skip"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Number of teams to return",
              "default": 50,
              "title": "Limit"
            },
            "description": "Number of teams to return"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}": {
      "get": {
        "tags": [
          "Teams"
        ],
        "summary": "Get Team",
        "description": "Get a specific team by ID.\n\nArgs:\n    team_id: Team UUID\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    TeamResponse: Team data\n\nRaises:\n    HTTPException: If team not found or access denied",
        "operationId": "get_team_teams__team_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Teams"
        ],
        "summary": "Update Team",
        "description": "Update a team.\n\nArgs:\n    team_id: Team UUID\n    request: Team update request data\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    TeamResponse: Updated team data\n\nRaises:\n    HTTPException: If team not found, access denied, or update fails",
        "operationId": "update_team_teams__team_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TeamUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Teams"
        ],
        "summary": "Delete Team",
        "description": "Delete a team.\n\nArgs:\n    team_id: Team UUID\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    SuccessResponse: Success confirmation\n\nRaises:\n    HTTPException: If team not found, access denied, or deletion fails",
        "operationId": "delete_team_teams__team_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/members": {
      "get": {
        "tags": [
          "Teams"
        ],
        "summary": "List Team Members",
        "description": "List team members.\n\nArgs:\n    team_id: Team UUID\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    List[TeamMemberResponse]: List of team members\n\nRaises:\n    HTTPException: If team not found or access denied",
        "operationId": "list_team_members_teams__team_id__members_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TeamMemberResponse"
                  },
                  "title": "Response List Team Members Teams  Team Id  Members Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/members/{user_email}": {
      "put": {
        "tags": [
          "Teams"
        ],
        "summary": "Update Team Member",
        "description": "Update a team member's role.\n\nArgs:\n    team_id: Team UUID\n    user_email: Email of the member to update\n    request: Member update request data\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    TeamMemberResponse: Updated member data\n\nRaises:\n    HTTPException: If member not found, access denied, or update fails",
        "operationId": "update_team_member_teams__team_id__members__user_email__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TeamMemberUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamMemberResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "Teams"
        ],
        "summary": "Remove Team Member",
        "description": "Remove a team member.\n\nArgs:\n    team_id: Team UUID\n    user_email: Email of the member to remove\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    SuccessResponse: Success confirmation\n\nRaises:\n    HTTPException: If member not found, access denied, or removal fails",
        "operationId": "remove_team_member_teams__team_id__members__user_email__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/invitations": {
      "post": {
        "tags": [
          "Teams"
        ],
        "summary": "Invite Team Member",
        "description": "Invite a user to join a team.\n\nArgs:\n    team_id: Team UUID\n    request: Invitation request data\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    TeamInvitationResponse: Created invitation data\n\nRaises:\n    HTTPException: If team not found, access denied, or invitation fails",
        "operationId": "invite_team_member_teams__team_id__invitations_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TeamInviteRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamInvitationResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "Teams"
        ],
        "summary": "List Team Invitations",
        "description": "List team invitations.\n\nArgs:\n    team_id: Team UUID\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    List[TeamInvitationResponse]: List of team invitations\n\nRaises:\n    HTTPException: If team not found or access denied",
        "operationId": "list_team_invitations_teams__team_id__invitations_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TeamInvitationResponse"
                  },
                  "title": "Response List Team Invitations Teams  Team Id  Invitations Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/invitations/{token}/accept": {
      "post": {
        "tags": [
          "Teams"
        ],
        "summary": "Accept Team Invitation",
        "description": "Accept a team invitation.\n\nArgs:\n    token: Invitation token\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    TeamMemberResponse: New team member data\n\nRaises:\n    HTTPException: If invitation not found, expired, or acceptance fails",
        "operationId": "accept_team_invitation_teams_invitations__token__accept_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "token",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamMemberResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/invitations/{invitation_id}": {
      "delete": {
        "tags": [
          "Teams"
        ],
        "summary": "Cancel Team Invitation",
        "description": "Cancel a team invitation.\n\nArgs:\n    invitation_id: Invitation UUID\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    SuccessResponse: Success confirmation\n\nRaises:\n    HTTPException: If invitation not found, access denied, or cancellation fails",
        "operationId": "cancel_team_invitation_teams_invitations__invitation_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "invitation_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Invitation Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/discover": {
      "get": {
        "tags": [
          "Teams"
        ],
        "summary": "Discover Public Teams",
        "description": "Discover public teams that can be joined.\n\nReturns public teams that are discoverable to all authenticated users.\nOnly shows teams where the current user is not already a member.\n\nArgs:\n    skip: Number of teams to skip for pagination\n    limit: Maximum number of teams to return\n    current_user_ctx: Current user context with permissions and database session\n\nReturns:\n    List[TeamDiscoveryResponse]: List of discoverable public teams\n\nRaises:\n    HTTPException: If there's an error discovering teams",
        "operationId": "discover_public_teams_teams_discover_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "skip",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 0,
              "description": "Number of teams to skip",
              "default": 0,
              "title": "Skip"
            },
            "description": "Number of teams to skip"
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 100,
              "minimum": 1,
              "description": "Number of teams to return",
              "default": 50,
              "title": "Limit"
            },
            "description": "Number of teams to return"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TeamDiscoveryResponse"
                  },
                  "title": "Response Discover Public Teams Teams Discover Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/join": {
      "post": {
        "tags": [
          "Teams"
        ],
        "summary": "Request To Join Team",
        "description": "Request to join a public team.\n\nAllows users to request membership in public teams. The request will be\npending until approved by a team owner.\n\nArgs:\n    team_id: ID of the team to join\n    join_request: Join request details including optional message\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    TeamJoinRequestResponse: Created join request details\n\nRaises:\n    HTTPException: If team not found, not public, user already member, or request fails",
        "operationId": "request_to_join_team_teams__team_id__join_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TeamJoinRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamJoinRequestResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/leave": {
      "delete": {
        "tags": [
          "Teams"
        ],
        "summary": "Leave Team",
        "description": "Leave a team.\n\nAllows users to remove themselves from a team. Cannot leave personal teams\nor if they are the last owner of a team.\n\nArgs:\n    team_id: ID of the team to leave\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    SuccessResponse: Confirmation of leaving the team\n\nRaises:\n    HTTPException: If team not found, user not member, cannot leave personal team, or last owner",
        "operationId": "leave_team_teams__team_id__leave_delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/join-requests": {
      "get": {
        "tags": [
          "Teams"
        ],
        "summary": "List Team Join Requests",
        "description": "List pending join requests for a team.\n\nOnly team owners can view join requests for their teams.\n\nArgs:\n    team_id: ID of the team\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    List[TeamJoinRequestResponse]: List of pending join requests\n\nRaises:\n    HTTPException: If team not found or user not authorized",
        "operationId": "list_team_join_requests_teams__team_id__join_requests_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/TeamJoinRequestResponse"
                  },
                  "title": "Response List Team Join Requests Teams  Team Id  Join Requests Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/join-requests/{request_id}/approve": {
      "post": {
        "tags": [
          "Teams"
        ],
        "summary": "Approve Join Request",
        "description": "Approve a team join request.\n\nOnly team owners can approve join requests for their teams.\n\nArgs:\n    team_id: ID of the team\n    request_id: ID of the join request\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    TeamMemberResponse: New team member data\n\nRaises:\n    HTTPException: If request not found or user not authorized",
        "operationId": "approve_join_request_teams__team_id__join_requests__request_id__approve_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "request_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Request Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TeamMemberResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/teams/{team_id}/join-requests/{request_id}": {
      "delete": {
        "tags": [
          "Teams"
        ],
        "summary": "Reject Join Request",
        "description": "Reject a team join request.\n\nOnly team owners can reject join requests for their teams.\n\nArgs:\n    team_id: ID of the team\n    request_id: ID of the join request\n    current_user: Currently authenticated user\n    db: Database session\n\nReturns:\n    SuccessResponse: Confirmation of rejection\n\nRaises:\n    HTTPException: If request not found or user not authorized",
        "operationId": "reject_join_request_teams__team_id__join_requests__request_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "request_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Request Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/SuccessResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tokens": {
      "post": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "Create Token",
        "description": "Create a new API token for the current user.\n\nArgs:\n    request: Token creation request with name, description, scoping, etc.\n    current_user: Authenticated user from JWT\n    db: Database session\n\nReturns:\n    TokenCreateResponse: Created token details with raw token\n\nRaises:\n    HTTPException: If token name already exists or validation fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(create_token)\n    True",
        "operationId": "create_token_tokens_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenCreateRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenCreateResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "List Tokens",
        "description": "List API tokens for the current user.\n\nArgs:\n    include_inactive: Include inactive/expired tokens\n    limit: Maximum number of tokens to return (default 50)\n    offset: Number of tokens to skip for pagination\n    current_user: Authenticated user from JWT\n    db: Database session\n\nReturns:\n    TokenListResponse: List of user's API tokens\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(list_tokens)\n    True",
        "operationId": "list_tokens_tokens_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tokens/{token_id}": {
      "get": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "Get Token",
        "description": "Get details of a specific token.\n\nArgs:\n    token_id: Token ID to retrieve\n    current_user: Authenticated user from JWT\n    db: Database session\n\nReturns:\n    TokenResponse: Token details\n\nRaises:\n    HTTPException: If token not found or not owned by user\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(get_token)\n    True",
        "operationId": "get_token_tokens__token_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "token_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Token Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "Update Token",
        "description": "Update an existing token.\n\nArgs:\n    token_id: Token ID to update\n    request: Token update request\n    current_user: Authenticated user from JWT\n    db: Database session\n\nReturns:\n    TokenResponse: Updated token details\n\nRaises:\n    HTTPException: If token not found or validation fails",
        "operationId": "update_token_tokens__token_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "token_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Token Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "Revoke Token",
        "description": "Revoke (delete) a token.\n\nArgs:\n    token_id: Token ID to revoke\n    request: Optional revocation request with reason\n    current_user: Authenticated user from JWT\n    db: Database session\n\nRaises:\n    HTTPException: If token not found",
        "operationId": "revoke_token_tokens__token_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "token_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Token Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/TokenRevokeRequest"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tokens/{token_id}/usage": {
      "get": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "Get Token Usage Stats",
        "description": "Get usage statistics for a specific token.\n\nArgs:\n    token_id: Token ID to get stats for\n    days: Number of days to analyze (default 30)\n    current_user: Authenticated user from JWT\n    db: Database session\n\nReturns:\n    TokenUsageStatsResponse: Token usage statistics\n\nRaises:\n    HTTPException: If token not found or not owned by user",
        "operationId": "get_token_usage_stats_tokens__token_id__usage_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "token_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Token Id"
            }
          },
          {
            "name": "days",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 30,
              "title": "Days"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenUsageStatsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tokens/admin/all": {
      "get": {
        "tags": [
          "JWT Token Catalog",
          "tokens",
          "admin"
        ],
        "summary": "List All Tokens",
        "description": "Admin endpoint to list all tokens or tokens for a specific user.\n\nArgs:\n    user_email: Filter tokens by user email (admin only)\n    include_inactive: Include inactive/expired tokens\n    limit: Maximum number of tokens to return\n    offset: Number of tokens to skip\n    current_user: Authenticated admin user\n    db: Database session\n\nReturns:\n    TokenListResponse: List of tokens\n\nRaises:\n    HTTPException: If user is not admin",
        "operationId": "list_all_tokens_tokens_admin_all_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "User Email"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 100,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tokens/admin/{token_id}": {
      "delete": {
        "tags": [
          "JWT Token Catalog",
          "tokens",
          "admin"
        ],
        "summary": "Admin Revoke Token",
        "description": "Admin endpoint to revoke any token.\n\nArgs:\n    token_id: Token ID to revoke\n    request: Optional revocation request with reason\n    current_user: Authenticated admin user\n    db: Database session\n\nRaises:\n    HTTPException: If user is not admin or token not found",
        "operationId": "admin_revoke_token_tokens_admin__token_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "token_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Token Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/TokenRevokeRequest"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request"
              }
            }
          }
        },
        "responses": {
          "204": {
            "description": "Successful Response"
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/tokens/teams/{team_id}": {
      "post": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "Create Team Token",
        "description": "Create a new API token for a team (only team owners can do this).\n\nArgs:\n    team_id: Team ID to create token for\n    request: Token creation request with name, description, scoping, etc.\n    current_user: Authenticated user (must be team owner)\n    db: Database session\n\nReturns:\n    TokenCreateResponse: Created token details with raw token\n\nRaises:\n    HTTPException: If user is not team owner or validation fails",
        "operationId": "create_team_token_tokens_teams__team_id__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TokenCreateRequest"
              }
            }
          }
        },
        "responses": {
          "201": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenCreateResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "JWT Token Catalog",
          "tokens"
        ],
        "summary": "List Team Tokens",
        "description": "List API tokens for a team (only team owners can do this).\n\nArgs:\n    team_id: Team ID to list tokens for\n    include_inactive: Include inactive/expired tokens\n    limit: Maximum number of tokens to return (default 50)\n    offset: Number of tokens to skip for pagination\n    current_user: Authenticated user (must be team owner)\n    db: Database session\n\nReturns:\n    TokenListResponse: List of teams API tokens\n\nRaises:\n    HTTPException: If user is not team owner",
        "operationId": "list_team_tokens_tokens_teams__team_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 50,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TokenListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/roles": {
      "post": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Create Role",
        "description": "Create a new role.\n\nRequires admin permissions to create roles.\n\nArgs:\n    role_data: Role creation data\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    RoleResponse: Created role details\n\nRaises:\n    HTTPException: If role creation fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(create_role)\n    True",
        "operationId": "create_role_rbac_roles_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RoleCreateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoleResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "List Roles",
        "description": "List all roles.\n\nArgs:\n    scope: Optional scope filter\n    active_only: Whether to show only active roles\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    List[RoleResponse]: List of roles\n\nRaises:\n    HTTPException: If user lacks required permissions\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(list_roles)\n    True",
        "operationId": "list_roles_rbac_roles_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "scope",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by scope",
              "title": "Scope"
            },
            "description": "Filter by scope"
          },
          {
            "name": "active_only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Show only active roles",
              "default": true,
              "title": "Active Only"
            },
            "description": "Show only active roles"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/RoleResponse"
                  },
                  "title": "Response List Roles Rbac Roles Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/roles/{role_id}": {
      "get": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Get Role",
        "description": "Get role details by ID.\n\nArgs:\n    role_id: Role identifier\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    RoleResponse: Role details\n\nRaises:\n    HTTPException: If role not found\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(get_role)\n    True",
        "operationId": "get_role_rbac_roles__role_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "role_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Role Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoleResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Update Role",
        "description": "Update an existing role.\n\nArgs:\n    role_id: Role identifier\n    role_data: Role update data\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    RoleResponse: Updated role details\n\nRaises:\n    HTTPException: If role not found or update fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(update_role)\n    True",
        "operationId": "update_role_rbac_roles__role_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "role_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Role Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RoleUpdateRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RoleResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Delete Role",
        "description": "Delete a role.\n\nArgs:\n    role_id: Role identifier\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    dict: Success message\n\nRaises:\n    HTTPException: If role not found or deletion fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(delete_role)\n    True",
        "operationId": "delete_role_rbac_roles__role_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "role_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Role Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/users/{user_email}/roles": {
      "post": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Assign Role To User",
        "description": "Assign a role to a user.\n\nArgs:\n    user_email: User email address\n    assignment_data: Role assignment data\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    UserRoleResponse: Created role assignment\n\nRaises:\n    HTTPException: If assignment fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(assign_role_to_user)\n    True",
        "operationId": "assign_role_to_user_rbac_users__user_email__roles_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UserRoleAssignRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UserRoleResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "get": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Get User Roles",
        "description": "Get roles assigned to a user.\n\nArgs:\n    user_email: User email address\n    scope: Optional scope filter\n    active_only: Whether to show only active assignments\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    List[UserRoleResponse]: User's role assignments\n\nRaises:\n    HTTPException: If role retrieval fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(get_user_roles)\n    True",
        "operationId": "get_user_roles_rbac_users__user_email__roles_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "scope",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Filter by scope",
              "title": "Scope"
            },
            "description": "Filter by scope"
          },
          {
            "name": "active_only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Show only active assignments",
              "default": true,
              "title": "Active Only"
            },
            "description": "Show only active assignments"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/UserRoleResponse"
                  },
                  "title": "Response Get User Roles Rbac Users  User Email  Roles Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/users/{user_email}/roles/{role_id}": {
      "delete": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Revoke User Role",
        "description": "Revoke a role from a user.\n\nArgs:\n    user_email: User email address\n    role_id: Role identifier\n    scope: Optional scope filter\n    scope_id: Optional scope ID filter\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    dict: Success message\n\nRaises:\n    HTTPException: If revocation fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(revoke_user_role)\n    True",
        "operationId": "revoke_user_role_rbac_users__user_email__roles__role_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "role_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Role Id"
            }
          },
          {
            "name": "scope",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Scope filter",
              "title": "Scope"
            },
            "description": "Scope filter"
          },
          {
            "name": "scope_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Scope ID filter",
              "title": "Scope Id"
            },
            "description": "Scope ID filter"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/permissions/check": {
      "post": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Check Permission",
        "description": "Check if a user has specific permission.\n\nArgs:\n    check_data: Permission check request\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    PermissionCheckResponse: Permission check result\n\nRaises:\n    HTTPException: If permission check fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(check_permission)\n    True",
        "operationId": "check_permission_rbac_permissions_check_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PermissionCheckRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PermissionCheckResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/permissions/user/{user_email}": {
      "get": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Get User Permissions",
        "description": "Get all effective permissions for a user.\n\nArgs:\n    user_email: User email address\n    team_id: Optional team context\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    List[str]: User's effective permissions\n\nRaises:\n    HTTPException: If retrieving user permissions fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(get_user_permissions)\n    True",
        "operationId": "get_user_permissions_rbac_permissions_user__user_email__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Team context",
              "title": "Team Id"
            },
            "description": "Team context"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "title": "Response Get User Permissions Rbac Permissions User  User Email  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/permissions/available": {
      "get": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Get Available Permissions",
        "description": "Get all available permissions in the system.\n\nArgs:\n    user: Current authenticated user\n\nReturns:\n    PermissionListResponse: Available permissions organized by resource type\n\nRaises:\n    HTTPException: If retrieving available permissions fails",
        "operationId": "get_available_permissions_rbac_permissions_available_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PermissionListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/my/roles": {
      "get": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Get My Roles",
        "description": "Get current user's role assignments.\n\nArgs:\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    List[UserRoleResponse]: Current user's role assignments\n\nRaises:\n    HTTPException: If retrieving user roles fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(get_my_roles)\n    True",
        "operationId": "get_my_roles_rbac_my_roles_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/UserRoleResponse"
                  },
                  "title": "Response Get My Roles Rbac My Roles Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/rbac/my/permissions": {
      "get": {
        "tags": [
          "RBAC",
          "RBAC"
        ],
        "summary": "Get My Permissions",
        "description": "Get current user's effective permissions.\n\nArgs:\n    team_id: Optional team context\n    user: Current authenticated user\n    db: Database session\n\nReturns:\n    List[str]: Current user's effective permissions\n\nRaises:\n    HTTPException: If retrieving user permissions fails\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(get_my_permissions)\n    True",
        "operationId": "get_my_permissions_rbac_my_permissions_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Team context",
              "title": "Team Id"
            },
            "description": "Team context"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  },
                  "title": "Response Get My Permissions Rbac My Permissions Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/oauth/authorize/{gateway_id}": {
      "get": {
        "tags": [
          "oauth"
        ],
        "summary": "Initiate Oauth Flow",
        "description": "Initiates the OAuth 2.0 Authorization Code flow for a specified gateway.\n\nThis endpoint retrieves the OAuth configuration for the given gateway, validates that\nthe gateway supports the Authorization Code flow, and redirects the user to the OAuth\nprovider's authorization URL to begin the OAuth process.\n\n**Phase 1.4: DCR Integration**\nIf the gateway has an issuer but no client_id, and DCR is enabled, this endpoint will\nautomatically register the gateway as an OAuth client with the Authorization Server\nusing Dynamic Client Registration (RFC 7591).\n\nArgs:\n    gateway_id: The unique identifier of the gateway to authorize.\n    request: The FastAPI request object.\n    current_user: The authenticated user initiating the OAuth flow.\n    db: The database session dependency.\n\nReturns:\n    A redirect response to the OAuth provider's authorization URL.\n\nRaises:\n    HTTPException: If the gateway is not found, not configured for OAuth, or not using\n        the Authorization Code flow. If an unexpected error occurs during the initiation process.\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(initiate_oauth_flow)\n    True",
        "operationId": "initiate_oauth_flow_oauth_authorize__gateway_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/oauth/callback": {
      "get": {
        "tags": [
          "oauth"
        ],
        "summary": "Oauth Callback",
        "description": "Handle the OAuth callback and complete the authorization process.\n\nThis endpoint is called by the OAuth provider after the user authorizes access.\nIt receives the authorization code and state parameters, verifies the state,\nretrieves the corresponding gateway configuration, and exchanges the code for an access token.\n\nArgs:\n    code (str): The authorization code returned by the OAuth provider.\n    state (str): The state parameter for CSRF protection, which encodes the gateway ID.\n    request (Request): The incoming HTTP request object.\n    db (Session): The database session dependency.\n\nReturns:\n    HTMLResponse: An HTML response indicating the result of the OAuth authorization process.\n\nRaises:\n    ValueError: Raised internally when state parameter is missing gateway_id (caught and handled).\n\nExamples:\n    >>> import asyncio\n    >>> asyncio.iscoroutinefunction(oauth_callback)\n    True",
        "operationId": "oauth_callback_oauth_callback_get",
        "parameters": [
          {
            "name": "code",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "Authorization code from OAuth provider",
              "title": "Code"
            },
            "description": "Authorization code from OAuth provider"
          },
          {
            "name": "state",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string",
              "description": "State parameter for CSRF protection",
              "title": "State"
            },
            "description": "State parameter for CSRF protection"
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/oauth/status/{gateway_id}": {
      "get": {
        "tags": [
          "oauth"
        ],
        "summary": "Get Oauth Status",
        "description": "Get OAuth status for a gateway.\n\nArgs:\n    gateway_id: ID of the gateway\n    db: Database session\n\nReturns:\n    OAuth status information\n\nRaises:\n    HTTPException: If gateway not found or error retrieving status",
        "operationId": "get_oauth_status_oauth_status__gateway_id__get",
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Oauth Status Oauth Status  Gateway Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/oauth/fetch-tools/{gateway_id}": {
      "post": {
        "tags": [
          "oauth"
        ],
        "summary": "Fetch Tools After Oauth",
        "description": "Fetch tools from MCP server after OAuth completion for Authorization Code flow.\n\nArgs:\n    gateway_id: ID of the gateway to fetch tools for\n    current_user: The authenticated user fetching tools\n    db: Database session\n\nReturns:\n    Dict containing success status and message with number of tools fetched\n\nRaises:\n    HTTPException: If fetching tools fails",
        "operationId": "fetch_tools_after_oauth_oauth_fetch_tools__gateway_id__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Fetch Tools After Oauth Oauth Fetch Tools  Gateway Id  Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/oauth/registered-clients": {
      "get": {
        "tags": [
          "oauth"
        ],
        "summary": "List Registered Oauth Clients",
        "description": "List all registered OAuth clients (created via DCR).\n\nThis endpoint shows OAuth clients that were dynamically registered with external\nAuthorization Servers using RFC 7591 Dynamic Client Registration.\n\nArgs:\n    current_user: The authenticated user (admin access required)\n    db: Database session\n\nReturns:\n    Dict containing list of registered OAuth clients with metadata\n\nRaises:\n    HTTPException: If user lacks permissions or database error occurs",
        "operationId": "list_registered_oauth_clients_oauth_registered_clients_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response List Registered Oauth Clients Oauth Registered Clients Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/oauth/registered-clients/{gateway_id}": {
      "get": {
        "tags": [
          "oauth"
        ],
        "summary": "Get Registered Client For Gateway",
        "description": "Get the registered OAuth client for a specific gateway.\n\nArgs:\n    gateway_id: The gateway ID to lookup\n    current_user: The authenticated user\n    db: Database session\n\nReturns:\n    Dict containing registered client information\n\nRaises:\n    HTTPException: If gateway or registered client not found",
        "operationId": "get_registered_client_for_gateway_oauth_registered_clients__gateway_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Registered Client For Gateway Oauth Registered Clients  Gateway Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/oauth/registered-clients/{client_id}": {
      "delete": {
        "tags": [
          "oauth"
        ],
        "summary": "Delete Registered Client",
        "description": "Delete a registered OAuth client.\n\nThis will revoke the client registration locally. Note: This does not automatically\nrevoke the client at the Authorization Server. You may need to manually revoke the\nclient using the registration_client_uri if available.\n\nArgs:\n    client_id: The registered client ID to delete\n    current_user: The authenticated user (admin access required)\n    db: Database session\n\nReturns:\n    Dict containing success message\n\nRaises:\n    HTTPException: If client not found or deletion fails",
        "operationId": "delete_registered_client_oauth_registered_clients__client_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "client_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Client Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Delete Registered Client Oauth Registered Clients  Client Id  Delete"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/reverse-proxy/sessions": {
      "get": {
        "tags": [
          "reverse-proxy"
        ],
        "summary": "List Sessions",
        "description": "List all active reverse proxy sessions.\n\nArgs:\n    request: HTTP request.\n    _: Authenticated user info (used for auth check).\n\nReturns:\n    List of session information.",
        "operationId": "list_sessions_reverse_proxy_sessions_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/reverse-proxy/sessions/{session_id}": {
      "delete": {
        "tags": [
          "reverse-proxy"
        ],
        "summary": "Disconnect Session",
        "description": "Disconnect a reverse proxy session.\n\nArgs:\n    session_id: Session ID to disconnect.\n    request: HTTP request.\n    _: Authenticated user info (used for auth check).\n\nReturns:\n    Disconnection status.\n\nRaises:\n    HTTPException: If session is not found.",
        "operationId": "disconnect_session_reverse_proxy_sessions__session_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "session_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Session Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/reverse-proxy/sessions/{session_id}/request": {
      "post": {
        "tags": [
          "reverse-proxy"
        ],
        "summary": "Send Request To Session",
        "description": "Send an MCP request to a reverse proxy session.\n\nArgs:\n    session_id: Session ID to send request to.\n    mcp_request: MCP request to send.\n    request: HTTP request.\n    _: Authenticated user info (used for auth check).\n\nReturns:\n    Request acknowledgment.\n\nRaises:\n    HTTPException: If session is not found or request fails.",
        "operationId": "send_request_to_session_reverse_proxy_sessions__session_id__request_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "session_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Session Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "additionalProperties": true,
                "title": "Mcp Request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/reverse-proxy/sse/{session_id}": {
      "get": {
        "tags": [
          "reverse-proxy"
        ],
        "summary": "Sse Endpoint",
        "description": "SSE endpoint for receiving messages from a reverse proxy session.\n\nArgs:\n    session_id: Session ID to subscribe to.\n    request: HTTP request.\n\nReturns:\n    SSE stream.\n\nRaises:\n    HTTPException: If session is not found.",
        "operationId": "sse_endpoint_reverse_proxy_sse__session_id__get",
        "parameters": [
          {
            "name": "session_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Session Id"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/config/passthrough-headers": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Global Passthrough Headers",
        "description": "Get the global passthrough headers configuration.\n\nArgs:\n    db: Database session\n    _user: Authenticated user\n\nReturns:\n    GlobalConfigRead: The current global passthrough headers configuration\n\nExamples:\n    >>> # Test function exists and has correct name\n    >>> from mcpgateway.admin import get_global_passthrough_headers\n    >>> get_global_passthrough_headers.__name__\n    'get_global_passthrough_headers'\n    >>> # Test it's a coroutine function\n    >>> import inspect\n    >>> inspect.iscoroutinefunction(get_global_passthrough_headers)\n    True",
        "operationId": "get_global_passthrough_headers_admin_config_passthrough_headers_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalConfigRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Update Global Passthrough Headers",
        "description": "Update the global passthrough headers configuration.\n\nArgs:\n    request: HTTP request object\n    config_update: The new configuration\n    db: Database session\n    _user: Authenticated user\n\nRaises:\n    HTTPException: If there is a conflict or validation error\n\nReturns:\n    GlobalConfigRead: The updated configuration\n\nExamples:\n    >>> # Test function exists and has correct name\n    >>> from mcpgateway.admin import update_global_passthrough_headers\n    >>> update_global_passthrough_headers.__name__\n    'update_global_passthrough_headers'\n    >>> # Test it's a coroutine function\n    >>> import inspect\n    >>> inspect.iscoroutinefunction(update_global_passthrough_headers)\n    True",
        "operationId": "update_global_passthrough_headers_admin_config_passthrough_headers_put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GlobalConfigUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalConfigRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/config/settings": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Configuration Settings",
        "description": "Get application configuration settings grouped by category.\n\nReturns configuration settings with sensitive values masked.\n\nArgs:\n    _db: Database session\n    _user: Authenticated user\n\nReturns:\n    Dict with configuration groups and their settings",
        "operationId": "get_configuration_settings_admin_config_settings_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Configuration Settings Admin Config Settings Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/servers": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Servers",
        "description": "List servers for the admin UI with an option to include inactive servers.\n\nArgs:\n    include_inactive (bool): Whether to include inactive servers.\n    db (Session): The database session dependency.\n    user (str): The authenticated user dependency.\n\nReturns:\n    List[ServerRead]: A list of server records.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import ServerRead, ServerMetrics\n    >>>\n    >>> # Mock dependencies\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>>\n    >>> # Mock server service\n    >>> from datetime import datetime, timezone\n    >>> mock_metrics = ServerMetrics(\n    ...     total_executions=10,\n    ...     successful_executions=8,\n    ...     failed_executions=2,\n    ...     failure_rate=0.2,\n    ...     min_response_time=0.1,\n    ...     max_response_time=2.0,\n    ...     avg_response_time=0.5,\n    ...     last_execution_time=datetime.now(timezone.utc)\n    ... )\n    >>> mock_server = ServerRead(\n    ...     id=\"server-1\",\n    ...     name=\"Test Server\",\n    ...     description=\"A test server\",\n    ...     icon=\"test-icon.png\",\n    ...     created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc),\n    ...     is_active=True,\n    ...     associated_tools=[\"tool1\", \"tool2\"],\n    ...     associated_resources=[1, 2],\n    ...     associated_prompts=[1],\n    ...     metrics=mock_metrics\n    ... )\n    >>>\n    >>> # Mock the server_service.list_servers_for_user method\n    >>> original_list_servers_for_user = server_service.list_servers_for_user\n    >>> server_service.list_servers_for_user = AsyncMock(return_value=[mock_server])\n    >>>\n    >>> # Test the function\n    >>> async def test_admin_list_servers():\n    ...     result = await admin_list_servers(\n    ...         include_inactive=False,\n    ...         db=mock_db,\n    ...         user=mock_user\n    ...     )\n    ...     return len(result) > 0 and isinstance(result[0], dict)\n    >>>\n    >>> # Run the test\n    >>> asyncio.run(test_admin_list_servers())\n    True\n    >>>\n    >>> # Restore original method\n    >>> server_service.list_servers_for_user = original_list_servers_for_user\n    >>>\n    >>> # Additional test for empty server list\n    >>> server_service.list_servers_for_user = AsyncMock(return_value=[])\n    >>> async def test_admin_list_servers_empty():\n    ...     result = await admin_list_servers(\n    ...         include_inactive=True,\n    ...         db=mock_db,\n    ...         user=mock_user\n    ...     )\n    ...     return result == []\n    >>> asyncio.run(test_admin_list_servers_empty())\n    True\n    >>> server_service.list_servers_for_user = original_list_servers_for_user\n    >>>\n    >>> # Additional test for exception handling\n    >>> import pytest\n    >>> from fastapi import HTTPException\n    >>> async def test_admin_list_servers_exception():\n    ...     server_service.list_servers_for_user = AsyncMock(side_effect=Exception(\"Test error\"))\n    ...     try:\n    ...         await admin_list_servers(False, mock_db, mock_user)\n    ...     except Exception as e:\n    ...         return str(e) == \"Test error\"\n    >>> asyncio.run(test_admin_list_servers_exception())\n    True",
        "operationId": "admin_list_servers_admin_servers_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ServerRead"
                  },
                  "title": "Response Admin List Servers Admin Servers Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Server",
        "description": "Add a new server via the admin UI.\n\nThis endpoint processes form data to create a new server entry in the database.\nIt handles exceptions gracefully and logs any errors that occur during server\nregistration.\n\nExpects form fields:\n  - name (required): The name of the server\n  - description (optional): A description of the server's purpose\n  - icon (optional): URL or path to the server's icon\n  - associatedTools (optional, multiple values): Tools associated with this server\n  - associatedResources (optional, multiple values): Resources associated with this server\n  - associatedPrompts (optional, multiple values): Prompts associated with this server\n\nArgs:\n    request (Request): FastAPI request containing form data.\n    db (Session): Database session dependency\n    user (str): Authenticated user dependency\n\nReturns:\n    JSONResponse: A JSON response indicating success or failure of the server creation operation.\n\nExamples:\n    >>> import asyncio\n    >>> import uuid\n    >>> from datetime import datetime\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> # Mock dependencies\n    >>> mock_db = MagicMock()\n    >>> timestamp = datetime.now().strftime(\"%Y%m%d%H%M%S\")\n    >>> short_uuid = str(uuid.uuid4())[:8]\n    >>> unq_ext = f\"{timestamp}-{short_uuid}\"\n    >>> mock_user = {\"email\": \"test_user_\" + unq_ext, \"db\": mock_db}\n    >>> # Mock form data for successful server creation\n    >>> form_data = FormData([\n    ...     (\"name\", \"Test-Server-\"+unq_ext ),\n    ...     (\"description\", \"A test server\"),\n    ...     (\"icon\", \"https://raw.githubusercontent.com/github/explore/main/topics/python/python.png\"),\n    ...     (\"associatedTools\", \"tool1\"),\n    ...     (\"associatedTools\", \"tool2\"),\n    ...     (\"associatedResources\", \"resource1\"),\n    ...     (\"associatedResources\", \"resource2\"),\n    ...     (\"associatedPrompts\", \"prompt1\"),\n    ...     (\"associatedPrompts\", \"prompt2\"),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>>\n    >>> # Mock request with form data\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"/test\"}\n    >>>\n    >>> # Mock server service\n    >>> original_register_server = server_service.register_server\n    >>> server_service.register_server = AsyncMock()\n    >>>\n    >>> # Test successful server addition\n    >>> async def test_admin_add_server_success():\n    ...     result = await admin_add_server(\n    ...         request=mock_request,\n    ...         db=mock_db,\n    ...         user=mock_user\n    ...     )\n    ...     # Accept both Successful (200) and JSONResponse (422/409) for error cases\n    ...     #print(result.status_code)\n    ...     return isinstance(result, JSONResponse) and result.status_code in (200, 409, 422, 500)\n    >>>\n    >>> asyncio.run(test_admin_add_server_success())\n    True\n    >>>\n    >>> # Test with inactive checkbox checked\n    >>> form_data_inactive = FormData([\n    ...     (\"name\", \"Test Server\"),\n    ...     (\"description\", \"A test server\"),\n    ...     (\"is_inactive_checked\", \"true\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_add_server_inactive():\n    ...     result = await admin_add_server(mock_request, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code in (200, 409, 422, 500)\n    >>>\n    >>> #asyncio.run(test_admin_add_server_inactive())\n    >>>\n    >>> # Test exception handling - should still return redirect\n    >>> async def test_admin_add_server_exception():\n    ...     server_service.register_server = AsyncMock(side_effect=Exception(\"Test error\"))\n    ...     result = await admin_add_server(mock_request, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 500\n    >>>\n    >>> asyncio.run(test_admin_add_server_exception())\n    True\n    >>>\n    >>> # Test with minimal form data\n    >>> form_data_minimal = FormData([(\"name\", \"Minimal Server\")])\n    >>> mock_request.form = AsyncMock(return_value=form_data_minimal)\n    >>> server_service.register_server = AsyncMock()\n    >>>\n    >>> async def test_admin_add_server_minimal():\n    ...     result = await admin_add_server(mock_request, mock_db, mock_user)\n    ...     #print (result)\n    ...     #print (result.status_code)\n    ...     return isinstance(result, JSONResponse) and result.status_code==200\n    >>>\n    >>> asyncio.run(test_admin_add_server_minimal())\n    True\n    >>>\n    >>> # Restore original method\n    >>> server_service.register_server = original_register_server",
        "operationId": "admin_add_server_admin_servers_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/servers/{server_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Server",
        "description": "Retrieve server details for the admin UI.\n\nArgs:\n    server_id (str): The ID of the server to retrieve.\n    db (Session): The database session dependency.\n    user (str): The authenticated user dependency.\n\nReturns:\n    Dict[str, Any]: The server details.\n\nRaises:\n    HTTPException: If the server is not found.\n    Exception: For any other unexpected errors.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import ServerRead, ServerMetrics\n    >>> from mcpgateway.services.server_service import ServerNotFoundError\n    >>> from fastapi import HTTPException\n    >>>\n    >>> # Mock dependencies\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> server_id = \"test-server-1\"\n    >>>\n    >>> # Mock server response\n    >>> from datetime import datetime, timezone\n    >>> mock_metrics = ServerMetrics(\n    ...     total_executions=5,\n    ...     successful_executions=4,\n    ...     failed_executions=1,\n    ...     failure_rate=0.2,\n    ...     min_response_time=0.2,\n    ...     max_response_time=1.5,\n    ...     avg_response_time=0.8,\n    ...     last_execution_time=datetime.now(timezone.utc)\n    ... )\n    >>> mock_server = ServerRead(\n    ...     id=server_id,\n    ...     name=\"Test Server\",\n    ...     description=\"A test server\",\n    ...     icon=\"test-icon.png\",\n    ...     created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc),\n    ...     is_active=True,\n    ...     associated_tools=[\"tool1\"],\n    ...     associated_resources=[1],\n    ...     associated_prompts=[1],\n    ...     metrics=mock_metrics\n    ... )\n    >>>\n    >>> # Mock the server_service.get_server method\n    >>> original_get_server = server_service.get_server\n    >>> server_service.get_server = AsyncMock(return_value=mock_server)\n    >>>\n    >>> # Test successful retrieval\n    >>> async def test_admin_get_server_success():\n    ...     result = await admin_get_server(\n    ...         server_id=server_id,\n    ...         db=mock_db,\n    ...         user=mock_user\n    ...     )\n    ...     return isinstance(result, dict) and result.get('id') == server_id\n    >>>\n    >>> # Run the test\n    >>> asyncio.run(test_admin_get_server_success())\n    True\n    >>>\n    >>> # Test server not found scenario\n    >>> server_service.get_server = AsyncMock(side_effect=ServerNotFoundError(\"Server not found\"))\n    >>>\n    >>> async def test_admin_get_server_not_found():\n    ...     try:\n    ...         await admin_get_server(\n    ...             server_id=\"nonexistent\",\n    ...             db=mock_db,\n    ...             user=mock_user\n    ...         )\n    ...         return False\n    ...     except HTTPException as e:\n    ...         return e.status_code == 404\n    >>>\n    >>> # Run the not found test\n    >>> asyncio.run(test_admin_get_server_not_found())\n    True\n    >>>\n    >>> # Restore original method\n    >>> server_service.get_server = original_get_server",
        "operationId": "admin_get_server_admin_servers__server_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/servers/{server_id}/edit": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Edit Server",
        "description": "Edit an existing server via the admin UI.\n\nThis endpoint processes form data to update an existing server's properties.\nIt handles exceptions gracefully and logs any errors that occur during the\nupdate operation.\n\nExpects form fields:\n  - id (optional): Updated UUID for the server\n  - name (optional): The updated name of the server\n  - description (optional): An updated description of the server's purpose\n  - icon (optional): Updated URL or path to the server's icon\n  - associatedTools (optional, multiple values): Updated list of tools associated with this server\n  - associatedResources (optional, multiple values): Updated list of resources associated with this server\n  - associatedPrompts (optional, multiple values): Updated list of prompts associated with this server\n\nArgs:\n    server_id (str): The ID of the server to edit\n    request (Request): FastAPI request containing form data\n    db (Session): Database session dependency\n    user (str): Authenticated user dependency\n\nReturns:\n    JSONResponse: A JSON response indicating success or failure of the server update operation.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import JSONResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> server_id = \"server-to-edit\"\n    >>>\n    >>> # Happy path: Edit server with new name\n    >>> form_data_edit = FormData([(\"name\", \"Updated Server Name\"), (\"is_inactive_checked\", \"false\")])\n    >>> mock_request_edit = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_edit.form = AsyncMock(return_value=form_data_edit)\n    >>> original_update_server = server_service.update_server\n    >>> server_service.update_server = AsyncMock()\n    >>>\n    >>> async def test_admin_edit_server_success():\n    ...     result = await admin_edit_server(server_id, mock_request_edit, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 200 and result.body == b'{\"message\":\"Server updated successfully!\",\"success\":true}'\n    >>>\n    >>> asyncio.run(test_admin_edit_server_success())\n    True\n    >>>\n    >>> # Error path: Simulate an exception during update\n    >>> form_data_error = FormData([(\"name\", \"Error Server\")])\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> server_service.update_server = AsyncMock(side_effect=Exception(\"Update failed\"))\n    >>>\n    >>> # Restore original method\n    >>> server_service.update_server = original_update_server\n    >>> # 409 Conflict: ServerNameConflictError\n    >>> server_service.update_server = AsyncMock(side_effect=ServerNameConflictError(\"Name conflict\"))\n    >>> async def test_admin_edit_server_conflict():\n    ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 409 and b'Name conflict' in result.body\n    >>> asyncio.run(test_admin_edit_server_conflict())\n    True\n    >>> # 409 Conflict: IntegrityError\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> server_service.update_server = AsyncMock(side_effect=IntegrityError(\"Integrity error\", None, None))\n    >>> async def test_admin_edit_server_integrity():\n    ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 409\n    >>> asyncio.run(test_admin_edit_server_integrity())\n    True\n    >>> # 422 Unprocessable Entity: ValidationError\n    >>> from pydantic import ValidationError, BaseModel\n    >>> from mcpgateway.schemas import ServerUpdate\n    >>> validation_error = ValidationError.from_exception_data(\"ServerUpdate validation error\", [\n    ...     {\"loc\": (\"name\",), \"msg\": \"Field required\", \"type\": \"missing\"}\n    ... ])\n    >>> server_service.update_server = AsyncMock(side_effect=validation_error)\n    >>> async def test_admin_edit_server_validation():\n    ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 422\n    >>> asyncio.run(test_admin_edit_server_validation())\n    True\n    >>> # 400 Bad Request: ValueError\n    >>> server_service.update_server = AsyncMock(side_effect=ValueError(\"Bad value\"))\n    >>> async def test_admin_edit_server_valueerror():\n    ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 400 and b'Bad value' in result.body\n    >>> asyncio.run(test_admin_edit_server_valueerror())\n    True\n    >>> # 500 Internal Server Error: ServerError\n    >>> server_service.update_server = AsyncMock(side_effect=ServerError(\"Server error\"))\n    >>> async def test_admin_edit_server_servererror():\n    ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 500 and b'Server error' in result.body\n    >>> asyncio.run(test_admin_edit_server_servererror())\n    True\n    >>> # 500 Internal Server Error: RuntimeError\n    >>> server_service.update_server = AsyncMock(side_effect=RuntimeError(\"Runtime error\"))\n    >>> async def test_admin_edit_server_runtimeerror():\n    ...     result = await admin_edit_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, JSONResponse) and result.status_code == 500 and b'Runtime error' in result.body\n    >>> asyncio.run(test_admin_edit_server_runtimeerror())\n    True\n    >>> # Restore original method\n    >>> server_service.update_server = original_update_server",
        "operationId": "admin_edit_server_admin_servers__server_id__edit_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/servers/{server_id}/toggle": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Toggle Server",
        "description": "Toggle a server's active status via the admin UI.\n\nThis endpoint processes a form request to activate or deactivate a server.\nIt expects a form field 'activate' with value \"true\" to activate the server\nor \"false\" to deactivate it. The endpoint handles exceptions gracefully and\nlogs any errors that might occur during the status toggle operation.\n\nArgs:\n    server_id (str): The ID of the server whose status to toggle.\n    request (Request): FastAPI request containing form data with the 'activate' field.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    Response: A redirect to the admin dashboard catalog section with a\n    status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> server_id = \"server-to-toggle\"\n    >>>\n    >>> # Happy path: Activate server\n    >>> form_data_activate = FormData([(\"activate\", \"true\"), (\"is_inactive_checked\", \"false\")])\n    >>> mock_request_activate = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_activate.form = AsyncMock(return_value=form_data_activate)\n    >>> original_toggle_server_status = server_service.toggle_server_status\n    >>> server_service.toggle_server_status = AsyncMock()\n    >>>\n    >>> async def test_admin_toggle_server_activate():\n    ...     result = await admin_toggle_server(server_id, mock_request_activate, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin#catalog\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_server_activate())\n    True\n    >>>\n    >>> # Happy path: Deactivate server\n    >>> form_data_deactivate = FormData([(\"activate\", \"false\"), (\"is_inactive_checked\", \"false\")])\n    >>> mock_request_deactivate = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_deactivate.form = AsyncMock(return_value=form_data_deactivate)\n    >>>\n    >>> async def test_admin_toggle_server_deactivate():\n    ...     result = await admin_toggle_server(server_id, mock_request_deactivate, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/api/admin#catalog\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_server_deactivate())\n    True\n    >>>\n    >>> # Edge case: Toggle with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"activate\", \"true\"), (\"is_inactive_checked\", \"true\")])\n    >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_toggle_server_inactive_checked():\n    ...     result = await admin_toggle_server(server_id, mock_request_inactive, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin/?include_inactive=true#catalog\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_server_inactive_checked())\n    True\n    >>>\n    >>> # Error path: Simulate an exception during toggle\n    >>> form_data_error = FormData([(\"activate\", \"true\")])\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> server_service.toggle_server_status = AsyncMock(side_effect=Exception(\"Toggle failed\"))\n    >>>\n    >>> async def test_admin_toggle_server_exception():\n    ...     result = await admin_toggle_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     location_header = result.headers[\"location\"]\n    ...     return (\n    ...         isinstance(result, RedirectResponse)\n    ...         and result.status_code == 303\n    ...         and \"/admin\" in location_header  # Ensure '/admin' is present\n    ...         and \"error=\" in location_header  # Ensure the error parameter is in the query string\n    ...         and location_header.endswith(\"#catalog\")  # Ensure the fragment is correct\n    ...     )\n    >>>\n    >>> asyncio.run(test_admin_toggle_server_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> server_service.toggle_server_status = original_toggle_server_status",
        "operationId": "admin_toggle_server_admin_servers__server_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/servers/{server_id}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Server",
        "description": "Delete a server via the admin UI.\n\nThis endpoint removes a server from the database by its ID. It handles exceptions\ngracefully and logs any errors that occur during the deletion process.\n\nArgs:\n    server_id (str): The ID of the server to delete\n    request (Request): FastAPI request object (not used but required by route signature).\n    db (Session): Database session dependency\n    user (str): Authenticated user dependency\n\nReturns:\n    RedirectResponse: A redirect to the admin dashboard catalog section with a\n    status code of 303 (See Other)\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> server_id = \"server-to-delete\"\n    >>>\n    >>> # Happy path: Delete server\n    >>> form_data_delete = FormData([(\"is_inactive_checked\", \"false\")])\n    >>> mock_request_delete = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_delete.form = AsyncMock(return_value=form_data_delete)\n    >>> original_delete_server = server_service.delete_server\n    >>> server_service.delete_server = AsyncMock()\n    >>>\n    >>> async def test_admin_delete_server_success():\n    ...     result = await admin_delete_server(server_id, mock_request_delete, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin#catalog\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_server_success())\n    True\n    >>>\n    >>> # Edge case: Delete with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"is_inactive_checked\", \"true\")])\n    >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_delete_server_inactive_checked():\n    ...     result = await admin_delete_server(server_id, mock_request_inactive, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/api/admin/?include_inactive=true#catalog\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_server_inactive_checked())\n    True\n    >>>\n    >>> # Error path: Simulate an exception during deletion\n    >>> form_data_error = FormData([])\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> server_service.delete_server = AsyncMock(side_effect=Exception(\"Deletion failed\"))\n    >>>\n    >>> async def test_admin_delete_server_exception():\n    ...     result = await admin_delete_server(server_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"#catalog\" in result.headers[\"location\"] and \"error=\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_server_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> server_service.delete_server = original_delete_server",
        "operationId": "admin_delete_server_admin_servers__server_id__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/resources": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Resources",
        "description": "List resources for the admin UI with an option to include inactive resources.\n\nThis endpoint retrieves a list of resources from the database, optionally including\nthose that are inactive. The inactive filter is useful for administrators who need\nto view or manage resources that have been deactivated but not deleted.\n\nArgs:\n    include_inactive (bool): Whether to include inactive resources in the results.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    List[ResourceRead]: A list of resource records formatted with by_alias=True.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import ResourceRead, ResourceMetrics\n    >>> from datetime import datetime, timezone\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>>\n    >>> # Mock resource data\n    >>> mock_resource = ResourceRead(\n    ...     id=1,\n    ...     uri=\"test://resource/1\",\n    ...     name=\"Test Resource\",\n    ...     description=\"A test resource\",\n    ...     mime_type=\"text/plain\",\n    ...     size=100,\n    ...     created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc),\n    ...     is_active=True,\n    ...     metrics=ResourceMetrics(\n    ...         total_executions=5, successful_executions=5, failed_executions=0,\n    ...         failure_rate=0.0, min_response_time=0.1, max_response_time=0.5,\n    ...         avg_response_time=0.3, last_execution_time=datetime.now(timezone.utc)\n    ...     ),\n    ...     tags=[]\n    ... )\n    >>>\n    >>> # Mock the resource_service.list_resources_for_user method\n    >>> original_list_resources_for_user = resource_service.list_resources_for_user\n    >>> resource_service.list_resources_for_user = AsyncMock(return_value=[mock_resource])\n    >>>\n    >>> # Test listing active resources\n    >>> async def test_admin_list_resources_active():\n    ...     result = await admin_list_resources(include_inactive=False, db=mock_db, user=mock_user)\n    ...     return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == \"Test Resource\"\n    >>>\n    >>> asyncio.run(test_admin_list_resources_active())\n    True\n    >>>\n    >>> # Test listing with inactive resources (if mock includes them)\n    >>> mock_inactive_resource = ResourceRead(\n    ...     id=2, uri=\"test://resource/2\", name=\"Inactive Resource\",\n    ...     description=\"Another test\", mime_type=\"application/json\", size=50,\n    ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),\n    ...     is_active=False, metrics=ResourceMetrics(\n    ...         total_executions=0, successful_executions=0, failed_executions=0,\n    ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0,\n    ...         avg_response_time=0.0, last_execution_time=None),\n    ...     tags=[]\n    ... )\n    >>> resource_service.list_resources_for_user = AsyncMock(return_value=[mock_resource, mock_inactive_resource])\n    >>> async def test_admin_list_resources_all():\n    ...     result = await admin_list_resources(include_inactive=True, db=mock_db, user=mock_user)\n    ...     return len(result) == 2 and not result[1]['isActive']\n    >>>\n    >>> asyncio.run(test_admin_list_resources_all())\n    True\n    >>>\n    >>> # Test empty list\n    >>> resource_service.list_resources_for_user = AsyncMock(return_value=[])\n    >>> async def test_admin_list_resources_empty():\n    ...     result = await admin_list_resources(include_inactive=False, db=mock_db, user=mock_user)\n    ...     return result == []\n    >>>\n    >>> asyncio.run(test_admin_list_resources_empty())\n    True\n    >>>\n    >>> # Test exception handling\n    >>> resource_service.list_resources_for_user = AsyncMock(side_effect=Exception(\"Resource list error\"))\n    >>> async def test_admin_list_resources_exception():\n    ...     try:\n    ...         await admin_list_resources(False, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Resource list error\"\n    >>>\n    >>> asyncio.run(test_admin_list_resources_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> resource_service.list_resources_for_user = original_list_resources_for_user",
        "operationId": "admin_list_resources_admin_resources_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ResourceRead"
                  },
                  "title": "Response Admin List Resources Admin Resources Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Resource",
        "description": "Add a resource via the admin UI.\n\nExpects form fields:\n  - uri\n  - name\n  - description (optional)\n  - mime_type (optional)\n  - content\n\nArgs:\n    request: FastAPI request containing form data.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    A redirect response to the admin dashboard.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> form_data = FormData([\n    ...     (\"uri\", \"test://resource1\"),\n    ...     (\"name\", \"Test Resource\"),\n    ...     (\"description\", \"A test resource\"),\n    ...     (\"mimeType\", \"text/plain\"),\n    ...     (\"content\", \"Sample content\"),\n    ... ])\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_register_resource = resource_service.register_resource\n    >>> resource_service.register_resource = AsyncMock()\n    >>>\n    >>> async def test_admin_add_resource():\n    ...     response = await admin_add_resource(mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body.decode() == '{\"message\":\"Add resource registered successfully!\",\"success\":true}'\n    >>>\n    >>> import asyncio; asyncio.run(test_admin_add_resource())\n    True\n    >>> resource_service.register_resource = original_register_resource",
        "operationId": "admin_add_resource_admin_resources_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/prompts": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Prompts",
        "description": "List prompts for the admin UI with an option to include inactive prompts.\n\nThis endpoint retrieves a list of prompts from the database, optionally including\nthose that are inactive. The inactive filter helps administrators see and manage\nprompts that have been deactivated but not deleted from the system.\n\nArgs:\n    include_inactive (bool): Whether to include inactive prompts in the results.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    List[PromptRead]: A list of prompt records formatted with by_alias=True.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import PromptRead, PromptMetrics\n    >>> from datetime import datetime, timezone\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>>\n    >>> # Mock prompt data\n    >>> mock_prompt = PromptRead(\n    ...     id=1,\n    ...     name=\"Test Prompt\",\n    ...     description=\"A test prompt\",\n    ...     template=\"Hello {{name}}!\",\n    ...     arguments=[{\"name\": \"name\", \"type\": \"string\"}],\n    ...     created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc),\n    ...     is_active=True,\n    ...     metrics=PromptMetrics(\n    ...         total_executions=10, successful_executions=10, failed_executions=0,\n    ...         failure_rate=0.0, min_response_time=0.01, max_response_time=0.1,\n    ...         avg_response_time=0.05, last_execution_time=datetime.now(timezone.utc)\n    ...     ),\n    ...     tags=[]\n    ... )\n    >>>\n    >>> # Mock the prompt_service.list_prompts_for_user method\n    >>> original_list_prompts_for_user = prompt_service.list_prompts_for_user\n    >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[mock_prompt])\n    >>>\n    >>> # Test listing active prompts\n    >>> async def test_admin_list_prompts_active():\n    ...     result = await admin_list_prompts(include_inactive=False, db=mock_db, user=mock_user)\n    ...     return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == \"Test Prompt\"\n    >>>\n    >>> asyncio.run(test_admin_list_prompts_active())\n    True\n    >>>\n    >>> # Test listing with inactive prompts (if mock includes them)\n    >>> mock_inactive_prompt = PromptRead(\n    ...     id=2, name=\"Inactive Prompt\", description=\"Another test\", template=\"Bye!\",\n    ...     arguments=[], created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),\n    ...     is_active=False, metrics=PromptMetrics(\n    ...         total_executions=0, successful_executions=0, failed_executions=0,\n    ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0,\n    ...         avg_response_time=0.0, last_execution_time=None\n    ...     ),\n    ...     tags=[]\n    ... )\n    >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[mock_prompt, mock_inactive_prompt])\n    >>> async def test_admin_list_prompts_all():\n    ...     result = await admin_list_prompts(include_inactive=True, db=mock_db, user=mock_user)\n    ...     return len(result) == 2 and not result[1]['isActive']\n    >>>\n    >>> asyncio.run(test_admin_list_prompts_all())\n    True\n    >>>\n    >>> # Test empty list\n    >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[])\n    >>> async def test_admin_list_prompts_empty():\n    ...     result = await admin_list_prompts(include_inactive=False, db=mock_db, user=mock_user)\n    ...     return result == []\n    >>>\n    >>> asyncio.run(test_admin_list_prompts_empty())\n    True\n    >>>\n    >>> # Test exception handling\n    >>> prompt_service.list_prompts_for_user = AsyncMock(side_effect=Exception(\"Prompt list error\"))\n    >>> async def test_admin_list_prompts_exception():\n    ...     try:\n    ...         await admin_list_prompts(False, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Prompt list error\"\n    >>>\n    >>> asyncio.run(test_admin_list_prompts_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> prompt_service.list_prompts_for_user = original_list_prompts_for_user",
        "operationId": "admin_list_prompts_admin_prompts_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/PromptRead"
                  },
                  "title": "Response Admin List Prompts Admin Prompts Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Prompt",
        "description": "Add a prompt via the admin UI.\n\nExpects form fields:\n  - name\n  - description (optional)\n  - template\n  - arguments (as a JSON string representing a list)\n\nArgs:\n    request: FastAPI request containing form data.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    A redirect response to the admin dashboard.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> form_data = FormData([\n    ...     (\"name\", \"Test Prompt\"),\n    ...     (\"description\", \"A test prompt\"),\n    ...     (\"template\", \"Hello {{name}}!\"),\n    ...     (\"arguments\", '[{\"name\": \"name\", \"type\": \"string\"}]'),\n    ... ])\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_register_prompt = prompt_service.register_prompt\n    >>> prompt_service.register_prompt = AsyncMock()\n    >>>\n    >>> async def test_admin_add_prompt():\n    ...     response = await admin_add_prompt(mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body == b'{\"message\":\"Prompt registered successfully!\",\"success\":true}'\n    >>>\n    >>> asyncio.run(test_admin_add_prompt())\n    True\n\n    >>> prompt_service.register_prompt = original_register_prompt",
        "operationId": "admin_add_prompt_admin_prompts_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/gateways": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Gateways",
        "description": "List gateways for the admin UI with an option to include inactive gateways.\n\nThis endpoint retrieves a list of gateways from the database, optionally\nincluding those that are inactive. The inactive filter allows administrators\nto view and manage gateways that have been deactivated but not deleted.\n\nArgs:\n    include_inactive (bool): Whether to include inactive gateways in the results.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    List[GatewayRead]: A list of gateway records formatted with by_alias=True.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import GatewayRead\n    >>> from datetime import datetime, timezone\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>>\n    >>> # Mock gateway data\n    >>> mock_gateway = GatewayRead(\n    ...     id=\"gateway-1\",\n    ...     name=\"Test Gateway\",\n    ...     url=\"http://test.com\",\n    ...     description=\"A test gateway\",\n    ...     transport=\"HTTP\",\n    ...     created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc),\n    ...     is_active=True,\n    ...     auth_type=None, auth_username=None, auth_password=None, auth_token=None,\n    ...     auth_header_key=None, auth_header_value=None,\n    ...     slug=\"test-gateway\"\n    ... )\n    >>>\n    >>> # Mock the gateway_service.list_gateways_for_user method\n    >>> original_list_gateways = gateway_service.list_gateways_for_user\n    >>> gateway_service.list_gateways_for_user = AsyncMock(return_value=[mock_gateway])\n    >>>\n    >>> # Test listing active gateways\n    >>> async def test_admin_list_gateways_active():\n    ...     result = await admin_list_gateways(include_inactive=False, db=mock_db, user=mock_user)\n    ...     return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == \"Test Gateway\"\n    >>>\n    >>> asyncio.run(test_admin_list_gateways_active())\n    True\n    >>>\n    >>> # Test listing with inactive gateways (if mock includes them)\n    >>> mock_inactive_gateway = GatewayRead(\n    ...     id=\"gateway-2\", name=\"Inactive Gateway\", url=\"http://inactive.com\",\n    ...     description=\"Another test\", transport=\"HTTP\", created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc), enabled=False,\n    ...     auth_type=None, auth_username=None, auth_password=None, auth_token=None,\n    ...     auth_header_key=None, auth_header_value=None,\n    ...     slug=\"test-gateway\"\n    ... )\n    >>> gateway_service.list_gateways_for_user = AsyncMock(return_value=[\n    ...     mock_gateway, # Return the GatewayRead objects, not pre-dumped dicts\n    ...     mock_inactive_gateway # Return the GatewayRead objects, not pre-dumped dicts\n    ... ])\n    >>> async def test_admin_list_gateways_all():\n    ...     result = await admin_list_gateways(include_inactive=True, db=mock_db, user=mock_user)\n    ...     return len(result) == 2 and not result[1]['enabled']\n    >>>\n    >>> asyncio.run(test_admin_list_gateways_all())\n    True\n    >>>\n    >>> # Test empty list\n    >>> gateway_service.list_gateways_for_user = AsyncMock(return_value=[])\n    >>> async def test_admin_list_gateways_empty():\n    ...     result = await admin_list_gateways(include_inactive=False, db=mock_db, user=mock_user)\n    ...     return result == []\n    >>>\n    >>> asyncio.run(test_admin_list_gateways_empty())\n    True\n    >>>\n    >>> # Test exception handling\n    >>> gateway_service.list_gateways_for_user = AsyncMock(side_effect=Exception(\"Gateway list error\"))\n    >>> async def test_admin_list_gateways_exception():\n    ...     try:\n    ...         await admin_list_gateways(False, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Gateway list error\"\n    >>>\n    >>> asyncio.run(test_admin_list_gateways_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> gateway_service.list_gateways_for_user = original_list_gateways",
        "operationId": "admin_list_gateways_admin_gateways_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GatewayRead"
                  },
                  "title": "Response Admin List Gateways Admin Gateways Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Gateway",
        "description": "Add a gateway via the admin UI.\n\nExpects form fields:\n  - name\n  - url\n  - description (optional)\n  - tags (optional, comma-separated)\n\nArgs:\n    request: FastAPI request containing form data.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    A redirect response to the admin dashboard.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import JSONResponse\n    >>> from starlette.datastructures import FormData\n    >>> from mcpgateway.services.gateway_service import GatewayConnectionError\n    >>> from pydantic import ValidationError\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> from mcpgateway.utils.error_formatter import ErrorFormatter\n    >>> import json # Added import for json.loads\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>>\n    >>> # Happy path: Add a new gateway successfully with basic auth details\n    >>> form_data_success = FormData([\n    ...     (\"name\", \"New Gateway\"),\n    ...     (\"url\", \"http://new.gateway.com\"),\n    ...     (\"transport\", \"HTTP\"),\n    ...     (\"auth_type\", \"basic\"), # Valid auth_type\n    ...     (\"auth_username\", \"user\"), # Required for basic auth\n    ...     (\"auth_password\", \"pass\")  # Required for basic auth\n    ... ])\n    >>> mock_request_success = MagicMock(spec=Request)\n    >>> mock_request_success.form = AsyncMock(return_value=form_data_success)\n    >>> original_register_gateway = gateway_service.register_gateway\n    >>> gateway_service.register_gateway = AsyncMock()\n    >>>\n    >>> async def test_admin_add_gateway_success():\n    ...     response = await admin_add_gateway(mock_request_success, mock_db, mock_user)\n    ...     # Corrected: Access body and then parse JSON\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body)[\"success\"] is True\n    >>>\n    >>> asyncio.run(test_admin_add_gateway_success())\n    True\n    >>>\n    >>> # Error path: Gateway connection error\n    >>> form_data_conn_error = FormData([(\"name\", \"Bad Gateway\"), (\"url\", \"http://bad.com\"), (\"auth_type\", \"bearer\"), (\"auth_token\", \"abc\")]) # Added auth_type and token\n    >>> mock_request_conn_error = MagicMock(spec=Request)\n    >>> mock_request_conn_error.form = AsyncMock(return_value=form_data_conn_error)\n    >>> gateway_service.register_gateway = AsyncMock(side_effect=GatewayConnectionError(\"Connection failed\"))\n    >>>\n    >>> async def test_admin_add_gateway_connection_error():\n    ...     response = await admin_add_gateway(mock_request_conn_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 502 and json.loads(response.body)[\"success\"] is False\n    >>>\n    >>> asyncio.run(test_admin_add_gateway_connection_error())\n    True\n    >>>\n    >>> # Error path: Validation error (e.g., missing name)\n    >>> form_data_validation_error = FormData([(\"url\", \"http://no-name.com\"), (\"auth_type\", \"headers\"), (\"auth_header_key\", \"X-Key\"), (\"auth_header_value\", \"val\")]) # 'name' is missing, added auth_type\n    >>> mock_request_validation_error = MagicMock(spec=Request)\n    >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)\n    >>> # No need to mock register_gateway, ValidationError happens during GatewayCreate()\n    >>>\n    >>> async def test_admin_add_gateway_validation_error():\n    ...     response = await admin_add_gateway(mock_request_validation_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())[\"success\"] is False\n    >>>\n    >>> asyncio.run(test_admin_add_gateway_validation_error())\n    True\n    >>>\n    >>> # Error path: Integrity error (e.g., duplicate name)\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> form_data_integrity_error = FormData([(\"name\", \"Duplicate Gateway\"), (\"url\", \"http://duplicate.com\"), (\"auth_type\", \"basic\"), (\"auth_username\", \"u\"), (\"auth_password\", \"p\")]) # Added auth_type and creds\n    >>> mock_request_integrity_error = MagicMock(spec=Request)\n    >>> mock_request_integrity_error.form = AsyncMock(return_value=form_data_integrity_error)\n    >>> gateway_service.register_gateway = AsyncMock(side_effect=IntegrityError(\"Duplicate entry\", {}, {}))\n    >>>\n    >>> async def test_admin_add_gateway_integrity_error():\n    ...     response = await admin_add_gateway(mock_request_integrity_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())[\"success\"] is False\n    >>>\n    >>> asyncio.run(test_admin_add_gateway_integrity_error())\n    True\n    >>>\n    >>> # Error path: Generic RuntimeError\n    >>> form_data_runtime_error = FormData([(\"name\", \"Runtime Error Gateway\"), (\"url\", \"http://runtime.com\"), (\"auth_type\", \"basic\"), (\"auth_username\", \"u\"), (\"auth_password\", \"p\")]) # Added auth_type and creds\n    >>> mock_request_runtime_error = MagicMock(spec=Request)\n    >>> mock_request_runtime_error.form = AsyncMock(return_value=form_data_runtime_error)\n    >>> gateway_service.register_gateway = AsyncMock(side_effect=RuntimeError(\"Unexpected runtime issue\"))\n    >>>\n    >>> async def test_admin_add_gateway_runtime_error():\n    ...     response = await admin_add_gateway(mock_request_runtime_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())[\"success\"] is False\n    >>>\n    >>> asyncio.run(test_admin_add_gateway_runtime_error())\n    True\n    >>>\n    >>> # Restore original method\n    >>> gateway_service.register_gateway = original_register_gateway",
        "operationId": "admin_add_gateway_admin_gateways_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/gateways/{gateway_id}/toggle": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Toggle Gateway",
        "description": "Toggle the active status of a gateway via the admin UI.\n\nThis endpoint allows an admin to toggle the active status of a gateway.\nIt expects a form field 'activate' with a value of \"true\" or \"false\" to\ndetermine the new status of the gateway.\n\nArgs:\n    gateway_id (str): The ID of the gateway to toggle.\n    request (Request): The FastAPI request object containing form data.\n    db (Session): The database session dependency.\n    user (str): The authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect response to the admin dashboard with a\n    status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> gateway_id = \"gateway-to-toggle\"\n    >>>\n    >>> # Happy path: Activate gateway\n    >>> form_data_activate = FormData([(\"activate\", \"true\"), (\"is_inactive_checked\", \"false\")])\n    >>> mock_request_activate = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_activate.form = AsyncMock(return_value=form_data_activate)\n    >>> original_toggle_gateway_status = gateway_service.toggle_gateway_status\n    >>> gateway_service.toggle_gateway_status = AsyncMock()\n    >>>\n    >>> async def test_admin_toggle_gateway_activate():\n    ...     result = await admin_toggle_gateway(gateway_id, mock_request_activate, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin#gateways\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_gateway_activate())\n    True\n    >>>\n    >>> # Happy path: Deactivate gateway\n    >>> form_data_deactivate = FormData([(\"activate\", \"false\"), (\"is_inactive_checked\", \"false\")])\n    >>> mock_request_deactivate = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_deactivate.form = AsyncMock(return_value=form_data_deactivate)\n    >>>\n    >>> async def test_admin_toggle_gateway_deactivate():\n    ...     result = await admin_toggle_gateway(gateway_id, mock_request_deactivate, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/api/admin#gateways\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_gateway_deactivate())\n    True\n    >>>\n    >>> # Error path: Simulate an exception during toggle\n    >>> form_data_error = FormData([(\"activate\", \"true\")])\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> gateway_service.toggle_gateway_status = AsyncMock(side_effect=Exception(\"Toggle failed\"))\n    >>>\n    >>> async def test_admin_toggle_gateway_exception():\n    ...     result = await admin_toggle_gateway(gateway_id, mock_request_error, mock_db, mock_user)\n    ...     location_header = result.headers[\"location\"]\n    ...     return (\n    ...         isinstance(result, RedirectResponse)\n    ...         and result.status_code == 303\n    ...         and \"/admin\" in location_header  # Ensure '/admin' is present\n    ...         and \"error=\" in location_header  # Ensure the error parameter is in the query string\n    ...         and location_header.endswith(\"#gateways\")  # Ensure the fragment is correct\n    ...     )\n    >>>\n    >>> asyncio.run(test_admin_toggle_gateway_exception())\n    True\n    >>> # Restore original method\n    >>> gateway_service.toggle_gateway_status = original_toggle_gateway_status",
        "operationId": "admin_toggle_gateway_admin_gateways__gateway_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Home",
        "description": "Render the admin dashboard HTML page.\n\nThis endpoint serves as the main entry point to the admin UI. It fetches data for\nservers, tools, resources, prompts, gateways, and roots from their respective\nservices, then renders the admin dashboard template with this data.\n\nSupports optional `team_id` query param to scope the returned data to a team.\nIf `team_id` is provided and email-based team management is enabled, we\nvalidate the user is a member of that team. We attempt to pass team_id into\nservice listing functions (preferred). If the service API does not accept a\nteam_id parameter we fall back to post-filtering the returned items.\n\nThe endpoint also sets a JWT token as a cookie for authentication in subsequent\nrequests. This token is HTTP-only for security reasons.\n\nArgs:\n    request (Request): FastAPI request object.\n    team_id (Optional[str]): Optional team ID to filter data by team.\n    include_inactive (bool): Whether to include inactive items in all listings.\n    db (Session): Database session dependency.\n    user (dict): Authenticated user context with permissions.\n\nReturns:\n    Any: Rendered HTML template for the admin dashboard.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock, patch\n    >>> from fastapi import Request\n    >>> from fastapi.responses import HTMLResponse\n    >>> from mcpgateway.schemas import ServerRead, ToolRead, ResourceRead, PromptRead, GatewayRead, ServerMetrics, ToolMetrics, ResourceMetrics, PromptMetrics\n    >>> from datetime import datetime, timezone\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"admin_user\", \"db\": mock_db}\n    >>>\n    >>> # Mock services to return empty lists for simplicity in doctest\n    >>> original_list_servers_for_user = server_service.list_servers_for_user\n    >>> original_list_tools_for_user = tool_service.list_tools_for_user\n    >>> original_list_resources_for_user = resource_service.list_resources_for_user\n    >>> original_list_prompts_for_user = prompt_service.list_prompts_for_user\n    >>> original_list_gateways = gateway_service.list_gateways\n    >>> original_list_roots = root_service.list_roots\n    >>>\n    >>> server_service.list_servers_for_user = AsyncMock(return_value=[])\n    >>> tool_service.list_tools_for_user = AsyncMock(return_value=[])\n    >>> resource_service.list_resources_for_user = AsyncMock(return_value=[])\n    >>> prompt_service.list_prompts_for_user = AsyncMock(return_value=[])\n    >>> gateway_service.list_gateways = AsyncMock(return_value=[])\n    >>> root_service.list_roots = AsyncMock(return_value=[])\n    >>>\n    >>> # Mock request and template rendering\n    >>> mock_request = MagicMock(spec=Request, scope={\"root_path\": \"/admin_prefix\"})\n    >>> mock_request.app.state.templates = MagicMock()\n    >>> mock_template_response = HTMLResponse(\"<html>Admin UI</html>\")\n    >>> mock_request.app.state.templates.TemplateResponse.return_value = mock_template_response\n    >>>\n    >>> # Test basic rendering\n    >>> async def test_admin_ui_basic_render():\n    ...     response = await admin_ui(mock_request, None, False, mock_db, mock_user)\n    ...     return isinstance(response, HTMLResponse) and response.status_code == 200\n    >>>\n    >>> asyncio.run(test_admin_ui_basic_render())\n    True\n    >>>\n    >>> # Test with include_inactive=True\n    >>> async def test_admin_ui_include_inactive():\n    ...     response = await admin_ui(mock_request, None, True, mock_db, mock_user)\n    ...     # Verify list methods were called with include_inactive=True\n    ...     server_service.list_servers_for_user.assert_called_with(mock_db, mock_user[\"email\"], include_inactive=True)\n    ...     return isinstance(response, HTMLResponse)\n    >>>\n    >>> asyncio.run(test_admin_ui_include_inactive())\n    True\n    >>>\n    >>> # Test with populated data (mocking a few items)\n    >>> mock_server = ServerRead(id=\"s1\", name=\"S1\", description=\"d\", created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc), is_active=True, associated_tools=[], associated_resources=[], associated_prompts=[], icon=\"i\", metrics=ServerMetrics(total_executions=0, successful_executions=0, failed_executions=0, failure_rate=0.0, min_response_time=0.0, max_response_time=0.0, avg_response_time=0.0, last_execution_time=None))\n    >>> mock_tool = ToolRead(\n    ...     id=\"t1\", name=\"T1\", original_name=\"T1\", url=\"http://t1.com\", description=\"d\",\n    ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),\n    ...     enabled=True, reachable=True, gateway_slug=\"default\", custom_name_slug=\"t1\",\n    ...     request_type=\"GET\", integration_type=\"MCP\", headers={}, input_schema={},\n    ...     annotations={}, jsonpath_filter=None, auth=None, execution_count=0,\n    ...     metrics=ToolMetrics(\n    ...         total_executions=0, successful_executions=0, failed_executions=0,\n    ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0,\n    ...         avg_response_time=0.0, last_execution_time=None\n    ...     ),\n    ...     gateway_id=None,\n    ...     customName=\"T1\",\n    ...     tags=[]\n    ... )\n    >>> server_service.list_servers_for_user = AsyncMock(return_value=[mock_server])\n    >>> tool_service.list_tools_for_user = AsyncMock(return_value=[mock_tool])\n    >>>\n    >>> async def test_admin_ui_with_data():\n    ...     response = await admin_ui(mock_request, None, False, mock_db, mock_user)\n    ...     # Check if template context was populated (indirectly via mock calls)\n    ...     assert mock_request.app.state.templates.TemplateResponse.call_count >= 1\n    ...     context = mock_request.app.state.templates.TemplateResponse.call_args[0][2]\n    ...     return len(context['servers']) == 1 and len(context['tools']) == 1\n    >>>\n    >>> asyncio.run(test_admin_ui_with_data())\n    True\n    >>>\n    >>> from unittest.mock import AsyncMock, patch\n    >>> import logging\n    >>>\n    >>> server_service.list_servers_for_user = AsyncMock(side_effect=Exception(\"DB error\"))\n    >>>\n    >>> async def test_admin_ui_exception_handled():\n    ...     with patch(\"mcpgateway.admin.LOGGER.exception\") as mock_log:\n    ...         response = await admin_ui(\n    ...             request=mock_request,\n    ...             team_id=None,\n    ...             include_inactive=False,\n    ...             db=mock_db,\n    ...             user=mock_user\n    ...         )\n    ...         # Check that the response rendered correctly\n    ...         ok_response = isinstance(response, HTMLResponse) and response.status_code == 200\n    ...         # Check that the exception was logged\n    ...         log_called = mock_log.called\n    ...         # Optionally, you can even inspect the message if you want\n    ...         return ok_response and log_called\n    >>>\n    >>> asyncio.run(test_admin_ui_exception_handled())\n    True\n    >>>\n    >>> # Restore original methods\n    >>> server_service.list_servers_for_user = original_list_servers_for_user\n    >>> tool_service.list_tools_for_user = original_list_tools_for_user\n    >>> resource_service.list_resources_for_user = original_list_resources_for_user\n    >>> prompt_service.list_prompts_for_user = original_list_prompts_for_user\n    >>> gateway_service.list_gateways = original_list_gateways\n    >>> root_service.list_roots = original_list_roots",
        "operationId": "admin_home_admin__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "text/html": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/login": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Login Page",
        "description": "Render the admin login page.\n\nThis endpoint serves the login form for email-based authentication.\nIf email auth is disabled, redirects to the main admin page.\n\nArgs:\n    request (Request): FastAPI request object.\n\nReturns:\n    Response: Rendered HTML or redirect response.\n\nExamples:\n    >>> from fastapi import Request\n    >>> from fastapi.responses import HTMLResponse\n    >>> from unittest.mock import MagicMock\n    >>>\n    >>> # Mock request\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.scope = {\"root_path\": \"/test\"}\n    >>> mock_request.app.state.templates = MagicMock()\n    >>> mock_response = HTMLResponse(\"<html>Login</html>\")\n    >>> mock_request.app.state.templates.TemplateResponse.return_value = mock_response\n    >>>\n    >>> import asyncio\n    >>> async def test_login_page():\n    ...     response = await admin_login_page(mock_request)\n    ...     return isinstance(response, HTMLResponse)\n    >>>\n    >>> asyncio.run(test_login_page())\n    True",
        "operationId": "admin_login_page_admin_login_get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Login Handler",
        "description": "Handle admin login form submission.\n\nThis endpoint processes the email/password login form, authenticates the user,\nsets the JWT cookie, and redirects to the admin panel or back to login with error.\n\nArgs:\n    request (Request): FastAPI request object.\n    db (Session): Database session dependency.\n\nReturns:\n    RedirectResponse: Redirect to admin panel on success or login page on failure.\n\nExamples:\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from unittest.mock import MagicMock, AsyncMock\n    >>>\n    >>> # Mock request with form data\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.scope = {\"root_path\": \"/test\"}\n    >>> mock_form = {\"email\": \"admin@example.com\", \"password\": \"changeme\"}\n    >>> mock_request.form = AsyncMock(return_value=mock_form)\n    >>>\n    >>> mock_db = MagicMock()\n    >>>\n    >>> import asyncio\n    >>> async def test_login_handler():\n    ...     try:\n    ...         response = await admin_login_handler(mock_request, mock_db)\n    ...         return isinstance(response, RedirectResponse)\n    ...     except Exception:\n    ...         return True  # Expected due to mocked dependencies\n    >>>\n    >>> asyncio.run(test_login_handler())\n    True",
        "operationId": "admin_login_handler_admin_login_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/admin/logout": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Logout",
        "description": "Handle admin logout by clearing authentication cookies.\n\nThis endpoint clears the JWT authentication cookie and redirects\nthe user to a login page or back to the admin page (which will\ntrigger authentication).\n\nArgs:\n    request (Request): FastAPI request object.\n\nReturns:\n    RedirectResponse: Redirect to admin page with cleared cookies.\n\nExamples:\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from unittest.mock import MagicMock\n    >>>\n    >>> # Mock request\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.scope = {\"root_path\": \"/test\"}\n    >>>\n    >>> import asyncio\n    >>> async def test_logout():\n    ...     response = await admin_logout(mock_request)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_logout())\n    True",
        "operationId": "admin_logout_admin_logout_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/admin/teams": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Teams",
        "description": "List teams for admin UI via HTMX.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated admin user\n    unified: If True, return unified team view with relationship badges\n\nReturns:\n    HTML response with teams list\n\nRaises:\n    HTTPException: If email auth is disabled or user not found",
        "operationId": "admin_list_teams_admin_teams_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "unified",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Unified"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Create Team",
        "description": "Create team via admin UI form submission.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated admin user\n\nReturns:\n    HTML response with new team or error message\n\nRaises:\n    HTTPException: If email auth is disabled or validation fails",
        "operationId": "admin_create_team_admin_teams_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/members": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin View Team Members",
        "description": "View team members via admin UI.\n\nArgs:\n    team_id: ID of the team to view members for\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Rendered team members view",
        "operationId": "admin_view_team_members_admin_teams__team_id__members_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/edit": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Team Edit",
        "description": "Get team edit form via admin UI.\n\nArgs:\n    team_id: ID of the team to edit\n    db: Database session\n\nReturns:\n    HTMLResponse: Rendered team edit form",
        "operationId": "admin_get_team_edit_admin_teams__team_id__edit_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/update": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Update Team",
        "description": "Update team via admin UI.\n\nArgs:\n    team_id: ID of the team to update\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    Response: Result of team update operation",
        "operationId": "admin_update_team_admin_teams__team_id__update_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}": {
      "delete": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Team",
        "description": "Delete team via admin UI.\n\nArgs:\n    team_id: ID of the team to delete\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_delete_team_admin_teams__team_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/add-member": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Team Member",
        "description": "Add member to team via admin UI.\n\nArgs:\n    team_id: ID of the team to add member to\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_add_team_member_admin_teams__team_id__add_member_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/update-member-role": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Update Team Member Role",
        "description": "Update team member role via admin UI.\n\nArgs:\n    team_id: ID of the team containing the member\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_update_team_member_role_admin_teams__team_id__update_member_role_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/remove-member": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Remove Team Member",
        "description": "Remove member from team via admin UI.\n\nArgs:\n    team_id: ID of the team to remove member from\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_remove_team_member_admin_teams__team_id__remove_member_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/leave": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Leave Team",
        "description": "Leave a team via admin UI.\n\nArgs:\n    team_id: ID of the team to leave\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_leave_team_admin_teams__team_id__leave_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/join-request": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Create Join Request",
        "description": "Create a join request for a team via admin UI.\n\nArgs:\n    team_id: ID of the team to request to join\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    HTML response with success message or error",
        "operationId": "admin_create_join_request_admin_teams__team_id__join_request_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/join-request/{request_id}": {
      "delete": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Cancel Join Request",
        "description": "Cancel a join request via admin UI.\n\nArgs:\n    team_id: ID of the team\n    request_id: ID of the join request to cancel\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    HTML response with updated button state",
        "operationId": "admin_cancel_join_request_admin_teams__team_id__join_request__request_id__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "request_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Request Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/join-requests": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Join Requests",
        "description": "List join requests for a team via admin UI.\n\nArgs:\n    team_id: ID of the team\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    HTML response with join requests list",
        "operationId": "admin_list_join_requests_admin_teams__team_id__join_requests_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/join-requests/{request_id}/approve": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Approve Join Request",
        "description": "Approve a join request via admin UI.\n\nArgs:\n    team_id: ID of the team\n    request_id: ID of the join request to approve\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    HTML response with success message",
        "operationId": "admin_approve_join_request_admin_teams__team_id__join_requests__request_id__approve_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "request_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Request Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/teams/{team_id}/join-requests/{request_id}/reject": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Reject Join Request",
        "description": "Reject a join request via admin UI.\n\nArgs:\n    team_id: ID of the team\n    request_id: ID of the join request to reject\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    HTML response with success message",
        "operationId": "admin_reject_join_request_admin_teams__team_id__join_requests__request_id__reject_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Team Id"
            }
          },
          {
            "name": "request_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Request Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/users": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Users",
        "description": "List users for admin UI via HTMX.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    Response: HTML or JSON response with users list",
        "operationId": "admin_list_users_admin_users_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Create User",
        "description": "Create a new user via admin UI.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_create_user_admin_users_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/users/{user_email}/edit": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get User Edit",
        "description": "Get user edit form via admin UI.\n\nArgs:\n    user_email: Email of user to edit\n    db: Database session\n\nReturns:\n    HTMLResponse: User edit form HTML",
        "operationId": "admin_get_user_edit_admin_users__user_email__edit_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/users/{user_email}/update": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Update User",
        "description": "Update user via admin UI.\n\nArgs:\n    user_email: Email of user to update\n    request: FastAPI request object\n    db: Database session\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_update_user_admin_users__user_email__update_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/users/{user_email}/activate": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Activate User",
        "description": "Activate user via admin UI.\n\nArgs:\n    user_email: Email of user to activate\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_activate_user_admin_users__user_email__activate_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/users/{user_email}/deactivate": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Deactivate User",
        "description": "Deactivate user via admin UI.\n\nArgs:\n    user_email: Email of user to deactivate\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success message or error response",
        "operationId": "admin_deactivate_user_admin_users__user_email__deactivate_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/users/{user_email}": {
      "delete": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete User",
        "description": "Delete user via admin UI.\n\nArgs:\n    user_email: Email address of user to delete\n    _request: FastAPI request object (unused)\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    HTMLResponse: Success/error message",
        "operationId": "admin_delete_user_admin_users__user_email__delete",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "user_email",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "User Email"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Tools",
        "description": "List tools for the admin UI with pagination support.\n\nThis endpoint retrieves a paginated list of tools from the database, optionally\nincluding those that are inactive. Supports offset-based pagination with\nconfigurable page size.\n\nArgs:\n    page (int): Page number (1-indexed). Default: 1.\n    per_page (int): Items per page (1-500). Default: 50.\n    include_inactive (bool): Whether to include inactive tools in the results.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    Dict with 'data', 'pagination', and 'links' keys containing paginated tools.",
        "operationId": "admin_list_tools_admin_tools_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "description": "Page number (1-indexed)",
              "default": 1,
              "title": "Page"
            },
            "description": "Page number (1-indexed)"
          },
          {
            "name": "per_page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 500,
              "minimum": 1,
              "description": "Items per page",
              "default": 50,
              "title": "Per Page"
            },
            "description": "Items per page"
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Admin List Tools Admin Tools Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Tool",
        "description": "Add a tool via the admin UI with error handling.\n\nExpects form fields:\n  - name\n  - url\n  - description (optional)\n  - requestType (mapped to request_type; defaults to \"SSE\")\n  - integrationType (mapped to integration_type; defaults to \"MCP\")\n  - headers (JSON string)\n  - input_schema (JSON string)\n  - output_schema (JSON string, optional)\n  - jsonpath_filter (optional)\n  - auth_type (optional)\n  - auth_username (optional)\n  - auth_password (optional)\n  - auth_token (optional)\n  - auth_header_key (optional)\n  - auth_header_value (optional)\n\nLogs the raw form data and assembled tool_data for debugging.\n\nArgs:\n    request (Request): the FastAPI request object containing the form data.\n    db (Session): the SQLAlchemy database session.\n    user (str): identifier of the authenticated user.\n\nReturns:\n    JSONResponse: a JSON response with `{\"message\": ..., \"success\": ...}` and an appropriate HTTP status code.\n\nExamples:\n    Examples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import JSONResponse\n    >>> from starlette.datastructures import FormData\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> from mcpgateway.utils.error_formatter import ErrorFormatter\n    >>> import json\n\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n\n    >>> # Happy path: Add a new tool successfully\n    >>> form_data_success = FormData([\n    ...     (\"name\", \"New_Tool\"),\n    ...     (\"url\", \"http://new.tool.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\"),\n    ...     (\"headers\", '{\"X-Api-Key\": \"abc\"}')\n    ... ])\n    >>> mock_request_success = MagicMock(spec=Request)\n    >>> mock_request_success.form = AsyncMock(return_value=form_data_success)\n    >>> original_register_tool = tool_service.register_tool\n    >>> tool_service.register_tool = AsyncMock()\n\n    >>> async def test_admin_add_tool_success():\n    ...     response = await admin_add_tool(mock_request_success, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())[\"success\"] is True\n\n    >>> asyncio.run(test_admin_add_tool_success())\n    True\n\n    >>> # Error path: Tool name conflict via IntegrityError\n    >>> form_data_conflict = FormData([\n    ...     (\"name\", \"Existing_Tool\"),\n    ...     (\"url\", \"http://existing.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_conflict = MagicMock(spec=Request)\n    >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)\n    >>> fake_integrity_error = IntegrityError(\"Mock Integrity Error\", {}, None)\n    >>> tool_service.register_tool = AsyncMock(side_effect=fake_integrity_error)\n\n    >>> async def test_admin_add_tool_integrity_error():\n    ...     response = await admin_add_tool(mock_request_conflict, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_add_tool_integrity_error())\n    True\n\n    >>> # Error path: Missing required field (Pydantic ValidationError)\n    >>> form_data_missing = FormData([\n    ...     (\"url\", \"http://missing.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_missing = MagicMock(spec=Request)\n    >>> mock_request_missing.form = AsyncMock(return_value=form_data_missing)\n\n    >>> async def test_admin_add_tool_validation_error():\n    ...     response = await admin_add_tool(mock_request_missing, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_add_tool_validation_error())  # doctest: +ELLIPSIS\n    True\n\n    >>> # Error path: Unexpected exception\n    >>> form_data_generic_error = FormData([\n    ...     (\"name\", \"Generic_Error_Tool\"),\n    ...     (\"url\", \"http://generic.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_generic_error = MagicMock(spec=Request)\n    >>> mock_request_generic_error.form = AsyncMock(return_value=form_data_generic_error)\n    >>> tool_service.register_tool = AsyncMock(side_effect=Exception(\"Unexpected error\"))\n\n    >>> async def test_admin_add_tool_generic_exception():\n    ...     response = await admin_add_tool(mock_request_generic_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_add_tool_generic_exception())\n    True\n\n    >>> # Restore original method\n    >>> tool_service.register_tool = original_register_tool",
        "operationId": "admin_add_tool_admin_tools_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/partial": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Tools Partial Html",
        "description": "Return HTML partial for paginated tools list (HTMX endpoint).\n\nThis endpoint returns only the table body rows and pagination controls\nfor HTMX-based pagination in the admin UI.\n\nArgs:\n    request (Request): FastAPI request object.\n    page (int): Page number (1-indexed). Default: 1.\n    per_page (int): Items per page (1-500). Default: 50.\n    include_inactive (bool): Whether to include inactive tools in the results.\n    render (str): Render mode - 'controls' returns only pagination controls.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    HTMLResponse with tools table rows and pagination controls.",
        "operationId": "admin_tools_partial_html_admin_tools_partial_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "minimum": 1,
              "description": "Page number (1-indexed)",
              "default": 1,
              "title": "Page"
            },
            "description": "Page number (1-indexed)"
          },
          {
            "name": "per_page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "maximum": 500,
              "minimum": 1,
              "description": "Items per page",
              "default": 50,
              "title": "Per Page"
            },
            "description": "Items per page"
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "render",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "description": "Render mode: 'controls' for pagination controls only",
              "title": "Render"
            },
            "description": "Render mode: 'controls' for pagination controls only"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "text/html": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/{tool_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Tool",
        "description": "Retrieve specific tool details for the admin UI.\n\nThis endpoint fetches the details of a specific tool from the database\nby its ID. It provides access to all information about the tool for\nviewing and management purposes.\n\nArgs:\n    tool_id (str): The ID of the tool to retrieve.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    ToolRead: The tool details formatted with by_alias=True.\n\nRaises:\n    HTTPException: If the tool is not found.\n    Exception: For any other unexpected errors.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import ToolRead, ToolMetrics\n    >>> from datetime import datetime, timezone\n    >>> from mcpgateway.services.tool_service import ToolNotFoundError # Added import\n    >>> from fastapi import HTTPException\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> tool_id = \"test-tool-id\"\n    >>>\n    >>> # Mock tool data\n    >>> mock_tool = ToolRead(\n    ...     id=tool_id, name=\"Get Tool\", original_name=\"GetTool\", url=\"http://get.com\",\n    ...     description=\"Tool for getting\", request_type=\"GET\", integration_type=\"REST\",\n    ...     headers={}, input_schema={}, annotations={}, jsonpath_filter=None, auth=None,\n    ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),\n    ...     enabled=True, reachable=True, gateway_id=None, execution_count=0,\n    ...     metrics=ToolMetrics(\n    ...         total_executions=0, successful_executions=0, failed_executions=0,\n    ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0, avg_response_time=0.0,\n    ...         last_execution_time=None\n    ...     ),\n    ...     gateway_slug=\"default\", custom_name_slug=\"get-tool\",\n    ...     customName=\"Get Tool\",\n    ...     tags=[]\n    ... )\n    >>>\n    >>> # Mock the tool_service.get_tool method\n    >>> original_get_tool = tool_service.get_tool\n    >>> tool_service.get_tool = AsyncMock(return_value=mock_tool)\n    >>>\n    >>> # Test successful retrieval\n    >>> async def test_admin_get_tool_success():\n    ...     result = await admin_get_tool(tool_id, mock_db, mock_user)\n    ...     return isinstance(result, dict) and result['id'] == tool_id\n    >>>\n    >>> asyncio.run(test_admin_get_tool_success())\n    True\n    >>>\n    >>> # Test tool not found\n    >>> tool_service.get_tool = AsyncMock(side_effect=ToolNotFoundError(\"Tool not found\"))\n    >>> async def test_admin_get_tool_not_found():\n    ...     try:\n    ...         await admin_get_tool(\"nonexistent\", mock_db, mock_user)\n    ...         return False\n    ...     except HTTPException as e:\n    ...         return e.status_code == 404 and \"Tool not found\" in e.detail\n    >>>\n    >>> asyncio.run(test_admin_get_tool_not_found())\n    True\n    >>>\n    >>> # Test generic exception\n    >>> tool_service.get_tool = AsyncMock(side_effect=Exception(\"Generic error\"))\n    >>> async def test_admin_get_tool_exception():\n    ...     try:\n    ...         await admin_get_tool(tool_id, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Generic error\"\n    >>>\n    >>> asyncio.run(test_admin_get_tool_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> tool_service.get_tool = original_get_tool",
        "operationId": "admin_get_tool_admin_tools__tool_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ToolRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Tool",
        "description": "Add a tool via the admin UI with error handling.\n\nExpects form fields:\n  - name\n  - url\n  - description (optional)\n  - requestType (mapped to request_type; defaults to \"SSE\")\n  - integrationType (mapped to integration_type; defaults to \"MCP\")\n  - headers (JSON string)\n  - input_schema (JSON string)\n  - output_schema (JSON string, optional)\n  - jsonpath_filter (optional)\n  - auth_type (optional)\n  - auth_username (optional)\n  - auth_password (optional)\n  - auth_token (optional)\n  - auth_header_key (optional)\n  - auth_header_value (optional)\n\nLogs the raw form data and assembled tool_data for debugging.\n\nArgs:\n    request (Request): the FastAPI request object containing the form data.\n    db (Session): the SQLAlchemy database session.\n    user (str): identifier of the authenticated user.\n\nReturns:\n    JSONResponse: a JSON response with `{\"message\": ..., \"success\": ...}` and an appropriate HTTP status code.\n\nExamples:\n    Examples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import JSONResponse\n    >>> from starlette.datastructures import FormData\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> from mcpgateway.utils.error_formatter import ErrorFormatter\n    >>> import json\n\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n\n    >>> # Happy path: Add a new tool successfully\n    >>> form_data_success = FormData([\n    ...     (\"name\", \"New_Tool\"),\n    ...     (\"url\", \"http://new.tool.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\"),\n    ...     (\"headers\", '{\"X-Api-Key\": \"abc\"}')\n    ... ])\n    >>> mock_request_success = MagicMock(spec=Request)\n    >>> mock_request_success.form = AsyncMock(return_value=form_data_success)\n    >>> original_register_tool = tool_service.register_tool\n    >>> tool_service.register_tool = AsyncMock()\n\n    >>> async def test_admin_add_tool_success():\n    ...     response = await admin_add_tool(mock_request_success, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())[\"success\"] is True\n\n    >>> asyncio.run(test_admin_add_tool_success())\n    True\n\n    >>> # Error path: Tool name conflict via IntegrityError\n    >>> form_data_conflict = FormData([\n    ...     (\"name\", \"Existing_Tool\"),\n    ...     (\"url\", \"http://existing.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_conflict = MagicMock(spec=Request)\n    >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)\n    >>> fake_integrity_error = IntegrityError(\"Mock Integrity Error\", {}, None)\n    >>> tool_service.register_tool = AsyncMock(side_effect=fake_integrity_error)\n\n    >>> async def test_admin_add_tool_integrity_error():\n    ...     response = await admin_add_tool(mock_request_conflict, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_add_tool_integrity_error())\n    True\n\n    >>> # Error path: Missing required field (Pydantic ValidationError)\n    >>> form_data_missing = FormData([\n    ...     (\"url\", \"http://missing.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_missing = MagicMock(spec=Request)\n    >>> mock_request_missing.form = AsyncMock(return_value=form_data_missing)\n\n    >>> async def test_admin_add_tool_validation_error():\n    ...     response = await admin_add_tool(mock_request_missing, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_add_tool_validation_error())  # doctest: +ELLIPSIS\n    True\n\n    >>> # Error path: Unexpected exception\n    >>> form_data_generic_error = FormData([\n    ...     (\"name\", \"Generic_Error_Tool\"),\n    ...     (\"url\", \"http://generic.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_generic_error = MagicMock(spec=Request)\n    >>> mock_request_generic_error.form = AsyncMock(return_value=form_data_generic_error)\n    >>> tool_service.register_tool = AsyncMock(side_effect=Exception(\"Unexpected error\"))\n\n    >>> async def test_admin_add_tool_generic_exception():\n    ...     response = await admin_add_tool(mock_request_generic_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_add_tool_generic_exception())\n    True\n\n    >>> # Restore original method\n    >>> tool_service.register_tool = original_register_tool",
        "operationId": "admin_add_tool_admin_tools__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/{tool_id}/edit": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Edit Tool",
        "description": "Edit a tool via the admin UI.\n\nExpects form fields:\n  - name\n  - displayName (optional)\n  - url\n  - description (optional)\n  - requestType (to be mapped to request_type)\n  - integrationType (to be mapped to integration_type)\n  - headers (as a JSON string)\n  - input_schema (as a JSON string)\n  - output_schema (as a JSON string, optional)\n  - jsonpathFilter (optional)\n  - auth_type (optional, string: \"basic\", \"bearer\", or empty)\n  - auth_username (optional, for basic auth)\n  - auth_password (optional, for basic auth)\n  - auth_token (optional, for bearer auth)\n  - auth_header_key (optional, for headers auth)\n  - auth_header_value (optional, for headers auth)\n\nAssembles the tool_data dictionary by remapping form keys into the\nsnake-case keys expected by the schemas.\n\nArgs:\n    tool_id (str): The ID of the tool to edit.\n    request (Request): FastAPI request containing form data.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    Response: A redirect response to the tools section of the admin\n        dashboard with a status code of 303 (See Other), or a JSON response with\n        an error message if the update fails.\n\nExamples:\n        Examples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse, JSONResponse\n    >>> from starlette.datastructures import FormData\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> from mcpgateway.services.tool_service import ToolError\n    >>> from pydantic import ValidationError\n    >>> from mcpgateway.utils.error_formatter import ErrorFormatter\n    >>> import json\n\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> tool_id = \"tool-to-edit\"\n\n    >>> # Happy path: Edit tool successfully\n    >>> form_data_success = FormData([\n    ...     (\"name\", \"Updated_Tool\"),\n    ...     (\"customName\", \"ValidToolName\"),\n    ...     (\"url\", \"http://updated.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\"),\n    ...     (\"headers\", '{\"X-Api-Key\": \"abc\"}'),\n    ...     (\"input_schema\", '{}'),  #  Required field\n    ...     (\"description\", \"Sample tool\")\n    ... ])\n    >>> mock_request_success = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_success.form = AsyncMock(return_value=form_data_success)\n    >>> original_update_tool = tool_service.update_tool\n    >>> tool_service.update_tool = AsyncMock()\n\n    >>> async def test_admin_edit_tool_success():\n    ...     response = await admin_edit_tool(tool_id, mock_request_success, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())[\"success\"] is True\n\n    >>> asyncio.run(test_admin_edit_tool_success())\n    True\n\n    >>> # Edge case: Edit tool with inactive checkbox checked\n    >>> form_data_inactive = FormData([\n    ...     (\"name\", \"Inactive_Edit\"),\n    ...     (\"customName\", \"ValidToolName\"),\n    ...     (\"url\", \"http://inactive.com\"),\n    ...     (\"is_inactive_checked\", \"true\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n\n    >>> async def test_admin_edit_tool_inactive_checked():\n    ...     response = await admin_edit_tool(tool_id, mock_request_inactive, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())[\"success\"] is True\n\n    >>> asyncio.run(test_admin_edit_tool_inactive_checked())\n    True\n\n    >>> # Error path: Tool name conflict (simulated with IntegrityError)\n    >>> form_data_conflict = FormData([\n    ...     (\"name\", \"Conflicting_Name\"),\n    ...     (\"customName\", \"Conflicting_Name\"),\n    ...     (\"url\", \"http://conflict.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_conflict = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)\n    >>> tool_service.update_tool = AsyncMock(side_effect=IntegrityError(\"Conflict\", {}, None))\n\n    >>> async def test_admin_edit_tool_integrity_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_conflict, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_integrity_error())\n    True\n\n    >>> # Error path: ToolError raised\n    >>> form_data_tool_error = FormData([\n    ...     (\"name\", \"Tool_Error\"),\n    ...     (\"customName\", \"Tool_Error\"),\n    ...     (\"url\", \"http://toolerror.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_tool_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_tool_error.form = AsyncMock(return_value=form_data_tool_error)\n    >>> tool_service.update_tool = AsyncMock(side_effect=ToolError(\"Tool specific error\"))\n\n    >>> async def test_admin_edit_tool_tool_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_tool_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_tool_error())\n    True\n\n    >>> # Error path: Pydantic Validation Error\n    >>> form_data_validation_error = FormData([\n    ...     (\"name\", \"Bad_URL\"),\n    ...     (\"customName\",\"Bad_Custom_Name\"),\n    ...     (\"url\", \"not-a-valid-url\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_validation_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)\n\n    >>> async def test_admin_edit_tool_validation_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_validation_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_validation_error())\n    True\n\n    >>> # Error path: Unexpected exception\n    >>> form_data_unexpected = FormData([\n    ...     (\"name\", \"Crash_Tool\"),\n    ...     (\"customName\", \"Crash_Tool\"),\n    ...     (\"url\", \"http://crash.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_unexpected = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_unexpected.form = AsyncMock(return_value=form_data_unexpected)\n    >>> tool_service.update_tool = AsyncMock(side_effect=Exception(\"Unexpected server crash\"))\n\n    >>> async def test_admin_edit_tool_unexpected_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_unexpected, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_unexpected_error())\n    True\n\n    >>> # Restore original method\n    >>> tool_service.update_tool = original_update_tool",
        "operationId": "admin_edit_tool_admin_tools__tool_id__edit_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/{tool_id}/edit/": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Edit Tool",
        "description": "Edit a tool via the admin UI.\n\nExpects form fields:\n  - name\n  - displayName (optional)\n  - url\n  - description (optional)\n  - requestType (to be mapped to request_type)\n  - integrationType (to be mapped to integration_type)\n  - headers (as a JSON string)\n  - input_schema (as a JSON string)\n  - output_schema (as a JSON string, optional)\n  - jsonpathFilter (optional)\n  - auth_type (optional, string: \"basic\", \"bearer\", or empty)\n  - auth_username (optional, for basic auth)\n  - auth_password (optional, for basic auth)\n  - auth_token (optional, for bearer auth)\n  - auth_header_key (optional, for headers auth)\n  - auth_header_value (optional, for headers auth)\n\nAssembles the tool_data dictionary by remapping form keys into the\nsnake-case keys expected by the schemas.\n\nArgs:\n    tool_id (str): The ID of the tool to edit.\n    request (Request): FastAPI request containing form data.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    Response: A redirect response to the tools section of the admin\n        dashboard with a status code of 303 (See Other), or a JSON response with\n        an error message if the update fails.\n\nExamples:\n        Examples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse, JSONResponse\n    >>> from starlette.datastructures import FormData\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> from mcpgateway.services.tool_service import ToolError\n    >>> from pydantic import ValidationError\n    >>> from mcpgateway.utils.error_formatter import ErrorFormatter\n    >>> import json\n\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> tool_id = \"tool-to-edit\"\n\n    >>> # Happy path: Edit tool successfully\n    >>> form_data_success = FormData([\n    ...     (\"name\", \"Updated_Tool\"),\n    ...     (\"customName\", \"ValidToolName\"),\n    ...     (\"url\", \"http://updated.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\"),\n    ...     (\"headers\", '{\"X-Api-Key\": \"abc\"}'),\n    ...     (\"input_schema\", '{}'),  #  Required field\n    ...     (\"description\", \"Sample tool\")\n    ... ])\n    >>> mock_request_success = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_success.form = AsyncMock(return_value=form_data_success)\n    >>> original_update_tool = tool_service.update_tool\n    >>> tool_service.update_tool = AsyncMock()\n\n    >>> async def test_admin_edit_tool_success():\n    ...     response = await admin_edit_tool(tool_id, mock_request_success, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())[\"success\"] is True\n\n    >>> asyncio.run(test_admin_edit_tool_success())\n    True\n\n    >>> # Edge case: Edit tool with inactive checkbox checked\n    >>> form_data_inactive = FormData([\n    ...     (\"name\", \"Inactive_Edit\"),\n    ...     (\"customName\", \"ValidToolName\"),\n    ...     (\"url\", \"http://inactive.com\"),\n    ...     (\"is_inactive_checked\", \"true\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n\n    >>> async def test_admin_edit_tool_inactive_checked():\n    ...     response = await admin_edit_tool(tool_id, mock_request_inactive, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body.decode())[\"success\"] is True\n\n    >>> asyncio.run(test_admin_edit_tool_inactive_checked())\n    True\n\n    >>> # Error path: Tool name conflict (simulated with IntegrityError)\n    >>> form_data_conflict = FormData([\n    ...     (\"name\", \"Conflicting_Name\"),\n    ...     (\"customName\", \"Conflicting_Name\"),\n    ...     (\"url\", \"http://conflict.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_conflict = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_conflict.form = AsyncMock(return_value=form_data_conflict)\n    >>> tool_service.update_tool = AsyncMock(side_effect=IntegrityError(\"Conflict\", {}, None))\n\n    >>> async def test_admin_edit_tool_integrity_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_conflict, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 409 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_integrity_error())\n    True\n\n    >>> # Error path: ToolError raised\n    >>> form_data_tool_error = FormData([\n    ...     (\"name\", \"Tool_Error\"),\n    ...     (\"customName\", \"Tool_Error\"),\n    ...     (\"url\", \"http://toolerror.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_tool_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_tool_error.form = AsyncMock(return_value=form_data_tool_error)\n    >>> tool_service.update_tool = AsyncMock(side_effect=ToolError(\"Tool specific error\"))\n\n    >>> async def test_admin_edit_tool_tool_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_tool_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_tool_error())\n    True\n\n    >>> # Error path: Pydantic Validation Error\n    >>> form_data_validation_error = FormData([\n    ...     (\"name\", \"Bad_URL\"),\n    ...     (\"customName\",\"Bad_Custom_Name\"),\n    ...     (\"url\", \"not-a-valid-url\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_validation_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)\n\n    >>> async def test_admin_edit_tool_validation_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_validation_error, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 422 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_validation_error())\n    True\n\n    >>> # Error path: Unexpected exception\n    >>> form_data_unexpected = FormData([\n    ...     (\"name\", \"Crash_Tool\"),\n    ...     (\"customName\", \"Crash_Tool\"),\n    ...     (\"url\", \"http://crash.com\"),\n    ...     (\"requestType\", \"GET\"),\n    ...     (\"integrationType\", \"REST\")\n    ... ])\n    >>> mock_request_unexpected = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_unexpected.form = AsyncMock(return_value=form_data_unexpected)\n    >>> tool_service.update_tool = AsyncMock(side_effect=Exception(\"Unexpected server crash\"))\n\n    >>> async def test_admin_edit_tool_unexpected_error():\n    ...     response = await admin_edit_tool(tool_id, mock_request_unexpected, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and json.loads(response.body.decode())[\"success\"] is False\n\n    >>> asyncio.run(test_admin_edit_tool_unexpected_error())\n    True\n\n    >>> # Restore original method\n    >>> tool_service.update_tool = original_update_tool",
        "operationId": "admin_edit_tool_admin_tools__tool_id__edit__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/{tool_id}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Tool",
        "description": "Delete a tool via the admin UI.\n\nThis endpoint permanently removes a tool from the database using its ID.\nIt is irreversible and should be used with caution. The operation is logged,\nand the user must be authenticated to access this route.\n\nArgs:\n    tool_id (str): The ID of the tool to delete.\n    request (Request): FastAPI request object (not used directly, but required by route signature).\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect response to the tools section of the admin\n    dashboard with a status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> tool_id = \"tool-to-delete\"\n    >>>\n    >>> # Happy path: Delete tool\n    >>> form_data_delete = FormData([(\"is_inactive_checked\", \"false\")])\n    >>> mock_request_delete = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_delete.form = AsyncMock(return_value=form_data_delete)\n    >>> original_delete_tool = tool_service.delete_tool\n    >>> tool_service.delete_tool = AsyncMock()\n    >>>\n    >>> async def test_admin_delete_tool_success():\n    ...     result = await admin_delete_tool(tool_id, mock_request_delete, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin#tools\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_tool_success())\n    True\n    >>>\n    >>> # Edge case: Delete with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"is_inactive_checked\", \"true\")])\n    >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_delete_tool_inactive_checked():\n    ...     result = await admin_delete_tool(tool_id, mock_request_inactive, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/api/admin/?include_inactive=true#tools\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_tool_inactive_checked())\n    True\n    >>>\n    >>> # Error path: Simulate an exception during deletion\n    >>> form_data_error = FormData([])\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> tool_service.delete_tool = AsyncMock(side_effect=Exception(\"Deletion failed\"))\n    >>>\n    >>> async def test_admin_delete_tool_exception():\n    ...     result = await admin_delete_tool(tool_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"#tools\" in result.headers[\"location\"] and \"error=\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_tool_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> tool_service.delete_tool = original_delete_tool",
        "operationId": "admin_delete_tool_admin_tools__tool_id__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/{tool_id}/toggle": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Toggle Tool",
        "description": "Toggle a tool's active status via the admin UI.\n\nThis endpoint processes a form request to activate or deactivate a tool.\nIt expects a form field 'activate' with value \"true\" to activate the tool\nor \"false\" to deactivate it. The endpoint handles exceptions gracefully and\nlogs any errors that might occur during the status toggle operation.\n\nArgs:\n    tool_id (str): The ID of the tool whose status to toggle.\n    request (Request): FastAPI request containing form data with the 'activate' field.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect to the admin dashboard tools section with a\n    status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> tool_id = \"tool-to-toggle\"\n    >>>\n    >>> # Happy path: Activate tool\n    >>> form_data_activate = FormData([(\"activate\", \"true\"), (\"is_inactive_checked\", \"false\")])\n    >>> mock_request_activate = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_activate.form = AsyncMock(return_value=form_data_activate)\n    >>> original_toggle_tool_status = tool_service.toggle_tool_status\n    >>> tool_service.toggle_tool_status = AsyncMock()\n    >>>\n    >>> async def test_admin_toggle_tool_activate():\n    ...     result = await admin_toggle_tool(tool_id, mock_request_activate, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin#tools\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_tool_activate())\n    True\n    >>>\n    >>> # Happy path: Deactivate tool\n    >>> form_data_deactivate = FormData([(\"activate\", \"false\"), (\"is_inactive_checked\", \"false\")])\n    >>> mock_request_deactivate = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_deactivate.form = AsyncMock(return_value=form_data_deactivate)\n    >>>\n    >>> async def test_admin_toggle_tool_deactivate():\n    ...     result = await admin_toggle_tool(tool_id, mock_request_deactivate, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/api/admin#tools\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_tool_deactivate())\n    True\n    >>>\n    >>> # Edge case: Toggle with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"activate\", \"true\"), (\"is_inactive_checked\", \"true\")])\n    >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_toggle_tool_inactive_checked():\n    ...     result = await admin_toggle_tool(tool_id, mock_request_inactive, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin/?include_inactive=true#tools\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_tool_inactive_checked())\n    True\n    >>>\n    >>> # Error path: Simulate an exception during toggle\n    >>> form_data_error = FormData([(\"activate\", \"true\")])\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> tool_service.toggle_tool_status = AsyncMock(side_effect=Exception(\"Toggle failed\"))\n    >>>\n    >>> async def test_admin_toggle_tool_exception():\n    ...     result = await admin_toggle_tool(tool_id, mock_request_error, mock_db, mock_user)\n    ...     location_header = result.headers[\"location\"]\n    ...     return (\n    ...         isinstance(result, RedirectResponse)\n    ...         and result.status_code == 303\n    ...         and \"/admin\" in location_header  # Ensure '/admin' is in the URL\n    ...         and \"error=\" in location_header  # Ensure error query param is present\n    ...         and location_header.endswith(\"#tools\")  # Ensure fragment is correct\n    ...     )\n    >>>\n    >>> asyncio.run(test_admin_toggle_tool_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> tool_service.toggle_tool_status = original_toggle_tool_status",
        "operationId": "admin_toggle_tool_admin_tools__tool_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "tool_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Tool Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/gateways/{gateway_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Gateway",
        "description": "Get gateway details for the admin UI.\n\nArgs:\n    gateway_id: Gateway ID.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Gateway details.\n\nRaises:\n    HTTPException: If the gateway is not found.\n    Exception: For any other unexpected errors.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import GatewayRead\n    >>> from datetime import datetime, timezone\n    >>> from mcpgateway.services.gateway_service import GatewayNotFoundError # Added import\n    >>> from fastapi import HTTPException\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> gateway_id = \"test-gateway-id\"\n    >>>\n    >>> # Mock gateway data\n    >>> mock_gateway = GatewayRead(\n    ...     id=gateway_id, name=\"Get Gateway\", url=\"http://get.com\",\n    ...     description=\"Gateway for getting\", transport=\"HTTP\",\n    ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),\n    ...     enabled=True, auth_type=None, auth_username=None, auth_password=None,\n    ...     auth_token=None, auth_header_key=None, auth_header_value=None,\n    ...     slug=\"test-gateway\"\n    ... )\n    >>>\n    >>> # Mock the gateway_service.get_gateway method\n    >>> original_get_gateway = gateway_service.get_gateway\n    >>> gateway_service.get_gateway = AsyncMock(return_value=mock_gateway)\n    >>>\n    >>> # Test successful retrieval\n    >>> async def test_admin_get_gateway_success():\n    ...     result = await admin_get_gateway(gateway_id, mock_db, mock_user)\n    ...     return isinstance(result, dict) and result['id'] == gateway_id\n    >>>\n    >>> asyncio.run(test_admin_get_gateway_success())\n    True\n    >>>\n    >>> # Test gateway not found\n    >>> gateway_service.get_gateway = AsyncMock(side_effect=GatewayNotFoundError(\"Gateway not found\"))\n    >>> async def test_admin_get_gateway_not_found():\n    ...     try:\n    ...         await admin_get_gateway(\"nonexistent\", mock_db, mock_user)\n    ...         return False\n    ...     except HTTPException as e:\n    ...         return e.status_code == 404 and \"Gateway not found\" in e.detail\n    >>>\n    >>> asyncio.run(test_admin_get_gateway_not_found())\n    True\n    >>>\n    >>> # Test generic exception\n    >>> gateway_service.get_gateway = AsyncMock(side_effect=Exception(\"Generic error\"))\n    >>> async def test_admin_get_gateway_exception():\n    ...     try:\n    ...         await admin_get_gateway(gateway_id, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Generic error\"\n    >>>\n    >>> asyncio.run(test_admin_get_gateway_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> gateway_service.get_gateway = original_get_gateway",
        "operationId": "admin_get_gateway_admin_gateways__gateway_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GatewayRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/gateways/{gateway_id}/edit": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Edit Gateway",
        "description": "Edit a gateway via the admin UI.\n\nExpects form fields:\n  - name\n  - url\n  - description (optional)\n  - tags (optional, comma-separated)\n\nArgs:\n    gateway_id: Gateway ID.\n    request: FastAPI request containing form data.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    A redirect response to the admin dashboard.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>> from pydantic import ValidationError\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> gateway_id = \"gateway-to-edit\"\n    >>>\n    >>> # Happy path: Edit gateway successfully\n    >>> form_data_success = FormData([\n    ...  (\"name\", \"Updated Gateway\"),\n    ...  (\"url\", \"http://updated.com\"),\n    ...  (\"is_inactive_checked\", \"false\"),\n    ...  (\"auth_type\", \"basic\"),\n    ...  (\"auth_username\", \"user\"),\n    ...  (\"auth_password\", \"pass\")\n    ... ])\n    >>> mock_request_success = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_success.form = AsyncMock(return_value=form_data_success)\n    >>> original_update_gateway = gateway_service.update_gateway\n    >>> gateway_service.update_gateway = AsyncMock()\n    >>>\n    >>> async def test_admin_edit_gateway_success():\n    ...     response = await admin_edit_gateway(gateway_id, mock_request_success, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and json.loads(response.body)[\"success\"] is True\n    >>>\n    >>> asyncio.run(test_admin_edit_gateway_success())\n    True\n    >>>\n    # >>> # Edge case: Edit gateway with inactive checkbox checked\n    # >>> form_data_inactive = FormData([(\"name\", \"Inactive Edit\"), (\"url\", \"http://inactive.com\"), (\"is_inactive_checked\", \"true\"), (\"auth_type\", \"basic\"), (\"auth_username\", \"user\"),\n    # ...     (\"auth_password\", \"pass\")]) # Added auth_type\n    # >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    # >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n    # >>>\n    # >>> async def test_admin_edit_gateway_inactive_checked():\n    # ...     response = await admin_edit_gateway(gateway_id, mock_request_inactive, mock_db, mock_user)\n    # ...     return isinstance(response, RedirectResponse) and response.status_code == 303 and \"/api/admin/?include_inactive=true#gateways\" in response.headers[\"location\"]\n    # >>>\n    # >>> asyncio.run(test_admin_edit_gateway_inactive_checked())\n    # True\n    # >>>\n    >>> # Error path: Simulate an exception during update\n    >>> form_data_error = FormData([(\"name\", \"Error Gateway\"), (\"url\", \"http://error.com\"), (\"auth_type\", \"basic\"),(\"auth_username\", \"user\"),\n    ...     (\"auth_password\", \"pass\")]) # Added auth_type\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> gateway_service.update_gateway = AsyncMock(side_effect=Exception(\"Update failed\"))\n    >>>\n    >>> async def test_admin_edit_gateway_exception():\n    ...     response = await admin_edit_gateway(gateway_id, mock_request_error, mock_db, mock_user)\n    ...     return (\n    ...         isinstance(response, JSONResponse)\n    ...         and response.status_code == 500\n    ...         and json.loads(response.body)[\"success\"] is False\n    ...         and \"Update failed\" in json.loads(response.body)[\"message\"]\n    ...     )\n    >>>\n    >>> asyncio.run(test_admin_edit_gateway_exception())\n    True\n    >>>\n    >>> # Error path: Pydantic Validation Error (e.g., invalid URL format)\n    >>> form_data_validation_error = FormData([(\"name\", \"Bad URL Gateway\"), (\"url\", \"invalid-url\"), (\"auth_type\", \"basic\"),(\"auth_username\", \"user\"),\n    ...     (\"auth_password\", \"pass\")]) # Added auth_type\n    >>> mock_request_validation_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_validation_error.form = AsyncMock(return_value=form_data_validation_error)\n    >>>\n    >>> async def test_admin_edit_gateway_validation_error():\n    ...     response = await admin_edit_gateway(gateway_id, mock_request_validation_error, mock_db, mock_user)\n    ...     body = json.loads(response.body.decode())\n    ...     return isinstance(response, JSONResponse) and response.status_code in (422,400) and body[\"success\"] is False\n    >>>\n    >>> asyncio.run(test_admin_edit_gateway_validation_error())\n    True\n    >>>\n    >>> # Restore original method\n    >>> gateway_service.update_gateway = original_update_gateway",
        "operationId": "admin_edit_gateway_admin_gateways__gateway_id__edit_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/gateways/{gateway_id}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Gateway",
        "description": "Delete a gateway via the admin UI.\n\nThis endpoint removes a gateway from the database by its ID. The deletion is\npermanent and cannot be undone. It requires authentication and logs the\noperation for auditing purposes.\n\nArgs:\n    gateway_id (str): The ID of the gateway to delete.\n    request (Request): FastAPI request object (not used directly but required by the route signature).\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect response to the gateways section of the admin\n    dashboard with a status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> gateway_id = \"gateway-to-delete\"\n    >>>\n    >>> # Happy path: Delete gateway\n    >>> form_data_delete = FormData([(\"is_inactive_checked\", \"false\")])\n    >>> mock_request_delete = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_delete.form = AsyncMock(return_value=form_data_delete)\n    >>> original_delete_gateway = gateway_service.delete_gateway\n    >>> gateway_service.delete_gateway = AsyncMock()\n    >>>\n    >>> async def test_admin_delete_gateway_success():\n    ...     result = await admin_delete_gateway(gateway_id, mock_request_delete, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/admin#gateways\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_gateway_success())\n    True\n    >>>\n    >>> # Edge case: Delete with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"is_inactive_checked\", \"true\")])\n    >>> mock_request_inactive = MagicMock(spec=Request, scope={\"root_path\": \"/api\"})\n    >>> mock_request_inactive.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_delete_gateway_inactive_checked():\n    ...     result = await admin_delete_gateway(gateway_id, mock_request_inactive, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"/api/admin/?include_inactive=true#gateways\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_gateway_inactive_checked())\n    True\n    >>>\n    >>> # Error path: Simulate an exception during deletion\n    >>> form_data_error = FormData([])\n    >>> mock_request_error = MagicMock(spec=Request, scope={\"root_path\": \"\"})\n    >>> mock_request_error.form = AsyncMock(return_value=form_data_error)\n    >>> gateway_service.delete_gateway = AsyncMock(side_effect=Exception(\"Deletion failed\"))\n    >>>\n    >>> async def test_admin_delete_gateway_exception():\n    ...     result = await admin_delete_gateway(gateway_id, mock_request_error, mock_db, mock_user)\n    ...     return isinstance(result, RedirectResponse) and result.status_code == 303 and \"#gateways\" in result.headers[\"location\"] and \"error=\" in result.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_gateway_exception())\n    True\n    >>>\n    >>> # Restore original method\n    >>> gateway_service.delete_gateway = original_delete_gateway",
        "operationId": "admin_delete_gateway_admin_gateways__gateway_id__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "gateway_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Gateway Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/resources/{resource_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Resource",
        "description": "Get resource details for the admin UI.\n\nArgs:\n    resource_id: Resource ID.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    A dictionary containing resource details and its content.\n\nRaises:\n    HTTPException: If the resource is not found.\n    Exception: For any other unexpected errors.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import ResourceRead, ResourceMetrics, ResourceContent\n    >>> from datetime import datetime, timezone\n    >>> from mcpgateway.services.resource_service import ResourceNotFoundError # Added import\n    >>> from fastapi import HTTPException\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> resource_uri = \"test://resource/get\"\n    >>> resource_id = 1\n    >>>\n    >>> # Mock resource data\n    >>> mock_resource = ResourceRead(\n    ...     id=resource_id, uri=resource_uri, name=\"Get Resource\", description=\"Test\",\n    ...     mime_type=\"text/plain\", size=10, created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc), is_active=True, metrics=ResourceMetrics(\n    ...         total_executions=0, successful_executions=0, failed_executions=0,\n    ...         failure_rate=0.0, min_response_time=0.0, max_response_time=0.0, avg_response_time=0.0,\n    ...         last_execution_time=None\n    ...     ),\n    ...     tags=[]\n    ... )\n    >>> mock_content = ResourceContent(id=str(resource_id), type=\"resource\", uri=resource_uri, mime_type=\"text/plain\", text=\"Hello content\")\n    >>>\n    >>> # Mock service methods\n    >>> original_get_resource_by_id = resource_service.get_resource_by_id\n    >>> original_read_resource = resource_service.read_resource\n    >>> resource_service.get_resource_by_id = AsyncMock(return_value=mock_resource)\n    >>> resource_service.read_resource = AsyncMock(return_value=mock_content)\n    >>>\n    >>> # Test successful retrieval\n    >>> async def test_admin_get_resource_success():\n    ...     result = await admin_get_resource(resource_id, mock_db, mock_user)\n    ...     return isinstance(result, dict) and result['resource']['id'] == resource_id and result['content'].text == \"Hello content\" # Corrected to .text\n    >>>\n    >>> asyncio.run(test_admin_get_resource_success())\n    True\n    >>>\n    >>> # Test resource not found\n    >>> resource_service.get_resource_by_id = AsyncMock(side_effect=ResourceNotFoundError(\"Resource not found\"))\n    >>> async def test_admin_get_resource_not_found():\n    ...     try:\n    ...         await admin_get_resource(999, mock_db, mock_user)\n    ...         return False\n    ...     except HTTPException as e:\n    ...         return e.status_code == 404 and \"Resource not found\" in e.detail\n    >>>\n    >>> asyncio.run(test_admin_get_resource_not_found())\n    True\n    >>>\n    >>> # Test exception during content read (resource found but content fails)\n    >>> resource_service.get_resource_by_id = AsyncMock(return_value=mock_resource) # Resource found\n    >>> resource_service.read_resource = AsyncMock(side_effect=Exception(\"Content read error\"))\n    >>> async def test_admin_get_resource_content_error():\n    ...     try:\n    ...         await admin_get_resource(resource_id, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Content read error\"\n    >>>\n    >>> asyncio.run(test_admin_get_resource_content_error())\n    True\n    >>>\n    >>> # Restore original methods\n    >>> resource_service.get_resource_by_id = original_get_resource_by_id\n    >>> resource_service.read_resource = original_read_resource",
        "operationId": "admin_get_resource_admin_resources__resource_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Admin Get Resource Admin Resources  Resource Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/resources/{resource_id}/edit": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Edit Resource",
        "description": "Edit a resource via the admin UI.\n\nExpects form fields:\n  - name\n  - description (optional)\n  - mime_type (optional)\n  - content\n\nArgs:\n    resource_id: Resource ID.\n    request: FastAPI request containing form data.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    JSONResponse: A JSON response indicating success or failure of the resource update operation.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> form_data = FormData([\n    ...     (\"name\", \"Updated Resource\"),\n    ...     (\"description\", \"Updated description\"),\n    ...     (\"mimeType\", \"text/plain\"),\n    ...     (\"content\", \"Updated content\"),\n    ... ])\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_update_resource = resource_service.update_resource\n    >>> resource_service.update_resource = AsyncMock()\n    >>>\n    >>> # Test successful update\n    >>> async def test_admin_edit_resource():\n    ...     response = await admin_edit_resource(\"test://resource1\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body == b'{\"message\":\"Resource updated successfully!\",\"success\":true}'\n    >>>\n    >>> asyncio.run(test_admin_edit_resource())\n    True\n    >>>\n    >>> # Test validation error\n    >>> from pydantic import ValidationError\n    >>> validation_error = ValidationError.from_exception_data(\"Resource validation error\", [\n    ...     {\"loc\": (\"name\",), \"msg\": \"Field required\", \"type\": \"missing\"}\n    ... ])\n    >>> resource_service.update_resource = AsyncMock(side_effect=validation_error)\n    >>> async def test_admin_edit_resource_validation():\n    ...     response = await admin_edit_resource(\"test://resource1\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 422\n    >>>\n    >>> asyncio.run(test_admin_edit_resource_validation())\n    True\n    >>>\n    >>> # Test integrity error (e.g., duplicate resource)\n    >>> from sqlalchemy.exc import IntegrityError\n    >>> integrity_error = IntegrityError(\"Duplicate entry\", None, None)\n    >>> resource_service.update_resource = AsyncMock(side_effect=integrity_error)\n    >>> async def test_admin_edit_resource_integrity():\n    ...     response = await admin_edit_resource(\"test://resource1\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 409\n    >>>\n    >>> asyncio.run(test_admin_edit_resource_integrity())\n    True\n    >>>\n    >>> # Test unknown error\n    >>> resource_service.update_resource = AsyncMock(side_effect=Exception(\"Unknown error\"))\n    >>> async def test_admin_edit_resource_unknown():\n    ...     response = await admin_edit_resource(\"test://resource1\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 500 and b'Unknown error' in response.body\n    >>>\n    >>> asyncio.run(test_admin_edit_resource_unknown())\n    True\n    >>>\n    >>> # Reset mock\n    >>> resource_service.update_resource = original_update_resource",
        "operationId": "admin_edit_resource_admin_resources__resource_id__edit_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/resources/{resource_id}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Resource",
        "description": "Delete a resource via the admin UI.\n\nThis endpoint permanently removes a resource from the database using its resource ID.\nThe operation is irreversible and should be used with caution. It requires\nuser authentication and logs the deletion attempt.\n\nArgs:\n    resource_id (str): The ID of the resource to delete.\n    request (Request): FastAPI request object (not used directly but required by the route signature).\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect response to the resources section of the admin\n    dashboard with a status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> mock_request = MagicMock(spec=Request)\n    >>> form_data = FormData([(\"is_inactive_checked\", \"false\")])\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_delete_resource = resource_service.delete_resource\n    >>> resource_service.delete_resource = AsyncMock()\n    >>>\n    >>> async def test_admin_delete_resource():\n    ...     response = await admin_delete_resource(\"test://resource1\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> import asyncio; asyncio.run(test_admin_delete_resource())\n    True\n    >>>\n    >>> # Test with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"is_inactive_checked\", \"true\")])\n    >>> mock_request.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_delete_resource_inactive():\n    ...     response = await admin_delete_resource(\"test://resource1\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and \"include_inactive=true\" in response.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_resource_inactive())\n    True\n    >>> resource_service.delete_resource = original_delete_resource",
        "operationId": "admin_delete_resource_admin_resources__resource_id__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/resources/{resource_id}/toggle": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Toggle Resource",
        "description": "Toggle a resource's active status via the admin UI.\n\nThis endpoint processes a form request to activate or deactivate a resource.\nIt expects a form field 'activate' with value \"true\" to activate the resource\nor \"false\" to deactivate it. The endpoint handles exceptions gracefully and\nlogs any errors that might occur during the status toggle operation.\n\nArgs:\n    resource_id (int): The ID of the resource whose status to toggle.\n    request (Request): FastAPI request containing form data with the 'activate' field.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect to the admin dashboard resources section with a\n    status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> mock_request = MagicMock(spec=Request)\n    >>> form_data = FormData([\n    ...     (\"activate\", \"true\"),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_toggle_resource_status = resource_service.toggle_resource_status\n    >>> resource_service.toggle_resource_status = AsyncMock()\n    >>>\n    >>> async def test_admin_toggle_resource():\n    ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_toggle_resource())\n    True\n    >>>\n    >>> # Test with activate=false\n    >>> form_data_deactivate = FormData([\n    ...     (\"activate\", \"false\"),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_deactivate)\n    >>>\n    >>> async def test_admin_toggle_resource_deactivate():\n    ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_toggle_resource_deactivate())\n    True\n    >>>\n    >>> # Test with inactive checkbox checked\n    >>> form_data_inactive = FormData([\n    ...     (\"activate\", \"true\"),\n    ...     (\"is_inactive_checked\", \"true\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_toggle_resource_inactive():\n    ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and \"include_inactive=true\" in response.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_resource_inactive())\n    True\n    >>>\n    >>> # Test exception handling\n    >>> resource_service.toggle_resource_status = AsyncMock(side_effect=Exception(\"Test error\"))\n    >>> form_data_error = FormData([\n    ...     (\"activate\", \"true\"),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_error)\n    >>>\n    >>> async def test_admin_toggle_resource_exception():\n    ...     response = await admin_toggle_resource(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_toggle_resource_exception())\n    True\n    >>> resource_service.toggle_resource_status = original_toggle_resource_status",
        "operationId": "admin_toggle_resource_admin_resources__resource_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "resource_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Resource Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/prompts/{prompt_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Prompt",
        "description": "Get prompt details for the admin UI.\n\nArgs:\n    prompt_id: Prompt ID.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    A dictionary with prompt details.\n\nRaises:\n    HTTPException: If the prompt is not found.\n    Exception: For any other unexpected errors.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import PromptRead, PromptMetrics\n    >>> from datetime import datetime, timezone\n    >>> from mcpgateway.services.prompt_service import PromptNotFoundError # Added import\n    >>> from fastapi import HTTPException\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> prompt_name = \"test-prompt\"\n    >>>\n    >>> # Mock prompt details\n    >>> mock_metrics = PromptMetrics(\n    ...     total_executions=3,\n    ...     successful_executions=3,\n    ...     failed_executions=0,\n    ...     failure_rate=0.0,\n    ...     min_response_time=0.1,\n    ...     max_response_time=0.5,\n    ...     avg_response_time=0.3,\n    ...     last_execution_time=datetime.now(timezone.utc)\n    ... )\n    >>> mock_prompt_details = {\n    ...     \"id\": 1,\n    ...     \"name\": prompt_name,\n    ...     \"description\": \"A test prompt\",\n    ...     \"template\": \"Hello {{name}}!\",\n    ...     \"arguments\": [{\"name\": \"name\", \"type\": \"string\"}],\n    ...     \"created_at\": datetime.now(timezone.utc),\n    ...     \"updated_at\": datetime.now(timezone.utc),\n    ...     \"is_active\": True,\n    ...     \"metrics\": mock_metrics,\n    ...     \"tags\": []\n    ... }\n    >>>\n    >>> original_get_prompt_details = prompt_service.get_prompt_details\n    >>> prompt_service.get_prompt_details = AsyncMock(return_value=mock_prompt_details)\n    >>>\n    >>> async def test_admin_get_prompt():\n    ...     result = await admin_get_prompt(prompt_name, mock_db, mock_user)\n    ...     return isinstance(result, dict) and result.get(\"name\") == prompt_name\n    >>>\n    >>> asyncio.run(test_admin_get_prompt())\n    True\n    >>>\n    >>> # Test prompt not found\n    >>> prompt_service.get_prompt_details = AsyncMock(side_effect=PromptNotFoundError(\"Prompt not found\"))\n    >>> async def test_admin_get_prompt_not_found():\n    ...     try:\n    ...         await admin_get_prompt(\"nonexistent\", mock_db, mock_user)\n    ...         return False\n    ...     except HTTPException as e:\n    ...         return e.status_code == 404 and \"Prompt not found\" in e.detail\n    >>>\n    >>> asyncio.run(test_admin_get_prompt_not_found())\n    True\n    >>>\n    >>> # Test generic exception\n    >>> prompt_service.get_prompt_details = AsyncMock(side_effect=Exception(\"Generic error\"))\n    >>> async def test_admin_get_prompt_exception():\n    ...     try:\n    ...         await admin_get_prompt(prompt_name, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Generic error\"\n    >>>\n    >>> asyncio.run(test_admin_get_prompt_exception())\n    True\n    >>>\n    >>> prompt_service.get_prompt_details = original_get_prompt_details",
        "operationId": "admin_get_prompt_admin_prompts__prompt_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Admin Get Prompt Admin Prompts  Prompt Id  Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/prompts/{prompt_id}/edit": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Edit Prompt",
        "description": "Edit a prompt via the admin UI.\n\nExpects form fields:\n    - name\n    - description (optional)\n    - template\n    - arguments (as a JSON string representing a list)\n\nArgs:\n    prompt_id: Prompt ID.\n    request: FastAPI request containing form data.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    JSONResponse: A JSON response indicating success or failure of the server update operation.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from starlette.datastructures import FormData\n    >>> from fastapi.responses import JSONResponse\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> prompt_name = \"test-prompt\"\n    >>> form_data = FormData([\n    ...     (\"name\", \"Updated Prompt\"),\n    ...     (\"description\", \"Updated description\"),\n    ...     (\"template\", \"Hello {{name}}, welcome!\"),\n    ...     (\"arguments\", '[{\"name\": \"name\", \"type\": \"string\"}]'),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>> mock_request = MagicMock(spec=Request)\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_update_prompt = prompt_service.update_prompt\n    >>> prompt_service.update_prompt = AsyncMock()\n    >>>\n    >>> async def test_admin_edit_prompt():\n    ...     response = await admin_edit_prompt(prompt_name, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and response.body == b'{\"message\":\"Prompt updated successfully!\",\"success\":true}'\n    >>>\n    >>> asyncio.run(test_admin_edit_prompt())\n    True\n    >>>\n    >>> # Test with inactive checkbox checked\n    >>> form_data_inactive = FormData([\n    ...     (\"name\", \"Updated Prompt\"),\n    ...     (\"template\", \"Hello {{name}}!\"),\n    ...     (\"arguments\", \"[]\"),\n    ...     (\"is_inactive_checked\", \"true\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_edit_prompt_inactive():\n    ...     response = await admin_edit_prompt(prompt_name, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, JSONResponse) and response.status_code == 200 and b\"Prompt updated successfully!\" in response.body\n    >>>\n    >>> asyncio.run(test_admin_edit_prompt_inactive())\n    True\n    >>> prompt_service.update_prompt = original_update_prompt",
        "operationId": "admin_edit_prompt_admin_prompts__prompt_id__edit_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/prompts/{prompt_id}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Prompt",
        "description": "Delete a prompt via the admin UI.\n\nThis endpoint permanently deletes a prompt from the database using its ID.\nDeletion is irreversible and requires authentication. All actions are logged\nfor administrative auditing.\n\nArgs:\n    prompt_id (str): The ID of the prompt to delete.\n    request (Request): FastAPI request object (not used directly but required by the route signature).\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect response to the prompts section of the admin\n    dashboard with a status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> mock_request = MagicMock(spec=Request)\n    >>> form_data = FormData([(\"is_inactive_checked\", \"false\")])\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_delete_prompt = prompt_service.delete_prompt\n    >>> prompt_service.delete_prompt = AsyncMock()\n    >>>\n    >>> async def test_admin_delete_prompt():\n    ...     response = await admin_delete_prompt(\"test-prompt\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_delete_prompt())\n    True\n    >>>\n    >>> # Test with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"is_inactive_checked\", \"true\")])\n    >>> mock_request.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_delete_prompt_inactive():\n    ...     response = await admin_delete_prompt(\"test-prompt\", mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and \"include_inactive=true\" in response.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_prompt_inactive())\n    True\n    >>> prompt_service.delete_prompt = original_delete_prompt",
        "operationId": "admin_delete_prompt_admin_prompts__prompt_id__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/prompts/{prompt_id}/toggle": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Toggle Prompt",
        "description": "Toggle a prompt's active status via the admin UI.\n\nThis endpoint processes a form request to activate or deactivate a prompt.\nIt expects a form field 'activate' with value \"true\" to activate the prompt\nor \"false\" to deactivate it. The endpoint handles exceptions gracefully and\nlogs any errors that might occur during the status toggle operation.\n\nArgs:\n    prompt_id (int): The ID of the prompt whose status to toggle.\n    request (Request): FastAPI request containing form data with the 'activate' field.\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect to the admin dashboard prompts section with a\n    status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> mock_request = MagicMock(spec=Request)\n    >>> form_data = FormData([\n    ...     (\"activate\", \"true\"),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_toggle_prompt_status = prompt_service.toggle_prompt_status\n    >>> prompt_service.toggle_prompt_status = AsyncMock()\n    >>>\n    >>> async def test_admin_toggle_prompt():\n    ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_toggle_prompt())\n    True\n    >>>\n    >>> # Test with activate=false\n    >>> form_data_deactivate = FormData([\n    ...     (\"activate\", \"false\"),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_deactivate)\n    >>>\n    >>> async def test_admin_toggle_prompt_deactivate():\n    ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_toggle_prompt_deactivate())\n    True\n    >>>\n    >>> # Test with inactive checkbox checked\n    >>> form_data_inactive = FormData([\n    ...     (\"activate\", \"true\"),\n    ...     (\"is_inactive_checked\", \"true\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_toggle_prompt_inactive():\n    ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and \"include_inactive=true\" in response.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_toggle_prompt_inactive())\n    True\n    >>>\n    >>> # Test exception handling\n    >>> prompt_service.toggle_prompt_status = AsyncMock(side_effect=Exception(\"Test error\"))\n    >>> form_data_error = FormData([\n    ...     (\"activate\", \"true\"),\n    ...     (\"is_inactive_checked\", \"false\")\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data_error)\n    >>>\n    >>> async def test_admin_toggle_prompt_exception():\n    ...     response = await admin_toggle_prompt(1, mock_request, mock_db, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_toggle_prompt_exception())\n    True\n    >>> prompt_service.toggle_prompt_status = original_toggle_prompt_status",
        "operationId": "admin_toggle_prompt_admin_prompts__prompt_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "prompt_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "integer",
              "title": "Prompt Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/roots": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add Root",
        "description": "Add a new root via the admin UI.\n\nExpects form fields:\n  - path\n  - name (optional)\n\nArgs:\n    request: FastAPI request containing form data.\n    user: Authenticated user.\n\nReturns:\n    RedirectResponse: A redirect response to the admin dashboard.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> mock_request = MagicMock(spec=Request)\n    >>> form_data = FormData([\n    ...     (\"uri\", \"test://root1\"),\n    ...     (\"name\", \"Test Root\"),\n    ... ])\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_add_root = root_service.add_root\n    >>> root_service.add_root = AsyncMock()\n    >>>\n    >>> async def test_admin_add_root():\n    ...     response = await admin_add_root(mock_request, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_add_root())\n    True\n    >>> root_service.add_root = original_add_root",
        "operationId": "admin_add_root_admin_roots_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/roots/{uri}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Root",
        "description": "Delete a root via the admin UI.\n\nThis endpoint removes a registered root URI from the system. The deletion is\npermanent and cannot be undone. It requires authentication and logs the\noperation for audit purposes.\n\nArgs:\n    uri (str): The URI of the root to delete.\n    request (Request): FastAPI request object (not used directly but required by the route signature).\n    user (str): Authenticated user dependency.\n\nReturns:\n    RedirectResponse: A redirect response to the roots section of the admin\n    dashboard with a status code of 303 (See Other).\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from fastapi import Request\n    >>> from fastapi.responses import RedirectResponse\n    >>> from starlette.datastructures import FormData\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> mock_request = MagicMock(spec=Request)\n    >>> form_data = FormData([(\"is_inactive_checked\", \"false\")])\n    >>> mock_request.form = AsyncMock(return_value=form_data)\n    >>> mock_request.scope = {\"root_path\": \"\"}\n    >>>\n    >>> original_remove_root = root_service.remove_root\n    >>> root_service.remove_root = AsyncMock()\n    >>>\n    >>> async def test_admin_delete_root():\n    ...     response = await admin_delete_root(\"test://root1\", mock_request, mock_user)\n    ...     return isinstance(response, RedirectResponse) and response.status_code == 303\n    >>>\n    >>> asyncio.run(test_admin_delete_root())\n    True\n    >>>\n    >>> # Test with inactive checkbox checked\n    >>> form_data_inactive = FormData([(\"is_inactive_checked\", \"true\")])\n    >>> mock_request.form = AsyncMock(return_value=form_data_inactive)\n    >>>\n    >>> async def test_admin_delete_root_inactive():\n    ...     response = await admin_delete_root(\"test://root1\", mock_request, mock_user)\n    ...     return isinstance(response, RedirectResponse) and \"include_inactive=true\" in response.headers[\"location\"]\n    >>>\n    >>> asyncio.run(test_admin_delete_root_inactive())\n    True\n    >>> root_service.remove_root = original_remove_root",
        "operationId": "admin_delete_root_admin_roots__uri__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "uri",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Uri"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/metrics": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Aggregated Metrics",
        "description": "Retrieve aggregated metrics and top performers for all entity types.\n\nThis endpoint collects usage metrics and top-performing entities for tools,\nresources, prompts, and servers by calling the respective service methods.\nThe results are compiled into a dictionary for administrative monitoring.\n\nArgs:\n    db (Session): Database session dependency for querying metrics.\n\nReturns:\n    Dict[str, Any]: A dictionary containing aggregated metrics and top performers\n        for tools, resources, prompts, and servers. The structure includes:\n        - 'tools': Metrics for tools.\n        - 'resources': Metrics for resources.\n        - 'prompts': Metrics for prompts.\n        - 'servers': Metrics for servers.\n        - 'topPerformers': A nested dictionary with all tools, resources, prompts,\n          and servers with their metrics.",
        "operationId": "get_aggregated_metrics_admin_metrics_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Get Aggregated Metrics Admin Metrics Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/metrics/reset": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Reset Metrics",
        "description": "Reset all metrics for tools, resources, servers, and prompts.\nEach service must implement its own reset_metrics method.\n\nArgs:\n    db (Session): Database session dependency.\n    user (str): Authenticated user dependency.\n\nReturns:\n    Dict[str, object]: A dictionary containing a success message and status.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>>\n    >>> original_reset_metrics_tool = tool_service.reset_metrics\n    >>> original_reset_metrics_resource = resource_service.reset_metrics\n    >>> original_reset_metrics_server = server_service.reset_metrics\n    >>> original_reset_metrics_prompt = prompt_service.reset_metrics\n    >>>\n    >>> tool_service.reset_metrics = AsyncMock()\n    >>> resource_service.reset_metrics = AsyncMock()\n    >>> server_service.reset_metrics = AsyncMock()\n    >>> prompt_service.reset_metrics = AsyncMock()\n    >>>\n    >>> async def test_admin_reset_metrics():\n    ...     result = await admin_reset_metrics(mock_db, mock_user)\n    ...     return result == {\"message\": \"All metrics reset successfully\", \"success\": True}\n    >>>\n    >>> import asyncio; asyncio.run(test_admin_reset_metrics())\n    True\n    >>>\n    >>> tool_service.reset_metrics = original_reset_metrics_tool\n    >>> resource_service.reset_metrics = original_reset_metrics_resource\n    >>> server_service.reset_metrics = original_reset_metrics_server\n    >>> prompt_service.reset_metrics = original_reset_metrics_prompt",
        "operationId": "admin_reset_metrics_admin_metrics_reset_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Admin Reset Metrics Admin Metrics Reset Post"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/gateways/test": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Test Gateway",
        "description": "Test a gateway by sending a request to its URL.\nThis endpoint allows administrators to test the connectivity and response\n\nArgs:\n    request (GatewayTestRequest): The request object containing the gateway URL and request details.\n    team_id (Optional[str]): Optional team ID for team-specific gateways.\n    user (str): Authenticated user dependency.\n    db (Session): Database session dependency.\n\nReturns:\n    GatewayTestResponse: The response from the gateway, including status code, latency, and body\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import GatewayTestRequest, GatewayTestResponse\n    >>> from fastapi import Request\n    >>> import httpx\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> mock_request = GatewayTestRequest(\n    ...     base_url=\"https://api.example.com\",\n    ...     path=\"/test\",\n    ...     method=\"GET\",\n    ...     headers={},\n    ...     body=None\n    ... )\n    >>>\n    >>> # Mock ResilientHttpClient to simulate a successful response\n    >>> class MockResponse:\n    ...     def __init__(self):\n    ...         self.status_code = 200\n    ...         self._json = {\"message\": \"success\"}\n    ...     def json(self):\n    ...         return self._json\n    ...     @property\n    ...     def text(self):\n    ...         return str(self._json)\n    >>>\n    >>> class MockClient:\n    ...     async def __aenter__(self):\n    ...         return self\n    ...     async def __aexit__(self, exc_type, exc, tb):\n    ...         pass\n    ...     async def request(self, method, url, headers=None, json=None):\n    ...         return MockResponse()\n    >>>\n    >>> from unittest.mock import patch\n    >>>\n    >>> async def test_admin_test_gateway():\n    ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:\n    ...         mock_client_class.return_value = MockClient()\n    ...         response = await admin_test_gateway(mock_request, mock_user)\n    ...         return isinstance(response, GatewayTestResponse) and response.status_code == 200\n    >>>\n    >>> result = asyncio.run(test_admin_test_gateway())\n    >>> result\n    True\n    >>>\n    >>> # Test with JSON decode error\n    >>> class MockResponseTextOnly:\n    ...     def __init__(self):\n    ...         self.status_code = 200\n    ...         self.text = \"plain text response\"\n    ...     def json(self):\n    ...         raise json.JSONDecodeError(\"Invalid JSON\", \"doc\", 0)\n    >>>\n    >>> class MockClientTextOnly:\n    ...     async def __aenter__(self):\n    ...         return self\n    ...     async def __aexit__(self, exc_type, exc, tb):\n    ...         pass\n    ...     async def request(self, method, url, headers=None, json=None):\n    ...         return MockResponseTextOnly()\n    >>>\n    >>> async def test_admin_test_gateway_text_response():\n    ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:\n    ...         mock_client_class.return_value = MockClientTextOnly()\n    ...         response = await admin_test_gateway(mock_request, mock_user)\n    ...         return isinstance(response, GatewayTestResponse) and response.body.get(\"details\") == \"plain text response\"\n    >>>\n    >>> asyncio.run(test_admin_test_gateway_text_response())\n    True\n    >>>\n    >>> # Test with network error\n    >>> class MockClientError:\n    ...     async def __aenter__(self):\n    ...         return self\n    ...     async def __aexit__(self, exc_type, exc, tb):\n    ...         pass\n    ...     async def request(self, method, url, headers=None, json=None):\n    ...         raise httpx.RequestError(\"Network error\")\n    >>>\n    >>> async def test_admin_test_gateway_network_error():\n    ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:\n    ...         mock_client_class.return_value = MockClientError()\n    ...         response = await admin_test_gateway(mock_request, mock_user)\n    ...         return response.status_code == 502 and \"Network error\" in str(response.body)\n    >>>\n    >>> asyncio.run(test_admin_test_gateway_network_error())\n    True\n    >>>\n    >>> # Test with POST method and body\n    >>> mock_request_post = GatewayTestRequest(\n    ...     base_url=\"https://api.example.com\",\n    ...     path=\"/test\",\n    ...     method=\"POST\",\n    ...     headers={\"Content-Type\": \"application/json\"},\n    ...     body={\"test\": \"data\"}\n    ... )\n    >>>\n    >>> async def test_admin_test_gateway_post():\n    ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:\n    ...         mock_client_class.return_value = MockClient()\n    ...         response = await admin_test_gateway(mock_request_post, mock_user)\n    ...         return isinstance(response, GatewayTestResponse) and response.status_code == 200\n    >>>\n    >>> asyncio.run(test_admin_test_gateway_post())\n    True\n    >>>\n    >>> # Test URL path handling with trailing slashes\n    >>> mock_request_trailing = GatewayTestRequest(\n    ...     base_url=\"https://api.example.com/\",\n    ...     path=\"/test/\",\n    ...     method=\"GET\",\n    ...     headers={},\n    ...     body=None\n    ... )\n    >>>\n    >>> async def test_admin_test_gateway_trailing_slash():\n    ...     with patch('mcpgateway.admin.ResilientHttpClient') as mock_client_class:\n    ...         mock_client_class.return_value = MockClient()\n    ...         response = await admin_test_gateway(mock_request_trailing, mock_user)\n    ...         return isinstance(response, GatewayTestResponse) and response.status_code == 200\n    >>>\n    >>> asyncio.run(test_admin_test_gateway_trailing_slash())\n    True",
        "operationId": "admin_test_gateway_admin_gateways_test_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GatewayTestRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GatewayTestResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tags": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Tags",
        "description": "List all unique tags with statistics for the admin UI.\n\nArgs:\n    entity_types: Comma-separated list of entity types to filter by\n                 (e.g., \"tools,resources,prompts,servers,gateways\").\n                 If not provided, returns tags from all entity types.\n    include_entities: Whether to include the list of entities that have each tag\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    List of tag information with statistics\n\nRaises:\n    HTTPException: If tag retrieval fails\n\nExamples:\n    >>> # Test function exists and has correct name\n    >>> from mcpgateway.admin import admin_list_tags\n    >>> admin_list_tags.__name__\n    'admin_list_tags'\n    >>> # Test it's a coroutine function\n    >>> import inspect\n    >>> inspect.iscoroutinefunction(admin_list_tags)\n    True",
        "operationId": "admin_list_tags_admin_tags_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entity_types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Types"
            }
          },
          {
            "name": "include_entities",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Entities"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": true
                  },
                  "title": "Response Admin List Tags Admin Tags Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/import": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Import Tools",
        "description": "Bulk import multiple tools in a single request.\n\nAccepts a JSON array of tool definitions and registers them individually.\nProvides per-item validation and error reporting without failing the entire batch.\n\nArgs:\n    request: FastAPI Request containing the tools data\n    db: Database session\n    user: Authenticated username\n\nReturns:\n    JSONResponse with success status, counts, and details of created/failed tools\n\nRaises:\n    HTTPException: For authentication or rate limiting failures",
        "operationId": "admin_import_tools_admin_tools_import_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/tools/import/": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Import Tools",
        "description": "Bulk import multiple tools in a single request.\n\nAccepts a JSON array of tool definitions and registers them individually.\nProvides per-item validation and error reporting without failing the entire batch.\n\nArgs:\n    request: FastAPI Request containing the tools data\n    db: Database session\n    user: Authenticated username\n\nReturns:\n    JSONResponse with success status, counts, and details of created/failed tools\n\nRaises:\n    HTTPException: For authentication or rate limiting failures",
        "operationId": "admin_import_tools_admin_tools_import__post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/logs": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Logs",
        "description": "Get filtered log entries from the in-memory buffer.\n\nArgs:\n    entity_type: Filter by entity type (tool, resource, server, gateway)\n    entity_id: Filter by entity ID\n    level: Minimum log level (debug, info, warning, error, critical)\n    start_time: ISO format start time\n    end_time: ISO format end time\n    request_id: Filter by request ID\n    search: Search in message text\n    limit: Maximum number of results (default 100, max 1000)\n    offset: Number of results to skip\n    order: Sort order (asc or desc)\n    user: Authenticated user\n\nReturns:\n    Dictionary with logs and metadata\n\nRaises:\n    HTTPException: If validation fails or service unavailable",
        "operationId": "admin_get_logs_admin_logs_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entity_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Type"
            }
          },
          {
            "name": "entity_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Id"
            }
          },
          {
            "name": "level",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Level"
            }
          },
          {
            "name": "start_time",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Start Time"
            }
          },
          {
            "name": "end_time",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Time"
            }
          },
          {
            "name": "request_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Request Id"
            }
          },
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Search"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 100,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          },
          {
            "name": "order",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": "desc",
              "title": "Order"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": true,
                  "title": "Response Admin Get Logs Admin Logs Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/logs/stream": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Stream Logs",
        "description": "Stream real-time log updates via Server-Sent Events.\n\nArgs:\n    request: FastAPI request object\n    entity_type: Filter by entity type\n    entity_id: Filter by entity ID\n    level: Minimum log level\n    user: Authenticated user\n\nReturns:\n    SSE response with real-time log updates\n\nRaises:\n    HTTPException: If log level is invalid or service unavailable",
        "operationId": "admin_stream_logs_admin_logs_stream_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "entity_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Type"
            }
          },
          {
            "name": "entity_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Id"
            }
          },
          {
            "name": "level",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Level"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/logs/file": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Log File",
        "description": "Download log file.\n\nArgs:\n    filename: Specific log file to download (optional)\n    user: Authenticated user\n\nReturns:\n    File download response or list of available files\n\nRaises:\n    HTTPException: If file doesn't exist or access denied",
        "operationId": "admin_get_log_file_admin_logs_file_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "filename",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Filename"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/logs/export": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Export Logs",
        "description": "Export filtered logs in JSON or CSV format.\n\nArgs:\n    export_format: Export format (json or csv)\n    entity_type: Filter by entity type\n    entity_id: Filter by entity ID\n    level: Minimum log level\n    start_time: ISO format start time\n    end_time: ISO format end time\n    request_id: Filter by request ID\n    search: Search in message text\n    user: Authenticated user\n\nReturns:\n    File download response with exported logs\n\nRaises:\n    HTTPException: If validation fails or export format invalid",
        "operationId": "admin_export_logs_admin_logs_export_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "format",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "default": "json",
              "title": "Format"
            }
          },
          {
            "name": "entity_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Type"
            }
          },
          {
            "name": "entity_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Entity Id"
            }
          },
          {
            "name": "level",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Level"
            }
          },
          {
            "name": "start_time",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Start Time"
            }
          },
          {
            "name": "end_time",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "End Time"
            }
          },
          {
            "name": "request_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Request Id"
            }
          },
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Search"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/export/configuration": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Export Configuration",
        "description": "Export gateway configuration via Admin UI.\n\nArgs:\n    request: FastAPI request object for extracting root path\n    types: Comma-separated entity types to include\n    exclude_types: Comma-separated entity types to exclude\n    tags: Comma-separated tags to filter by\n    include_inactive: Include inactive entities\n    include_dependencies: Include dependent entities\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    JSON file download with configuration export\n\nRaises:\n    HTTPException: If export fails",
        "operationId": "admin_export_configuration_admin_export_configuration_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Types"
            }
          },
          {
            "name": "exclude_types",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Exclude Types"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "include_dependencies",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Include Dependencies"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/export/selective": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Export Selective",
        "description": "Export selected entities via Admin UI with entity selection.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    JSON file download with selective export data\n\nRaises:\n    HTTPException: If export fails\n\nExpects JSON body with entity selections:\n{\n    \"entity_selections\": {\n        \"tools\": [\"tool1\", \"tool2\"],\n        \"servers\": [\"server1\"]\n    },\n    \"include_dependencies\": true\n}",
        "operationId": "admin_export_selective_admin_export_selective_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/import/preview": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Import Preview",
        "description": "Preview import file to show available items for selective import.\n\nArgs:\n    request: FastAPI request object with import file data\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    JSON response with categorized import preview data\n\nRaises:\n    HTTPException: 400 for invalid JSON or missing data field, validation errors;\n                  500 for unexpected preview failures\n\nExpects JSON body:\n{\n    \"data\": { ... }  // The import file content\n}",
        "operationId": "admin_import_preview_admin_import_preview_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/import/configuration": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Import Configuration",
        "description": "Import configuration via Admin UI.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    JSON response with import status\n\nRaises:\n    HTTPException: If import fails\n\nExpects JSON body with import data and options:\n{\n    \"import_data\": { ... },\n    \"conflict_strategy\": \"update\",\n    \"dry_run\": false,\n    \"rekey_secret\": \"optional-new-secret\",\n    \"selected_entities\": { ... }\n}",
        "operationId": "admin_import_configuration_admin_import_configuration_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/import/status/{import_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Import Status",
        "description": "Get import status via Admin UI.\n\nArgs:\n    import_id: Import operation ID\n    user: Authenticated user\n\nReturns:\n    JSON response with import status\n\nRaises:\n    HTTPException: If import not found",
        "operationId": "admin_get_import_status_admin_import_status__import_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "import_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Import Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/import/status": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Import Statuses",
        "description": "List all import statuses via Admin UI.\n\nArgs:\n    user: Authenticated user\n\nReturns:\n    JSON response with list of import statuses",
        "operationId": "admin_list_import_statuses_admin_import_status_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/a2a/{agent_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Agent",
        "description": "Get A2A agent details for the admin UI.\n\nArgs:\n    agent_id: Agent ID.\n    db: Database session.\n    user: Authenticated user.\n\nReturns:\n    Agent details.\n\nRaises:\n    HTTPException: If the agent is not found.\n    Exception: For any other unexpected errors.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import A2AAgentRead\n    >>> from datetime import datetime, timezone\n    >>> from mcpgateway.services.a2a_service import A2AAgentError, A2AAgentNameConflictError, A2AAgentNotFoundError, A2AAgentService\n    >>> from mcpgateway.services.a2a_service import A2AAgentNotFoundError\n    >>> from fastapi import HTTPException\n    >>>\n    >>> a2a_service: Optional[A2AAgentService] = A2AAgentService() if settings.mcpgateway_a2a_enabled else None\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>> agent_id = \"test-agent-id\"\n    >>>\n    >>> mock_agent = A2AAgentRead(\n    ...     id=agent_id, name=\"Agent1\", slug=\"agent1\",\n    ...     description=\"Test A2A agent\", endpoint_url=\"http://agent.local\",\n    ...     agent_type=\"connector\", protocol_version=\"1.0\",\n    ...     capabilities={\"ping\": True}, config={\"x\": \"y\"},\n    ...     auth_type=None, enabled=True, reachable=True,\n    ...     created_at=datetime.now(timezone.utc), updated_at=datetime.now(timezone.utc),\n    ...     last_interaction=None, metrics = {\n    ...                                           \"requests\": 0,\n    ...                                           \"totalExecutions\": 0,\n    ...                                           \"successfulExecutions\": 0,\n    ...                                           \"failedExecutions\": 0,\n    ...                                           \"failureRate\": 0.0,\n    ...                                             }\n    ... )\n    >>>\n    >>> from mcpgateway import admin\n    >>> original_get_agent = admin.a2a_service.get_agent\n    >>> a2a_service.get_agent = AsyncMock(return_value=mock_agent)\n    >>> admin.a2a_service.get_agent = AsyncMock(return_value=mock_agent)\n    >>> async def test_admin_get_agent_success():\n    ...     result = await admin.admin_get_agent(agent_id, mock_db, mock_user)\n    ...     return isinstance(result, dict) and result['id'] == agent_id\n    >>>\n    >>> asyncio.run(test_admin_get_agent_success())\n    True\n    >>>\n    >>> # Test not found\n    >>> admin.a2a_service.get_agent = AsyncMock(side_effect=A2AAgentNotFoundError(\"Agent not found\"))\n    >>> async def test_admin_get_agent_not_found():\n    ...     try:\n    ...         await admin.admin_get_agent(\"bad-id\", mock_db, mock_user)\n    ...         return False\n    ...     except HTTPException as e:\n    ...         return e.status_code == 404 and \"Agent not found\" in e.detail\n    >>>\n    >>> asyncio.run(test_admin_get_agent_not_found())\n    True\n    >>>\n    >>> # Test generic exception\n    >>> admin.a2a_service.get_agent = AsyncMock(side_effect=Exception(\"Generic error\"))\n    >>> async def test_admin_get_agent_exception():\n    ...     try:\n    ...         await admin.admin_get_agent(agent_id, mock_db, mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return str(e) == \"Generic error\"\n    >>>\n    >>> asyncio.run(test_admin_get_agent_exception())\n    True\n    >>>\n    >>> admin.a2a_service.get_agent = original_get_agent",
        "operationId": "admin_get_agent_admin_a2a__agent_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/A2AAgentRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/a2a": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List A2A Agents",
        "description": "List A2A Agents for the admin UI with an option to include inactive agents.\n\nThis endpoint retrieves a list of A2A (Agent-to-Agent) agents associated with\nthe current user. Administrators can optionally include inactive agents for\nmanagement or auditing purposes.\n\nArgs:\n    include_inactive (bool): Whether to include inactive agents in the results.\n    db (Session): Database session dependency.\n    user (dict): Authenticated user dependency.\n\nReturns:\n    List[A2AAgentRead]: A list of A2A agent records formatted with by_alias=True.\n\nRaises:\n    HTTPException (500): If an error occurs while retrieving the agent list.\n\nExamples:\n    >>> import asyncio\n    >>> from unittest.mock import AsyncMock, MagicMock\n    >>> from mcpgateway.schemas import A2AAgentRead, A2AAgentMetrics\n    >>> from datetime import datetime, timezone\n    >>>\n    >>> mock_db = MagicMock()\n    >>> mock_user = {\"email\": \"test_user\", \"db\": mock_db}\n    >>>\n    >>> mock_agent = A2AAgentRead(\n    ...     id=\"1\",\n    ...     name=\"Agent1\",\n    ...     slug=\"agent1\",\n    ...     description=\"A2A Test Agent\",\n    ...     endpoint_url=\"http://localhost/agent1\",\n    ...     agent_type=\"test\",\n    ...     protocol_version=\"1.0\",\n    ...     capabilities={},\n    ...     config={},\n    ...     auth_type=None,\n    ...     enabled=True,\n    ...     reachable=True,\n    ...     created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc),\n    ...     last_interaction=None,\n    ...     tags=[],\n    ...     metrics=A2AAgentMetrics(\n    ...         total_executions=1,\n    ...         successful_executions=1,\n    ...         failed_executions=0,\n    ...         failure_rate=0.0,\n    ...         min_response_time=0.1,\n    ...         max_response_time=0.2,\n    ...         avg_response_time=0.15,\n    ...         last_execution_time=datetime.now(timezone.utc)\n    ...     )\n    ... )\n    >>>\n    >>> original_list_agents_for_user = a2a_service.list_agents_for_user\n    >>> a2a_service.list_agents_for_user = AsyncMock(return_value=[mock_agent])\n    >>>\n    >>> async def test_admin_list_a2a_agents_active():\n    ...     result = await admin_list_a2a_agents(include_inactive=False, db=mock_db, user=mock_user)\n    ...     return len(result) > 0 and isinstance(result[0], dict) and result[0]['name'] == \"Agent1\"\n    >>>\n    >>> asyncio.run(test_admin_list_a2a_agents_active())\n    True\n    >>>\n    >>> a2a_service.list_agents_for_user = AsyncMock(side_effect=Exception(\"A2A error\"))\n    >>> async def test_admin_list_a2a_agents_exception():\n    ...     try:\n    ...         await admin_list_a2a_agents(False, db=mock_db, user=mock_user)\n    ...         return False\n    ...     except Exception as e:\n    ...         return \"A2A error\" in str(e)\n    >>>\n    >>> asyncio.run(test_admin_list_a2a_agents_exception())\n    True\n    >>>\n    >>> a2a_service.list_agents_for_user = original_list_agents_for_user",
        "operationId": "admin_list_a2a_agents_admin_a2a_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/A2AAgentRead"
                  },
                  "title": "Response Admin List A2A Agents Admin A2A Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Add A2A Agent",
        "description": "Add a new A2A agent via admin UI.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    JSONResponse with success/error status\n\nRaises:\n    HTTPException: If A2A features are disabled",
        "operationId": "admin_add_a2a_agent_admin_a2a_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/a2a/{agent_id}/toggle": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Toggle A2A Agent",
        "description": "Toggle A2A agent status via admin UI.\n\nArgs:\n    agent_id: Agent ID\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Redirect response to admin page with A2A tab\n\nRaises:\n    HTTPException: If A2A features are disabled",
        "operationId": "admin_toggle_a2a_agent_admin_a2a__agent_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/a2a/{agent_id}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete A2A Agent",
        "description": "Delete A2A agent via admin UI.\n\nArgs:\n    agent_id: Agent ID\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Redirect response to admin page with A2A tab\n\nRaises:\n    HTTPException: If A2A features are disabled",
        "operationId": "admin_delete_a2a_agent_admin_a2a__agent_id__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/a2a/{agent_id}/test": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Test A2A Agent",
        "description": "Test A2A agent via admin UI.\n\nArgs:\n    agent_id: Agent ID\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    JSON response with test results\n\nRaises:\n    HTTPException: If A2A features are disabled",
        "operationId": "admin_test_a2a_agent_admin_a2a__agent_id__test_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "agent_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Agent Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/grpc": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin List Grpc Services",
        "description": "List all gRPC services.\n\nArgs:\n    include_inactive: Include disabled services\n    team_id: Filter by team ID\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    List of gRPC services\n\nRaises:\n    HTTPException: If gRPC support is disabled or not available",
        "operationId": "admin_list_grpc_services_admin_grpc_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Include Inactive"
            }
          },
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/GrpcServiceRead"
                  },
                  "title": "Response Admin List Grpc Services Admin Grpc Get"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Create Grpc Service",
        "description": "Create a new gRPC service.\n\nArgs:\n    service: gRPC service creation data\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Created gRPC service\n\nRaises:\n    HTTPException: If gRPC support is disabled or creation fails",
        "operationId": "admin_create_grpc_service_admin_grpc_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GrpcServiceCreate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/grpc/{service_id}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Grpc Service",
        "description": "Get a specific gRPC service.\n\nArgs:\n    service_id: Service ID\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    The gRPC service\n\nRaises:\n    HTTPException: If gRPC support is disabled or service not found",
        "operationId": "admin_get_grpc_service_admin_grpc__service_id__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "service_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Service Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GrpcServiceRead"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Update Grpc Service",
        "description": "Update a gRPC service.\n\nArgs:\n    service_id: Service ID\n    service: Update data\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Updated gRPC service\n\nRaises:\n    HTTPException: If gRPC support is disabled or update fails",
        "operationId": "admin_update_grpc_service_admin_grpc__service_id__put",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "service_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Service Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/GrpcServiceUpdate"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/grpc/{service_id}/toggle": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Toggle Grpc Service",
        "description": "Toggle a gRPC service's enabled status.\n\nArgs:\n    service_id: Service ID\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Updated gRPC service\n\nRaises:\n    HTTPException: If gRPC support is disabled or toggle fails",
        "operationId": "admin_toggle_grpc_service_admin_grpc__service_id__toggle_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "service_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Service Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/grpc/{service_id}/delete": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Delete Grpc Service",
        "description": "Delete a gRPC service.\n\nArgs:\n    service_id: Service ID\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    No content response\n\nRaises:\n    HTTPException: If gRPC support is disabled or deletion fails",
        "operationId": "admin_delete_grpc_service_admin_grpc__service_id__delete_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "service_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Service Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/grpc/{service_id}/reflect": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Reflect Grpc Service",
        "description": "Trigger re-reflection on a gRPC service.\n\nArgs:\n    service_id: Service ID\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    Updated gRPC service with reflection results\n\nRaises:\n    HTTPException: If gRPC support is disabled or reflection fails",
        "operationId": "admin_reflect_grpc_service_admin_grpc__service_id__reflect_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "service_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Service Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/grpc/{service_id}/methods": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Get Grpc Methods",
        "description": "Get methods for a gRPC service.\n\nArgs:\n    service_id: Service ID\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    List of gRPC methods\n\nRaises:\n    HTTPException: If gRPC support is disabled or service not found",
        "operationId": "admin_get_grpc_methods_admin_grpc__service_id__methods_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "service_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Service Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/sections/tools": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Tools Section",
        "description": "Get tools data filtered by team.\n\nArgs:\n    team_id: Optional team ID to filter by\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    JSONResponse: Tools data with team filtering applied",
        "operationId": "get_tools_section_admin_sections_tools_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/sections/resources": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Resources Section",
        "description": "Get resources data filtered by team.\n\nArgs:\n    team_id: Optional team ID to filter by\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    JSONResponse: Resources data with team filtering applied",
        "operationId": "get_resources_section_admin_sections_resources_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/sections/prompts": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Prompts Section",
        "description": "Get prompts data filtered by team.\n\nArgs:\n    team_id: Optional team ID to filter by\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    JSONResponse: Prompts data with team filtering applied",
        "operationId": "get_prompts_section_admin_sections_prompts_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/sections/servers": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Servers Section",
        "description": "Get servers data filtered by team.\n\nArgs:\n    team_id: Optional team ID to filter by\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    JSONResponse: Servers data with team filtering applied",
        "operationId": "get_servers_section_admin_sections_servers_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/sections/gateways": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Gateways Section",
        "description": "Get gateways data filtered by team.\n\nArgs:\n    team_id: Optional team ID to filter by\n    db: Database session\n    user: Current authenticated user context\n\nReturns:\n    JSONResponse: Gateways data with team filtering applied",
        "operationId": "get_gateways_section_admin_sections_gateways_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "team_id",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Team Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/plugins/partial": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Plugins Partial",
        "description": "Render the plugins partial HTML template.\n\nThis endpoint returns a rendered HTML partial containing plugin information,\nsimilar to the version_info_partial pattern. It's designed to be loaded via HTMX\ninto the admin interface.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    HTMLResponse with rendered plugins partial template",
        "operationId": "get_plugins_partial_admin_plugins_partial_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/plugins": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "List Plugins",
        "description": "Get list of all plugins with optional filtering.\n\nArgs:\n    request: FastAPI request object\n    search: Optional text search in name/description/author\n    mode: Optional filter by mode (enforce/permissive/disabled)\n    hook: Optional filter by hook type\n    tag: Optional filter by tag\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    PluginListResponse with list of plugins and statistics\n\nRaises:\n    HTTPException: If there's an error retrieving plugins",
        "operationId": "list_plugins_admin_plugins_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Search"
            }
          },
          {
            "name": "mode",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Mode"
            }
          },
          {
            "name": "hook",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Hook"
            }
          },
          {
            "name": "tag",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tag"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PluginListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/plugins/stats": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Plugin Stats",
        "description": "Get plugin statistics.\n\nArgs:\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    PluginStatsResponse with aggregated plugin statistics\n\nRaises:\n    HTTPException: If there's an error getting plugin statistics",
        "operationId": "get_plugin_stats_admin_plugins_stats_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PluginStatsResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/plugins/{name}": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get Plugin Details",
        "description": "Get detailed information about a specific plugin.\n\nArgs:\n    name: Plugin name\n    request: FastAPI request object\n    db: Database session\n    user: Authenticated user\n\nReturns:\n    PluginDetail with full plugin information\n\nRaises:\n    HTTPException: If plugin not found",
        "operationId": "get_plugin_details_admin_plugins__name__get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Name"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PluginDetail"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/mcp-registry/servers": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "List Catalog Servers",
        "description": "Get list of catalog servers with filtering.\n\nArgs:\n    _request: FastAPI request object\n    category: Filter by category\n    auth_type: Filter by authentication type\n    provider: Filter by provider\n    search: Search in name/description\n    tags: Filter by tags\n    show_registered_only: Show only already registered servers\n    show_available_only: Show only available servers\n    limit: Maximum results\n    offset: Pagination offset\n    db: Database session\n    _user: Authenticated user\n\nReturns:\n    List of catalog servers matching filters\n\nRaises:\n    HTTPException: If the catalog feature is disabled.",
        "operationId": "list_catalog_servers_admin_mcp_registry_servers_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "category",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Category"
            }
          },
          {
            "name": "auth_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Auth Type"
            }
          },
          {
            "name": "provider",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Provider"
            }
          },
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Search"
            }
          },
          {
            "name": "tags",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                {
                  "type": "null"
                }
              ],
              "title": "Tags"
            }
          },
          {
            "name": "show_registered_only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": false,
              "title": "Show Registered Only"
            }
          },
          {
            "name": "show_available_only",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "default": true,
              "title": "Show Available Only"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 100,
              "title": "Limit"
            }
          },
          {
            "name": "offset",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 0,
              "title": "Offset"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogListResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/mcp-registry/{server_id}/register": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Register Catalog Server",
        "description": "Register a catalog server.\n\nArgs:\n    server_id: Catalog server ID to register\n    request: Optional registration parameters\n    db: Database session\n    _user: Authenticated user\n\nReturns:\n    Registration response with success status\n\nRaises:\n    HTTPException: If the catalog feature is disabled.",
        "operationId": "register_catalog_server_admin_mcp_registry__server_id__register_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "anyOf": [
                  {
                    "$ref": "#/components/schemas/CatalogServerRegisterRequest"
                  },
                  {
                    "type": "null"
                  }
                ],
                "title": "Request"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogServerRegisterResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/mcp-registry/{server_id}/status": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Check Catalog Server Status",
        "description": "Check catalog server availability.\n\nArgs:\n    server_id: Catalog server ID to check\n    _db: Database session\n    _user: Authenticated user\n\nReturns:\n    Server status including availability and response time\n\nRaises:\n    HTTPException: If the catalog feature is disabled.",
        "operationId": "check_catalog_server_status_admin_mcp_registry__server_id__status_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "server_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "title": "Server Id"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogServerStatusResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/mcp-registry/bulk-register": {
      "post": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Bulk Register Catalog Servers",
        "description": "Register multiple catalog servers at once.\n\nArgs:\n    request: Bulk registration request with server IDs\n    db: Database session\n    _user: Authenticated user\n\nReturns:\n    Bulk registration response with success/failure details\n\nRaises:\n    HTTPException: If the catalog feature is disabled.",
        "operationId": "bulk_register_catalog_servers_admin_mcp_registry_bulk_register_post",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CatalogBulkRegisterRequest"
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CatalogBulkRegisterResponse"
                }
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/mcp-registry/partial": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Catalog Partial",
        "description": "Get HTML partial for catalog servers (used by HTMX).\n\nArgs:\n    request: FastAPI request object\n    category: Filter by category\n    auth_type: Filter by authentication type\n    search: Search term\n    page: Page number (1-indexed)\n    db: Database session\n    _user: Authenticated user\n\nReturns:\n    HTML partial with filtered catalog servers\n\nRaises:\n    HTTPException: If the catalog feature is disabled.",
        "operationId": "catalog_partial_admin_mcp_registry_partial_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "category",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Category"
            }
          },
          {
            "name": "auth_type",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Auth Type"
            }
          },
          {
            "name": "search",
            "in": "query",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Search"
            }
          },
          {
            "name": "page",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "default": 1,
              "title": "Page"
            }
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/system/stats": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Get System Stats",
        "description": "Get comprehensive system metrics for administrators.\n\nReturns detailed counts across all entity types including users, teams,\nMCP resources (servers, tools, resources, prompts, A2A agents, gateways),\nAPI tokens, sessions, metrics, security events, and workflow state.\n\nDesigned for capacity planning, performance optimization, and demonstrating\nsystem capabilities to administrators.\n\nArgs:\n    request: FastAPI request object\n    db: Database session dependency\n    user: Authenticated user from dependency (must have admin access)\n\nReturns:\n    HTMLResponse or JSONResponse: Comprehensive system metrics\n    Returns HTML partial when requested via HTMX, JSON otherwise\n\nRaises:\n    HTTPException: If metrics collection fails\n\nExamples:\n    >>> # Request system metrics via API\n    >>> # GET /admin/system/stats\n    >>> # Returns JSON with users, teams, mcp_resources, tokens, sessions, metrics, security, workflow",
        "operationId": "get_system_stats_admin_system_stats_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/admin/support-bundle/generate": {
      "get": {
        "tags": [
          "Admin UI"
        ],
        "summary": "Admin Generate Support Bundle",
        "description": "Generate and download a support bundle with sanitized diagnostics.\n\nCreates a ZIP file containing version info, system diagnostics, configuration,\nand logs with automatic sanitization of sensitive data (passwords, tokens, secrets).\n\nArgs:\n    log_lines: Number of log lines to include (default: 1000, 0 = all)\n    include_logs: Include log files in bundle (default: True)\n    include_env: Include environment configuration (default: True)\n    include_system: Include system diagnostics (default: True)\n    user: Authenticated user from dependency\n\nReturns:\n    Response: ZIP file download with support bundle\n\nRaises:\n    HTTPException: If bundle generation fails\n\nExamples:\n    >>> # Request support bundle via API\n    >>> # GET /admin/support-bundle/generate?log_lines=500\n    >>> # Returns: mcpgateway-support-YYYY-MM-DD-HHMMSS.zip",
        "operationId": "admin_generate_support_bundle_admin_support_bundle_generate_get",
        "security": [
          {
            "HTTPBearer": []
          }
        ],
        "parameters": [
          {
            "name": "log_lines",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "description": "Number of log lines to include",
              "default": 1000,
              "title": "Log Lines"
            },
            "description": "Number of log lines to include"
          },
          {
            "name": "include_logs",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include log files",
              "default": true,
              "title": "Include Logs"
            },
            "description": "Include log files"
          },
          {
            "name": "include_env",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include environment config",
              "default": true,
              "title": "Include Env"
            },
            "description": "Include environment config"
          },
          {
            "name": "include_system",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean",
              "description": "Include system info",
              "default": true,
              "title": "Include System"
            },
            "description": "Include system info"
          },
          {
            "name": "jwt_token",
            "in": "cookie",
            "required": false,
            "schema": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "null"
                }
              ],
              "title": "Jwt Token"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          },
          "422": {
            "description": "Validation Error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/": {
      "get": {
        "summary": "Root Redirect",
        "description": "Redirects the root path (\"/\") to \"/admin\".\n\nLogs a debug message before redirecting.\n\nArgs:\n    request (Request): The incoming HTTP request (used only to build the\n        target URL via :pymeth:`starlette.requests.Request.url_for`).\n\nReturns:\n    RedirectResponse: Redirects to /admin.\n\nRaises:\n    HTTPException: If there is an error during redirection.",
        "operationId": "root_redirect__get",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        }
      }
    },
    "/initialize": {
      "post": {
        "summary": "Initialize",
        "description": "Initialize a protocol.\n\nThis endpoint handles the initialization process of a protocol by accepting\na JSON request body and processing it. The `require_auth` dependency ensures that\nthe user is authenticated before proceeding.\n\nArgs:\n    request (Request): The incoming request object containing the JSON body.\n    user (str): The authenticated user (from `require_auth` dependency).\n\nReturns:\n    InitializeResult: The result of the initialization process.\n\nRaises:\n    HTTPException: If the request body contains invalid JSON, a 400 Bad Request error is raised.",
        "operationId": "initialize_initialize_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/InitializeResult"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBearer": []
          }
        ]
      }
    },
    "/notifications": {
      "post": {
        "summary": "Handle Notification",
        "description": "Handles incoming notifications from clients. Depending on the notification method,\ndifferent actions are taken (e.g., logging initialization, cancellation, or messages).\n\nArgs:\n    request (Request): The incoming request containing the notification data.\n    user (str): The authenticated user making the request.",
        "operationId": "handle_notification_notifications_post",
        "responses": {
          "200": {
            "description": "Successful Response",
            "content": {
              "application/json": {
                "schema": {}
              }
            }
          }
        },
        "security": [
          {
            "HTTPBearer": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "A2AAgentCreate": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name for the agent"
          },
          "slug": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Slug",
            "description": "Optional slug for the agent (auto-generated if not provided)"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Agent description"
          },
          "endpoint_url": {
            "type": "string",
            "title": "Endpoint Url",
            "description": "URL endpoint for the agent"
          },
          "agent_type": {
            "type": "string",
            "title": "Agent Type",
            "description": "Type of agent (e.g., 'openai', 'anthropic', 'custom')",
            "default": "generic"
          },
          "protocol_version": {
            "type": "string",
            "title": "Protocol Version",
            "description": "A2A protocol version supported",
            "default": "1.0"
          },
          "capabilities": {
            "additionalProperties": true,
            "type": "object",
            "title": "Capabilities",
            "description": "Agent capabilities and features"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "Agent-specific configuration parameters"
          },
          "auth_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Type",
            "description": "Type of authentication"
          },
          "auth_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Value",
            "description": "Authentication credentials"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorizing the agent"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID for resource organization"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Email of the agent owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "name",
          "endpoint_url"
        ],
        "title": "A2AAgentCreate",
        "description": "Schema for creating a new A2A (Agent-to-Agent) compatible agent.\n\nAttributes:\n    model_config (ConfigDict): Configuration for the model.\n    name (str): Unique name for the agent.\n    description (Optional[str]): Optional description of the agent.\n    endpoint_url (str): URL endpoint for the agent.\n    agent_type (str): Type of agent (e.g., \"openai\", \"anthropic\", \"custom\").\n    protocol_version (str): A2A protocol version supported.\n    capabilities (Dict[str, Any]): Agent capabilities and features.\n    config (Dict[str, Any]): Agent-specific configuration parameters.\n    auth_type (Optional[str]): Type of authentication (\"api_key\", \"oauth\", \"bearer\", etc.).\n    auth_value (Optional[str]): Authentication credentials (will be encrypted).\n    tags (List[str]): Tags for categorizing the agent.\n    team_id (Optional[str]): Team ID for resource organization.\n    visibility (str): Visibility level (\"private\", \"team\", \"public\")."
      },
      "A2AAgentMetrics": {
        "properties": {
          "totalExecutions": {
            "type": "integer",
            "title": "Totalexecutions",
            "description": "Total number of agent interactions"
          },
          "successfulExecutions": {
            "type": "integer",
            "title": "Successfulexecutions",
            "description": "Number of successful agent interactions"
          },
          "failedExecutions": {
            "type": "integer",
            "title": "Failedexecutions",
            "description": "Number of failed agent interactions"
          },
          "failureRate": {
            "type": "number",
            "title": "Failurerate",
            "description": "Failure rate (failed interactions / total interactions)"
          },
          "minResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Minresponsetime",
            "description": "Minimum response time in seconds"
          },
          "maxResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Maxresponsetime",
            "description": "Maximum response time in seconds"
          },
          "avgResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avgresponsetime",
            "description": "Average response time in seconds"
          },
          "lastExecutionTime": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastexecutiontime",
            "description": "Timestamp of the most recent interaction"
          }
        },
        "type": "object",
        "required": [
          "totalExecutions",
          "successfulExecutions",
          "failedExecutions",
          "failureRate"
        ],
        "title": "A2AAgentMetrics",
        "description": "Represents the performance and execution statistics for an A2A agent.\n\nAttributes:\n    total_executions (int): Total number of agent interactions.\n    successful_executions (int): Number of successful agent interactions.\n    failed_executions (int): Number of failed agent interactions.\n    failure_rate (float): Failure rate (failed interactions / total interactions).\n    min_response_time (Optional[float]): Minimum response time in seconds.\n    max_response_time (Optional[float]): Maximum response time in seconds.\n    avg_response_time (Optional[float]): Average response time in seconds.\n    last_execution_time (Optional[datetime]): Timestamp of the most recent interaction.",
        "nullable": true
      },
      "A2AAgentRead": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "slug": {
            "type": "string",
            "title": "Slug"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "endpointUrl": {
            "type": "string",
            "title": "Endpointurl"
          },
          "agentType": {
            "type": "string",
            "title": "Agenttype"
          },
          "protocolVersion": {
            "type": "string",
            "title": "Protocolversion"
          },
          "capabilities": {
            "additionalProperties": true,
            "type": "object",
            "title": "Capabilities"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config"
          },
          "authType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authtype"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled"
          },
          "reachable": {
            "type": "boolean",
            "title": "Reachable"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "Updatedat"
          },
          "lastInteraction": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastinteraction"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorizing the agent"
          },
          "metrics": {
            "$ref": "#/components/schemas/A2AAgentMetrics"
          },
          "createdBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdby",
            "description": "Username who created this entity"
          },
          "createdFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdfromip",
            "description": "IP address of creator"
          },
          "createdVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdvia",
            "description": "Creation method: ui|api|import|federation"
          },
          "createdUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createduseragent",
            "description": "User agent of creation request"
          },
          "modifiedBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedby",
            "description": "Username who last modified this entity"
          },
          "modifiedFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedfromip",
            "description": "IP address of last modifier"
          },
          "modifiedVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedvia",
            "description": "Modification method"
          },
          "modifiedUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifieduseragent",
            "description": "User agent of modification request"
          },
          "importBatchId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Importbatchid",
            "description": "UUID of bulk import batch"
          },
          "federationSource": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Federationsource",
            "description": "Source gateway for federated entities"
          },
          "version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "Entity version for change tracking",
            "default": 1
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "ID of the team that owns this resource"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the user who owns this resource"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level: private, team, or public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "slug",
          "description",
          "endpointUrl",
          "agentType",
          "protocolVersion",
          "capabilities",
          "config",
          "authType",
          "enabled",
          "reachable",
          "createdAt",
          "updatedAt",
          "lastInteraction",
          "metrics"
        ],
        "title": "A2AAgentRead",
        "description": "Schema for reading A2A agent information.\n\nIncludes all agent fields plus:\n- Database ID\n- Slug\n- Creation/update timestamps\n- Enabled/reachable status\n- Metrics\n- Audit metadata",
        "nullable": true
      },
      "A2AAgentUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Unique name for the agent"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Agent description"
          },
          "endpointUrl": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Endpointurl",
            "description": "URL endpoint for the agent"
          },
          "agentType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Agenttype",
            "description": "Type of agent"
          },
          "protocolVersion": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Protocolversion",
            "description": "A2A protocol version supported"
          },
          "capabilities": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Capabilities",
            "description": "Agent capabilities and features"
          },
          "config": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Config",
            "description": "Agent-specific configuration parameters"
          },
          "authType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authtype",
            "description": "Type of authentication"
          },
          "authValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authvalue",
            "description": "Authentication credentials"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the agent"
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "Team ID for resource organization"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the agent owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)"
          }
        },
        "type": "object",
        "title": "A2AAgentUpdate",
        "description": "Schema for updating an existing A2A agent.\n\nSimilar to A2AAgentCreate but all fields are optional to allow partial updates.",
        "nullable": true
      },
      "AuthEventResponse": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id",
            "description": "Event ID"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "Timestamp",
            "description": "Event timestamp"
          },
          "user_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "User Email",
            "description": "User's email address"
          },
          "event_type": {
            "type": "string",
            "title": "Event Type",
            "description": "Type of authentication event"
          },
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether the event was successful"
          },
          "ip_address": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Ip Address",
            "description": "Client IP address"
          },
          "failure_reason": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Failure Reason",
            "description": "Reason for failure"
          }
        },
        "type": "object",
        "required": [
          "id",
          "timestamp",
          "event_type",
          "success"
        ],
        "title": "AuthEventResponse",
        "description": "Response schema for authentication events.\n\nAttributes:\n    id: Event ID\n    timestamp: Event timestamp\n    user_email: User's email address\n    event_type: Type of authentication event\n    success: Whether the event was successful\n    ip_address: Client IP address\n    failure_reason: Reason for failure (if applicable)\n\nExamples:\n    >>> from datetime import datetime\n    >>> event = AuthEventResponse(\n    ...     id=1,\n    ...     timestamp=datetime.now(),\n    ...     user_email=\"user@example.com\",\n    ...     event_type=\"login\",\n    ...     success=True,\n    ...     ip_address=\"192.168.1.1\",\n    ...     failure_reason=None\n    ... )\n    >>> event.event_type\n    'login'\n    >>> event.success\n    True"
      },
      "AuthenticationResponse": {
        "properties": {
          "access_token": {
            "type": "string",
            "title": "Access Token",
            "description": "JWT access token"
          },
          "token_type": {
            "type": "string",
            "title": "Token Type",
            "description": "Token type",
            "default": "bearer"
          },
          "expires_in": {
            "type": "integer",
            "title": "Expires In",
            "description": "Token expiration in seconds"
          },
          "user": {
            "$ref": "#/components/schemas/EmailUserResponse",
            "description": "User information"
          }
        },
        "type": "object",
        "required": [
          "access_token",
          "expires_in",
          "user"
        ],
        "title": "AuthenticationResponse",
        "description": "Response schema for successful authentication.\n\nAttributes:\n    access_token: JWT token for API access\n    token_type: Type of token (always 'bearer')\n    expires_in: Token expiration time in seconds\n    user: User information\n\nExamples:\n    >>> from datetime import datetime\n    >>> response = AuthenticationResponse(\n    ...     access_token=\"jwt.token.here\",\n    ...     token_type=\"bearer\",\n    ...     expires_in=3600,\n    ...     user=EmailUserResponse(\n    ...         email=\"user@example.com\",\n    ...         full_name=\"Test User\",\n    ...         is_admin=False,\n    ...         is_active=True,\n    ...         auth_provider=\"local\",\n    ...         created_at=datetime.now(),\n    ...         last_login=None,\n    ...         email_verified=False\n    ...     )\n    ... )\n    >>> response.token_type\n    'bearer'\n    >>> response.user.email\n    'user@example.com'"
      },
      "AuthenticationValues": {
        "properties": {
          "authType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authtype",
            "description": "Type of authentication: basic, bearer, headers or None"
          },
          "authValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authvalue",
            "description": "Encoded Authentication values"
          },
          "username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Username",
            "description": "Username for basic authentication",
            "default": ""
          },
          "password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Password",
            "description": "Password for basic authentication",
            "default": ""
          },
          "token": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Token",
            "description": "Bearer token for authentication",
            "default": ""
          },
          "authHeaderKey": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authheaderkey",
            "description": "Key for custom headers authentication",
            "default": ""
          },
          "authHeaderValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authheadervalue",
            "description": "Value for custom headers authentication",
            "default": ""
          }
        },
        "type": "object",
        "title": "AuthenticationValues",
        "description": "Schema for all Authentications.\nProvides the authentication values for different types of authentication.",
        "nullable": true
      },
      "Body_create_a2a_agent_a2a__post": {
        "properties": {
          "agent": {
            "$ref": "#/components/schemas/A2AAgentCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign agent to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Agent visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "agent"
        ],
        "title": "Body_create_a2a_agent_a2a__post"
      },
      "Body_create_a2a_agent_a2a_post": {
        "properties": {
          "agent": {
            "$ref": "#/components/schemas/A2AAgentCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign agent to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Agent visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "agent"
        ],
        "title": "Body_create_a2a_agent_a2a_post"
      },
      "Body_create_prompt_prompts__post": {
        "properties": {
          "prompt": {
            "$ref": "#/components/schemas/PromptCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign prompt to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Prompt visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "prompt"
        ],
        "title": "Body_create_prompt_prompts__post"
      },
      "Body_create_prompt_prompts_post": {
        "properties": {
          "prompt": {
            "$ref": "#/components/schemas/PromptCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign prompt to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Prompt visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "prompt"
        ],
        "title": "Body_create_prompt_prompts_post"
      },
      "Body_create_resource_resources__post": {
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/ResourceCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign resource to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Resource visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "resource"
        ],
        "title": "Body_create_resource_resources__post"
      },
      "Body_create_resource_resources_post": {
        "properties": {
          "resource": {
            "$ref": "#/components/schemas/ResourceCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign resource to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Resource visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "resource"
        ],
        "title": "Body_create_resource_resources_post"
      },
      "Body_create_server_servers__post": {
        "properties": {
          "server": {
            "$ref": "#/components/schemas/ServerCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign server to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Server visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "server"
        ],
        "title": "Body_create_server_servers__post"
      },
      "Body_create_server_servers_post": {
        "properties": {
          "server": {
            "$ref": "#/components/schemas/ServerCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign server to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Server visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "server"
        ],
        "title": "Body_create_server_servers_post"
      },
      "Body_create_tool_tools__post": {
        "properties": {
          "tool": {
            "$ref": "#/components/schemas/ToolCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign tool to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Tool visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "tool"
        ],
        "title": "Body_create_tool_tools__post"
      },
      "Body_create_tool_tools_post": {
        "properties": {
          "tool": {
            "$ref": "#/components/schemas/ToolCreate"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID to assign tool to"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Tool visibility: private, team, public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "tool"
        ],
        "title": "Body_create_tool_tools_post"
      },
      "Body_import_configuration_import_post": {
        "properties": {
          "import_data": {
            "additionalProperties": true,
            "type": "object",
            "title": "Import Data"
          },
          "selected_entities": {
            "anyOf": [
              {
                "additionalProperties": {
                  "items": {
                    "type": "string"
                  },
                  "type": "array"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Selected Entities"
          }
        },
        "type": "object",
        "required": [
          "import_data"
        ],
        "title": "Body_import_configuration_import_post"
      },
      "Body_invoke_a2a_agent_a2a__agent_name__invoke_post": {
        "properties": {
          "parameters": {
            "additionalProperties": true,
            "type": "object",
            "title": "Parameters"
          },
          "interaction_type": {
            "type": "string",
            "title": "Interaction Type",
            "default": "query"
          }
        },
        "type": "object",
        "title": "Body_invoke_a2a_agent_a2a__agent_name__invoke_post"
      },
      "CatalogBulkRegisterRequest": {
        "properties": {
          "server_ids": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Server Ids",
            "description": "List of catalog server IDs to register"
          },
          "skip_errors": {
            "type": "boolean",
            "title": "Skip Errors",
            "description": "Continue on error",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "server_ids"
        ],
        "title": "CatalogBulkRegisterRequest",
        "description": "Request to register multiple catalog servers."
      },
      "CatalogBulkRegisterResponse": {
        "properties": {
          "successful": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Successful",
            "description": "Successfully registered server IDs"
          },
          "failed": {
            "items": {
              "additionalProperties": {
                "type": "string"
              },
              "type": "object"
            },
            "type": "array",
            "title": "Failed",
            "description": "Failed registrations with error messages"
          },
          "total_attempted": {
            "type": "integer",
            "title": "Total Attempted",
            "description": "Total servers attempted"
          },
          "total_successful": {
            "type": "integer",
            "title": "Total Successful",
            "description": "Total successful registrations"
          }
        },
        "type": "object",
        "required": [
          "successful",
          "failed",
          "total_attempted",
          "total_successful"
        ],
        "title": "CatalogBulkRegisterResponse",
        "description": "Response after bulk registration."
      },
      "CatalogListResponse": {
        "properties": {
          "servers": {
            "items": {
              "$ref": "#/components/schemas/CatalogServer"
            },
            "type": "array",
            "title": "Servers",
            "description": "List of catalog servers"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of matching servers"
          },
          "categories": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Categories",
            "description": "Available categories"
          },
          "auth_types": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Auth Types",
            "description": "Available auth types"
          },
          "providers": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Providers",
            "description": "Available providers"
          },
          "all_tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "All Tags",
            "description": "All available tags"
          }
        },
        "type": "object",
        "required": [
          "servers",
          "total",
          "categories",
          "auth_types",
          "providers"
        ],
        "title": "CatalogListResponse",
        "description": "Response containing catalog servers."
      },
      "CatalogServer": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique identifier for the catalog server"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Display name of the server"
          },
          "category": {
            "type": "string",
            "title": "Category",
            "description": "Server category (e.g., Project Management, Software Development)"
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "Server endpoint URL"
          },
          "auth_type": {
            "type": "string",
            "title": "Auth Type",
            "description": "Authentication type (e.g., OAuth2.1, API Key, Open)"
          },
          "provider": {
            "type": "string",
            "title": "Provider",
            "description": "Provider/vendor name"
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Server description"
          },
          "requires_api_key": {
            "type": "boolean",
            "title": "Requires Api Key",
            "description": "Whether API key is required",
            "default": false
          },
          "secure": {
            "type": "boolean",
            "title": "Secure",
            "description": "Whether additional security is required",
            "default": false
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorization"
          },
          "transport": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Transport",
            "description": "Transport type: SSE, STREAMABLEHTTP, or WEBSOCKET"
          },
          "logo_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Logo Url",
            "description": "URL to server logo/icon"
          },
          "documentation_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Documentation Url",
            "description": "URL to server documentation"
          },
          "is_registered": {
            "type": "boolean",
            "title": "Is Registered",
            "description": "Whether server is already registered",
            "default": false
          },
          "is_available": {
            "type": "boolean",
            "title": "Is Available",
            "description": "Whether server is currently available",
            "default": true
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "category",
          "url",
          "auth_type",
          "provider",
          "description"
        ],
        "title": "CatalogServer",
        "description": "Schema for a catalog server entry."
      },
      "CatalogServerRegisterRequest": {
        "properties": {
          "server_id": {
            "type": "string",
            "title": "Server Id",
            "description": "Catalog server ID to register"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Optional custom name for the server"
          },
          "api_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Api Key",
            "description": "API key if required"
          },
          "oauth_credentials": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Oauth Credentials",
            "description": "OAuth credentials if required"
          }
        },
        "type": "object",
        "required": [
          "server_id"
        ],
        "title": "CatalogServerRegisterRequest",
        "description": "Request to register a catalog server."
      },
      "CatalogServerRegisterResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Whether registration was successful"
          },
          "server_id": {
            "type": "string",
            "title": "Server Id",
            "description": "ID of the registered server in the system"
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Status message"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message if registration failed"
          }
        },
        "type": "object",
        "required": [
          "success",
          "server_id",
          "message"
        ],
        "title": "CatalogServerRegisterResponse",
        "description": "Response after registering a catalog server."
      },
      "CatalogServerStatusResponse": {
        "properties": {
          "server_id": {
            "type": "string",
            "title": "Server Id",
            "description": "Catalog server ID"
          },
          "is_available": {
            "type": "boolean",
            "title": "Is Available",
            "description": "Whether server is reachable"
          },
          "is_registered": {
            "type": "boolean",
            "title": "Is Registered",
            "description": "Whether server is registered"
          },
          "last_checked": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Checked",
            "description": "Last health check timestamp"
          },
          "response_time_ms": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Response Time Ms",
            "description": "Response time in milliseconds"
          },
          "error": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Error",
            "description": "Error message if check failed"
          }
        },
        "type": "object",
        "required": [
          "server_id",
          "is_available",
          "is_registered"
        ],
        "title": "CatalogServerStatusResponse",
        "description": "Response for catalog server status check."
      },
      "ChangePasswordRequest": {
        "properties": {
          "old_password": {
            "type": "string",
            "minLength": 1,
            "title": "Old Password",
            "description": "Current password"
          },
          "new_password": {
            "type": "string",
            "minLength": 8,
            "title": "New Password",
            "description": "New password"
          }
        },
        "type": "object",
        "required": [
          "old_password",
          "new_password"
        ],
        "title": "ChangePasswordRequest",
        "description": "Request schema for password change.\n\nAttributes:\n    old_password: Current password for verification\n    new_password: New password to set\n\nExamples:\n    >>> request = ChangePasswordRequest(\n    ...     old_password=\"old_secret\",\n    ...     new_password=\"new_secure_password\"\n    ... )\n    >>> request.old_password\n    'old_secret'\n    >>> request.new_password\n    'new_secure_password'"
      },
      "EmailLoginRequest": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email",
            "description": "User's email address"
          },
          "password": {
            "type": "string",
            "minLength": 1,
            "title": "Password",
            "description": "User's password"
          }
        },
        "type": "object",
        "required": [
          "email",
          "password"
        ],
        "title": "EmailLoginRequest",
        "description": "Request schema for email login.\n\nAttributes:\n    email: User's email address\n    password: User's password\n\nExamples:\n    >>> request = EmailLoginRequest(email=\"user@example.com\", password=\"secret123\")\n    >>> request.email\n    'user@example.com'\n    >>> request.password\n    'secret123'"
      },
      "EmailRegistrationRequest": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email",
            "description": "User's email address"
          },
          "password": {
            "type": "string",
            "minLength": 8,
            "title": "Password",
            "description": "User's password"
          },
          "full_name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255
              },
              {
                "type": "null"
              }
            ],
            "title": "Full Name",
            "description": "User's full name"
          }
        },
        "type": "object",
        "required": [
          "email",
          "password"
        ],
        "title": "EmailRegistrationRequest",
        "description": "Request schema for user registration.\n\nAttributes:\n    email: User's email address\n    password: User's password\n    full_name: Optional full name for display\n\nExamples:\n    >>> request = EmailRegistrationRequest(\n    ...     email=\"new@example.com\",\n    ...     password=\"secure123\",\n    ...     full_name=\"New User\"\n    ... )\n    >>> request.email\n    'new@example.com'\n    >>> request.full_name\n    'New User'"
      },
      "EmailUserResponse": {
        "properties": {
          "email": {
            "type": "string",
            "title": "Email",
            "description": "User's email address"
          },
          "full_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Full Name",
            "description": "User's full name"
          },
          "is_admin": {
            "type": "boolean",
            "title": "Is Admin",
            "description": "Whether user has admin privileges"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether account is active"
          },
          "auth_provider": {
            "type": "string",
            "title": "Auth Provider",
            "description": "Authentication provider"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Account creation timestamp"
          },
          "last_login": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Login",
            "description": "Last successful login"
          },
          "email_verified": {
            "type": "boolean",
            "title": "Email Verified",
            "description": "Whether email is verified",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "email",
          "is_admin",
          "is_active",
          "auth_provider",
          "created_at"
        ],
        "title": "EmailUserResponse",
        "description": "Response schema for user information.\n\nAttributes:\n    email: User's email address\n    full_name: User's full name\n    is_admin: Whether user has admin privileges\n    is_active: Whether account is active\n    auth_provider: Authentication provider used\n    created_at: Account creation timestamp\n    last_login: Last successful login timestamp\n    email_verified: Whether email is verified\n\nExamples:\n    >>> user = EmailUserResponse(\n    ...     email=\"user@example.com\",\n    ...     full_name=\"Test User\",\n    ...     is_admin=False,\n    ...     is_active=True,\n    ...     auth_provider=\"local\",\n    ...     created_at=datetime.now(),\n    ...     last_login=None,\n    ...     email_verified=False\n    ... )\n    >>> user.email\n    'user@example.com'\n    >>> user.is_admin\n    False"
      },
      "GatewayCreate": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name for the gateway"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "minLength": 1,
                "format": "uri"
              }
            ],
            "title": "Url",
            "description": "Gateway endpoint URL"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Gateway description"
          },
          "transport": {
            "type": "string",
            "title": "Transport",
            "description": "Transport used by MCP server: SSE or STREAMABLEHTTP",
            "default": "SSE"
          },
          "passthrough_headers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Passthrough Headers",
            "description": "List of headers allowed to be passed through from client to target"
          },
          "auth_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Type",
            "description": "Type of authentication: basic, bearer, headers, oauth, or none"
          },
          "auth_username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Username",
            "description": "Username for basic authentication"
          },
          "auth_password": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Password",
            "description": "Password for basic authentication"
          },
          "auth_token": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Token",
            "description": "Token for bearer authentication"
          },
          "auth_header_key": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Header Key",
            "description": "Key for custom headers authentication"
          },
          "auth_header_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Header Value",
            "description": "Value for custom headers authentication"
          },
          "auth_headers": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Headers",
            "description": "List of custom headers for authentication"
          },
          "oauth_config": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Oauth Config",
            "description": "OAuth 2.0 configuration including grant_type, client_id, encrypted client_secret, URLs, and scopes"
          },
          "auth_value": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Auth Value"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the gateway"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID this gateway belongs to"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Email of the gateway owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Gateway visibility: private, team, or public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "name",
          "url"
        ],
        "title": "GatewayCreate",
        "description": "Schema for creating a new gateway.\n\nAttributes:\n    model_config (ConfigDict): Configuration for the model.\n    name (str): Unique name for the gateway.\n    url (Union[str, AnyHttpUrl]): Gateway endpoint URL.\n    description (Optional[str]): Optional description of the gateway.\n    transport (str): Transport used by the MCP server, default is \"SSE\".\n    auth_type (Optional[str]): Type of authentication (basic, bearer, headers, or none).\n    auth_username (Optional[str]): Username for basic authentication.\n    auth_password (Optional[str]): Password for basic authentication.\n    auth_token (Optional[str]): Token for bearer authentication.\n    auth_header_key (Optional[str]): Key for custom headers authentication.\n    auth_header_value (Optional[str]): Value for custom headers authentication.\n    auth_headers (Optional[List[Dict[str, str]]]): List of custom headers for authentication.\n    auth_value (Optional[str]): Alias for authentication value, used for better access post-validation."
      },
      "GatewayRead": {
        "properties": {
          "id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Id",
            "description": "Unique ID of the gateway"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name for the gateway"
          },
          "url": {
            "type": "string",
            "title": "Url",
            "description": "Gateway endpoint URL"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Gateway description"
          },
          "transport": {
            "type": "string",
            "title": "Transport",
            "description": "Transport used by MCP server: SSE or STREAMABLEHTTP",
            "default": "SSE"
          },
          "capabilities": {
            "additionalProperties": true,
            "type": "object",
            "title": "Capabilities",
            "description": "Gateway capabilities"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat",
            "description": "Creation timestamp"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "Updatedat",
            "description": "Last update timestamp"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Is the gateway enabled?",
            "default": true
          },
          "reachable": {
            "type": "boolean",
            "title": "Reachable",
            "description": "Is the gateway reachable/online?",
            "default": true
          },
          "lastSeen": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastseen",
            "description": "Last seen timestamp"
          },
          "passthroughHeaders": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Passthroughheaders",
            "description": "List of headers allowed to be passed through from client to target"
          },
          "authType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authtype",
            "description": "auth_type: basic, bearer, headers, oauth, or None"
          },
          "authValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authvalue",
            "description": "auth value: username/password or token or custom headers"
          },
          "oauthConfig": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Oauthconfig",
            "description": "OAuth 2.0 configuration including grant_type, client_id, encrypted client_secret, URLs, and scopes"
          },
          "authUsername": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authusername",
            "description": "username for basic authentication"
          },
          "authPassword": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authpassword",
            "description": "password for basic authentication"
          },
          "authToken": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authtoken",
            "description": "token for bearer authentication"
          },
          "authHeaderKey": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authheaderkey",
            "description": "key for custom headers authentication"
          },
          "authHeaderValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authheadervalue",
            "description": "vallue for custom headers authentication"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorizing the gateway"
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "Team ID this gateway belongs to"
          },
          "team": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team",
            "description": "Name of the team that owns this resource"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the gateway owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Gateway visibility: private, team, or public",
            "default": "public"
          },
          "createdBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdby",
            "description": "Username who created this entity"
          },
          "createdFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdfromip",
            "description": "IP address of creator"
          },
          "createdVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdvia",
            "description": "Creation method: ui|api|import|federation"
          },
          "createdUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createduseragent",
            "description": "User agent of creation request"
          },
          "modifiedBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedby",
            "description": "Username who last modified this entity"
          },
          "modifiedFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedfromip",
            "description": "IP address of last modifier"
          },
          "modifiedVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedvia",
            "description": "Modification method"
          },
          "modifiedUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifieduseragent",
            "description": "User agent of modification request"
          },
          "importBatchId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Importbatchid",
            "description": "UUID of bulk import batch"
          },
          "federationSource": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Federationsource",
            "description": "Source gateway for federated entities"
          },
          "version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "Entity version for change tracking",
            "default": 1
          },
          "slug": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Slug",
            "description": "Slug for gateway endpoint URL"
          }
        },
        "type": "object",
        "required": [
          "name",
          "url"
        ],
        "title": "GatewayRead",
        "description": "Schema for reading gateway information.\n\nIncludes all gateway fields plus:\n- Database ID\n- Capabilities dictionary\n- Creation/update timestamps\n- enabled status\n- reachable status\n- Last seen timestamp\n- Authentication type: basic, bearer, headers, oauth\n- Authentication value: username/password or token or custom headers\n- OAuth configuration for OAuth 2.0 authentication\n\nAuto Populated fields:\n- Authentication username: for basic auth\n- Authentication password: for basic auth\n- Authentication token: for bearer auth\n- Authentication header key: for headers auth\n- Authentication header value: for headers auth",
        "nullable": true
      },
      "GatewayTestRequest": {
        "properties": {
          "method": {
            "type": "string",
            "title": "Method",
            "description": "HTTP method to test (GET, POST, etc.)"
          },
          "baseUrl": {
            "type": "string",
            "minLength": 1,
            "format": "uri",
            "title": "Baseurl",
            "description": "Base URL of the gateway to test"
          },
          "path": {
            "type": "string",
            "title": "Path",
            "description": "Path to append to the base URL"
          },
          "headers": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Headers",
            "description": "Optional headers for the request"
          },
          "body": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Body",
            "description": "Optional body for the request, can be a string or JSON object"
          }
        },
        "type": "object",
        "required": [
          "method",
          "baseUrl",
          "path"
        ],
        "title": "GatewayTestRequest",
        "description": "Schema for testing gateway connectivity.\n\nIncludes the HTTP method, base URL, path, optional headers, and body.",
        "nullable": true
      },
      "GatewayTestResponse": {
        "properties": {
          "statusCode": {
            "type": "integer",
            "title": "Statuscode",
            "description": "HTTP status code returned by the gateway"
          },
          "latencyMs": {
            "type": "integer",
            "title": "Latencyms",
            "description": "Latency of the request in milliseconds"
          },
          "body": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Body",
            "description": "Response body, can be a string or JSON object"
          }
        },
        "type": "object",
        "required": [
          "statusCode",
          "latencyMs"
        ],
        "title": "GatewayTestResponse",
        "description": "Schema for the response from a gateway test request.\n\nContains:\n- HTTP status code\n- Latency in milliseconds\n- Optional response body, which can be a string or JSON object",
        "nullable": true
      },
      "GatewayUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Unique name for the gateway"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "null"
              }
            ],
            "title": "Url",
            "description": "Gateway endpoint URL"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Gateway description"
          },
          "transport": {
            "type": "string",
            "title": "Transport",
            "description": "Transport used by MCP server: SSE or STREAMABLEHTTP",
            "default": "SSE"
          },
          "passthroughHeaders": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Passthroughheaders",
            "description": "List of headers allowed to be passed through from client to target"
          },
          "authType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authtype",
            "description": "auth_type: basic, bearer, headers or None"
          },
          "authUsername": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authusername",
            "description": "username for basic authentication"
          },
          "authPassword": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authpassword",
            "description": "password for basic authentication"
          },
          "authToken": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authtoken",
            "description": "token for bearer authentication"
          },
          "authHeaderKey": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authheaderkey",
            "description": "key for custom headers authentication"
          },
          "authHeaderValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authheadervalue",
            "description": "value for custom headers authentication"
          },
          "authHeaders": {
            "anyOf": [
              {
                "items": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authheaders",
            "description": "List of custom headers for authentication"
          },
          "authValue": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Authvalue"
          },
          "oauthConfig": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Oauthconfig",
            "description": "OAuth 2.0 configuration including grant_type, client_id, encrypted client_secret, URLs, and scopes"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the gateway"
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "Team ID this gateway belongs to"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the gateway owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Gateway visibility: private, team, or public"
          }
        },
        "type": "object",
        "title": "GatewayUpdate",
        "description": "Schema for updating an existing federation gateway.\n\nSimilar to GatewayCreate but all fields are optional to allow partial updates.",
        "nullable": true
      },
      "GlobalConfigRead": {
        "properties": {
          "passthrough_headers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Passthrough Headers",
            "description": "List of headers allowed to be passed through globally"
          }
        },
        "type": "object",
        "title": "GlobalConfigRead",
        "description": "Schema for reading global configuration.\n\nAttributes:\n    passthrough_headers (Optional[List[str]]): List of headers allowed to be passed through globally"
      },
      "GlobalConfigUpdate": {
        "properties": {
          "passthrough_headers": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Passthrough Headers",
            "description": "List of headers allowed to be passed through globally"
          }
        },
        "type": "object",
        "title": "GlobalConfigUpdate",
        "description": "Schema for updating global configuration.\n\nAttributes:\n    passthrough_headers (Optional[List[str]]): List of headers allowed to be passed through globally"
      },
      "GrpcServiceCreate": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "Unique name for the gRPC service"
          },
          "target": {
            "type": "string",
            "title": "Target",
            "description": "gRPC server target address (host:port)"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Description of the gRPC service"
          },
          "reflection_enabled": {
            "type": "boolean",
            "title": "Reflection Enabled",
            "description": "Enable gRPC server reflection",
            "default": true
          },
          "tls_enabled": {
            "type": "boolean",
            "title": "Tls Enabled",
            "description": "Enable TLS for gRPC connection",
            "default": false
          },
          "tls_cert_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tls Cert Path",
            "description": "Path to TLS certificate file"
          },
          "tls_key_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tls Key Path",
            "description": "Path to TLS key file"
          },
          "grpc_metadata": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Grpc Metadata",
            "description": "gRPC metadata headers"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorization"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "ID of the team that owns this resource"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Email of the user who owns this resource"
          },
          "visibility": {
            "type": "string",
            "title": "Visibility",
            "description": "Visibility level: private, team, or public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "name",
          "target"
        ],
        "title": "GrpcServiceCreate",
        "description": "Schema for creating a new gRPC service."
      },
      "GrpcServiceRead": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Unique service identifier"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Service name"
          },
          "slug": {
            "type": "string",
            "title": "Slug",
            "description": "URL-safe slug"
          },
          "target": {
            "type": "string",
            "title": "Target",
            "description": "gRPC server target (host:port)"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Service description"
          },
          "reflection_enabled": {
            "type": "boolean",
            "title": "Reflection Enabled",
            "description": "Reflection enabled"
          },
          "tls_enabled": {
            "type": "boolean",
            "title": "Tls Enabled",
            "description": "TLS enabled"
          },
          "tls_cert_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tls Cert Path",
            "description": "TLS certificate path"
          },
          "tls_key_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tls Key Path",
            "description": "TLS key path"
          },
          "grpc_metadata": {
            "additionalProperties": {
              "type": "string"
            },
            "type": "object",
            "title": "Grpc Metadata",
            "description": "gRPC metadata"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled",
            "description": "Service enabled"
          },
          "reachable": {
            "type": "boolean",
            "title": "Reachable",
            "description": "Service reachable"
          },
          "service_count": {
            "type": "integer",
            "title": "Service Count",
            "description": "Number of gRPC services discovered",
            "default": 0
          },
          "method_count": {
            "type": "integer",
            "title": "Method Count",
            "description": "Number of methods discovered",
            "default": 0
          },
          "discovered_services": {
            "additionalProperties": true,
            "type": "object",
            "title": "Discovered Services",
            "description": "Discovered service descriptors"
          },
          "last_reflection": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Reflection",
            "description": "Last reflection timestamp"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Service tags"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Last update timestamp"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Owner email"
          },
          "visibility": {
            "type": "string",
            "title": "Visibility",
            "description": "Visibility level",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "slug",
          "target",
          "reflection_enabled",
          "tls_enabled",
          "enabled",
          "reachable",
          "created_at",
          "updated_at"
        ],
        "title": "GrpcServiceRead",
        "description": "Schema for reading gRPC service information."
      },
      "GrpcServiceUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Service name"
          },
          "target": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Target",
            "description": "gRPC server target address"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Service description"
          },
          "reflection_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Reflection Enabled",
            "description": "Enable server reflection"
          },
          "tls_enabled": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tls Enabled",
            "description": "Enable TLS"
          },
          "tls_cert_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tls Cert Path",
            "description": "TLS certificate path"
          },
          "tls_key_path": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tls Key Path",
            "description": "TLS key path"
          },
          "grpc_metadata": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Grpc Metadata",
            "description": "gRPC metadata headers"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Service tags"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level"
          }
        },
        "type": "object",
        "title": "GrpcServiceUpdate",
        "description": "Schema for updating an existing gRPC service."
      },
      "HTTPValidationError": {
        "properties": {
          "detail": {
            "items": {
              "$ref": "#/components/schemas/ValidationError"
            },
            "type": "array",
            "title": "Detail"
          }
        },
        "type": "object",
        "title": "HTTPValidationError"
      },
      "Implementation": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name"
          },
          "version": {
            "type": "string",
            "title": "Version"
          }
        },
        "type": "object",
        "required": [
          "name",
          "version"
        ],
        "title": "Implementation",
        "description": "MCP implementation information.\n\nAttributes:\n    name (str): The name of the implementation.\n    version (str): The version of the implementation."
      },
      "InitializeResult": {
        "properties": {
          "protocolVersion": {
            "type": "string",
            "title": "Protocolversion"
          },
          "capabilities": {
            "$ref": "#/components/schemas/ServerCapabilities"
          },
          "serverInfo": {
            "$ref": "#/components/schemas/Implementation"
          },
          "instructions": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Instructions"
          }
        },
        "type": "object",
        "required": [
          "protocolVersion",
          "capabilities",
          "serverInfo"
        ],
        "title": "InitializeResult",
        "description": "Server's response to the initialization request.\n\nAttributes:\n    protocol_version (str): The protocol version used.\n    capabilities (ServerCapabilities): The server's capabilities.\n    server_info (Implementation): The server's implementation information.\n    instructions (Optional[str]): Optional instructions for the client."
      },
      "JsonPathModifier": {
        "properties": {
          "jsonpath": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Jsonpath",
            "description": "JSONPath expression for querying JSON data."
          },
          "mapping": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mapping",
            "description": "Mapping of fields from original data to output."
          }
        },
        "type": "object",
        "title": "JsonPathModifier",
        "description": "Schema for JSONPath queries.\n\nProvides the structure for parsing JSONPath queries and optional mapping.",
        "nullable": true
      },
      "ListResourceTemplatesResult": {
        "properties": {
          "_meta": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Meta",
            "description": "This result property is reserved by the protocol to allow clients and servers to attach additional metadata to their responses."
          },
          "next_cursor": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Next Cursor",
            "description": "An opaque token representing the pagination position after the last returned result.\nIf present, there may be more results available."
          },
          "resource_templates": {
            "items": {
              "$ref": "#/components/schemas/ResourceTemplate"
            },
            "type": "array",
            "title": "Resource Templates",
            "description": "List of resource templates available on the server"
          }
        },
        "type": "object",
        "title": "ListResourceTemplatesResult",
        "description": "The server's response to a resources/templates/list request from the client.\n\nAttributes:\n    meta (Optional[Dict[str, Any]]): Reserved property for metadata.\n    next_cursor (Optional[str]): Pagination cursor for the next page of results.\n    resource_templates (List[ResourceTemplate]): List of resource templates."
      },
      "LoginRequest": {
        "properties": {
          "email": {
            "anyOf": [
              {
                "type": "string",
                "format": "email"
              },
              {
                "type": "null"
              }
            ],
            "title": "Email"
          },
          "username": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Username"
          },
          "password": {
            "type": "string",
            "title": "Password"
          }
        },
        "type": "object",
        "required": [
          "password"
        ],
        "title": "LoginRequest",
        "description": "Login request supporting both email and username formats.\n\nAttributes:\n    email: User email address (can also accept 'username' field for compatibility)\n    password: User password"
      },
      "PermissionCheckRequest": {
        "properties": {
          "user_email": {
            "type": "string",
            "title": "User Email",
            "description": "User email to check"
          },
          "permission": {
            "type": "string",
            "title": "Permission",
            "description": "Permission to verify"
          },
          "resource_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Resource Type",
            "description": "Resource type"
          },
          "resource_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Resource Id",
            "description": "Resource ID"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team context"
          }
        },
        "type": "object",
        "required": [
          "user_email",
          "permission"
        ],
        "title": "PermissionCheckRequest",
        "description": "Schema for permission check request.\n\nAttributes:\n    user_email: User to check\n    permission: Permission to verify\n    resource_type: Optional resource type\n    resource_id: Optional resource ID\n    team_id: Optional team context\n\nExamples:\n    >>> request = PermissionCheckRequest(\n    ...     user_email=\"user@example.com\",\n    ...     permission=\"tools.create\",\n    ...     resource_type=\"tools\"\n    ... )\n    >>> request.permission\n    'tools.create'"
      },
      "PermissionCheckResponse": {
        "properties": {
          "user_email": {
            "type": "string",
            "title": "User Email",
            "description": "User email checked"
          },
          "permission": {
            "type": "string",
            "title": "Permission",
            "description": "Permission checked"
          },
          "granted": {
            "type": "boolean",
            "title": "Granted",
            "description": "Whether permission was granted"
          },
          "checked_at": {
            "type": "string",
            "format": "date-time",
            "title": "Checked At",
            "description": "When check was performed"
          },
          "checked_by": {
            "type": "string",
            "title": "Checked By",
            "description": "Who performed the check"
          }
        },
        "type": "object",
        "required": [
          "user_email",
          "permission",
          "granted",
          "checked_at",
          "checked_by"
        ],
        "title": "PermissionCheckResponse",
        "description": "Schema for permission check response.\n\nAttributes:\n    user_email: User checked\n    permission: Permission checked\n    granted: Whether permission was granted\n    checked_at: When check was performed\n    checked_by: Who performed the check\n\nExamples:\n    >>> response = PermissionCheckResponse(\n    ...     user_email=\"user@example.com\",\n    ...     permission=\"tools.create\",\n    ...     granted=True,\n    ...     checked_at=datetime.now(),\n    ...     checked_by=\"admin@example.com\"\n    ... )\n    >>> response.granted\n    True"
      },
      "PermissionListResponse": {
        "properties": {
          "all_permissions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "All Permissions",
            "description": "All available permissions"
          },
          "permissions_by_resource": {
            "additionalProperties": {
              "items": {
                "type": "string"
              },
              "type": "array"
            },
            "type": "object",
            "title": "Permissions By Resource",
            "description": "Permissions by resource type"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of permissions"
          }
        },
        "type": "object",
        "required": [
          "all_permissions",
          "permissions_by_resource",
          "total_count"
        ],
        "title": "PermissionListResponse",
        "description": "Schema for available permissions list.\n\nAttributes:\n    all_permissions: List of all available permissions\n    permissions_by_resource: Permissions grouped by resource type\n    total_count: Total number of permissions\n\nExamples:\n    >>> response = PermissionListResponse(\n    ...     all_permissions=[\"users.create\", \"tools.read\"],\n    ...     permissions_by_resource={\"users\": [\"users.create\"], \"tools\": [\"tools.read\"]},\n    ...     total_count=2\n    ... )\n    >>> response.total_count\n    2"
      },
      "PluginDetail": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique plugin name"
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Plugin description",
            "default": ""
          },
          "author": {
            "type": "string",
            "title": "Author",
            "description": "Plugin author",
            "default": "Unknown"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Plugin version",
            "default": "0.0.0"
          },
          "mode": {
            "type": "string",
            "title": "Mode",
            "description": "Plugin mode: enforce, permissive, or disabled"
          },
          "priority": {
            "type": "integer",
            "title": "Priority",
            "description": "Plugin execution priority (lower = higher priority)"
          },
          "hooks": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Hooks",
            "description": "Hook points where plugin executes"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Plugin tags for categorization"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Plugin status: enabled or disabled"
          },
          "config_summary": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config Summary",
            "description": "Summary of plugin configuration"
          },
          "kind": {
            "type": "string",
            "title": "Kind",
            "description": "Plugin type or class",
            "default": ""
          },
          "namespace": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Namespace",
            "description": "Plugin namespace"
          },
          "conditions": {
            "items": {},
            "type": "array",
            "title": "Conditions",
            "description": "Conditions for plugin execution"
          },
          "config": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config",
            "description": "Full plugin configuration"
          },
          "manifest": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Manifest",
            "description": "Plugin manifest information"
          }
        },
        "type": "object",
        "required": [
          "name",
          "mode",
          "priority",
          "status"
        ],
        "title": "PluginDetail",
        "description": "Detailed plugin information including full configuration."
      },
      "PluginListResponse": {
        "properties": {
          "plugins": {
            "items": {
              "$ref": "#/components/schemas/PluginSummary"
            },
            "type": "array",
            "title": "Plugins",
            "description": "List of plugins"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of plugins"
          },
          "enabled_count": {
            "type": "integer",
            "title": "Enabled Count",
            "description": "Number of enabled plugins",
            "default": 0
          },
          "disabled_count": {
            "type": "integer",
            "title": "Disabled Count",
            "description": "Number of disabled plugins",
            "default": 0
          }
        },
        "type": "object",
        "required": [
          "plugins",
          "total"
        ],
        "title": "PluginListResponse",
        "description": "Response for plugin list endpoint."
      },
      "PluginStatsResponse": {
        "properties": {
          "total_plugins": {
            "type": "integer",
            "title": "Total Plugins",
            "description": "Total number of plugins"
          },
          "enabled_plugins": {
            "type": "integer",
            "title": "Enabled Plugins",
            "description": "Number of enabled plugins"
          },
          "disabled_plugins": {
            "type": "integer",
            "title": "Disabled Plugins",
            "description": "Number of disabled plugins"
          },
          "plugins_by_hook": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Plugins By Hook",
            "description": "Plugin count by hook type"
          },
          "plugins_by_mode": {
            "additionalProperties": {
              "type": "integer"
            },
            "type": "object",
            "title": "Plugins By Mode",
            "description": "Plugin count by mode"
          }
        },
        "type": "object",
        "required": [
          "total_plugins",
          "enabled_plugins",
          "disabled_plugins"
        ],
        "title": "PluginStatsResponse",
        "description": "Response for plugin statistics endpoint."
      },
      "PluginSummary": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique plugin name"
          },
          "description": {
            "type": "string",
            "title": "Description",
            "description": "Plugin description",
            "default": ""
          },
          "author": {
            "type": "string",
            "title": "Author",
            "description": "Plugin author",
            "default": "Unknown"
          },
          "version": {
            "type": "string",
            "title": "Version",
            "description": "Plugin version",
            "default": "0.0.0"
          },
          "mode": {
            "type": "string",
            "title": "Mode",
            "description": "Plugin mode: enforce, permissive, or disabled"
          },
          "priority": {
            "type": "integer",
            "title": "Priority",
            "description": "Plugin execution priority (lower = higher priority)"
          },
          "hooks": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Hooks",
            "description": "Hook points where plugin executes"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Plugin tags for categorization"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Plugin status: enabled or disabled"
          },
          "config_summary": {
            "additionalProperties": true,
            "type": "object",
            "title": "Config Summary",
            "description": "Summary of plugin configuration"
          }
        },
        "type": "object",
        "required": [
          "name",
          "mode",
          "priority",
          "status"
        ],
        "title": "PluginSummary",
        "description": "Summary information for a plugin in list views."
      },
      "PromptArgument": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Argument name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Argument description"
          },
          "required": {
            "type": "boolean",
            "title": "Required",
            "description": "Whether argument is required",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "PromptArgument",
        "description": "Schema for prompt template arguments.\n\nDefines:\n- Argument name\n- Optional description\n- Required flag",
        "nullable": true
      },
      "PromptCreate": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name for the prompt"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Prompt description"
          },
          "template": {
            "type": "string",
            "title": "Template",
            "description": "Prompt template text"
          },
          "arguments": {
            "items": {
              "$ref": "#/components/schemas/PromptArgument"
            },
            "type": "array",
            "title": "Arguments",
            "description": "List of arguments for the template"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the prompt"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID for resource organization"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Email of the prompt owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "name",
          "template"
        ],
        "title": "PromptCreate",
        "description": "Schema for creating a new prompt.\n\nAttributes:\n    model_config (ConfigDict): Configuration for the model.\n    name (str): Unique name for the prompt.\n    description (Optional[str]): Optional description of the prompt.\n    template (str): Template text for the prompt.\n    arguments (List[PromptArgument]): List of arguments for the template."
      },
      "PromptMetrics": {
        "properties": {
          "totalExecutions": {
            "type": "integer",
            "title": "Totalexecutions",
            "description": "Total number of prompt invocations"
          },
          "successfulExecutions": {
            "type": "integer",
            "title": "Successfulexecutions",
            "description": "Number of successful prompt invocations"
          },
          "failedExecutions": {
            "type": "integer",
            "title": "Failedexecutions",
            "description": "Number of failed prompt invocations"
          },
          "failureRate": {
            "type": "number",
            "title": "Failurerate",
            "description": "Failure rate (failed invocations / total invocations)"
          },
          "minResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Minresponsetime",
            "description": "Minimum response time in seconds"
          },
          "maxResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Maxresponsetime",
            "description": "Maximum response time in seconds"
          },
          "avgResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avgresponsetime",
            "description": "Average response time in seconds"
          },
          "lastExecutionTime": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastexecutiontime",
            "description": "Timestamp of the most recent invocation"
          }
        },
        "type": "object",
        "required": [
          "totalExecutions",
          "successfulExecutions",
          "failedExecutions",
          "failureRate"
        ],
        "title": "PromptMetrics",
        "description": "Represents the performance and execution statistics for a prompt.\n\nAttributes:\n    total_executions (int): Total number of prompt invocations.\n    successful_executions (int): Number of successful prompt invocations.\n    failed_executions (int): Number of failed prompt invocations.\n    failure_rate (float): Failure rate (failed invocations / total invocations).\n    min_response_time (Optional[float]): Minimum response time in seconds.\n    max_response_time (Optional[float]): Maximum response time in seconds.\n    avg_response_time (Optional[float]): Average response time in seconds.\n    last_execution_time (Optional[datetime]): Timestamp of the most recent invocation.",
        "nullable": true
      },
      "PromptRead": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "template": {
            "type": "string",
            "title": "Template"
          },
          "arguments": {
            "items": {
              "$ref": "#/components/schemas/PromptArgument"
            },
            "type": "array",
            "title": "Arguments"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "Updatedat"
          },
          "isActive": {
            "type": "boolean",
            "title": "Isactive"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorizing the prompt"
          },
          "metrics": {
            "$ref": "#/components/schemas/PromptMetrics"
          },
          "createdBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdby",
            "description": "Username who created this entity"
          },
          "createdFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdfromip",
            "description": "IP address of creator"
          },
          "createdVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdvia",
            "description": "Creation method: ui|api|import|federation"
          },
          "createdUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createduseragent",
            "description": "User agent of creation request"
          },
          "modifiedBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedby",
            "description": "Username who last modified this entity"
          },
          "modifiedFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedfromip",
            "description": "IP address of last modifier"
          },
          "modifiedVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedvia",
            "description": "Modification method"
          },
          "modifiedUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifieduseragent",
            "description": "User agent of modification request"
          },
          "importBatchId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Importbatchid",
            "description": "UUID of bulk import batch"
          },
          "federationSource": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Federationsource",
            "description": "Source gateway for federated entities"
          },
          "version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "Entity version for change tracking",
            "default": 1
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "ID of the team that owns this resource"
          },
          "team": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team",
            "description": "Name of the team that owns this resource"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the user who owns this resource"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level: private, team, or public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "description",
          "template",
          "arguments",
          "createdAt",
          "updatedAt",
          "isActive",
          "metrics"
        ],
        "title": "PromptRead",
        "description": "Schema for reading prompt information.\n\nIncludes all prompt fields plus:\n- Database ID\n- Creation/update timestamps\n- Active status\n- Metrics: Aggregated metrics for the prompt invocations.",
        "nullable": true
      },
      "PromptUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Unique name for the prompt"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Prompt description"
          },
          "template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Template",
            "description": "Prompt template text"
          },
          "arguments": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/PromptArgument"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Arguments",
            "description": "List of arguments for the template"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the prompt"
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "Team ID for resource organization"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the prompt owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)"
          }
        },
        "type": "object",
        "title": "PromptUpdate",
        "description": "Schema for updating an existing prompt.\n\nSimilar to PromptCreate but all fields are optional to allow partial updates.",
        "nullable": true
      },
      "ResourceCreate": {
        "properties": {
          "uri": {
            "type": "string",
            "title": "Uri",
            "description": "Unique URI for the resource"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Human-readable resource name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Resource description"
          },
          "mime_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mime Type",
            "description": "Resource MIME type"
          },
          "template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Template",
            "description": "URI template for parameterized resources"
          },
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "format": "binary"
              }
            ],
            "title": "Content",
            "description": "Resource content (text or binary)"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the resource"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID for resource organization"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Email of the resource owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "uri",
          "name",
          "content"
        ],
        "title": "ResourceCreate",
        "description": "Schema for creating a new resource.\n\nAttributes:\n    model_config (ConfigDict): Configuration for the model.\n    uri (str): Unique URI for the resource.\n    name (str): Human-readable name for the resource.\n    description (Optional[str]): Optional description of the resource.\n    mime_type (Optional[str]): Optional MIME type of the resource.\n    template (Optional[str]): Optional URI template for parameterized resources.\n    content (Union[str, bytes]): Content of the resource, which can be text or binary."
      },
      "ResourceMetrics": {
        "properties": {
          "totalExecutions": {
            "type": "integer",
            "title": "Totalexecutions",
            "description": "Total number of resource invocations"
          },
          "successfulExecutions": {
            "type": "integer",
            "title": "Successfulexecutions",
            "description": "Number of successful resource invocations"
          },
          "failedExecutions": {
            "type": "integer",
            "title": "Failedexecutions",
            "description": "Number of failed resource invocations"
          },
          "failureRate": {
            "type": "number",
            "title": "Failurerate",
            "description": "Failure rate (failed invocations / total invocations)"
          },
          "minResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Minresponsetime",
            "description": "Minimum response time in seconds"
          },
          "maxResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Maxresponsetime",
            "description": "Maximum response time in seconds"
          },
          "avgResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avgresponsetime",
            "description": "Average response time in seconds"
          },
          "lastExecutionTime": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastexecutiontime",
            "description": "Timestamp of the most recent invocation"
          }
        },
        "type": "object",
        "required": [
          "totalExecutions",
          "successfulExecutions",
          "failedExecutions",
          "failureRate"
        ],
        "title": "ResourceMetrics",
        "description": "Represents the performance and execution statistics for a resource.\n\nAttributes:\n    total_executions (int): Total number of resource invocations.\n    successful_executions (int): Number of successful resource invocations.\n    failed_executions (int): Number of failed resource invocations.\n    failure_rate (float): Failure rate (failed invocations / total invocations).\n    min_response_time (Optional[float]): Minimum response time in seconds.\n    max_response_time (Optional[float]): Maximum response time in seconds.\n    avg_response_time (Optional[float]): Average response time in seconds.\n    last_execution_time (Optional[datetime]): Timestamp of the most recent invocation.",
        "nullable": true
      },
      "ResourceRead": {
        "properties": {
          "id": {
            "type": "integer",
            "title": "Id"
          },
          "uri": {
            "type": "string",
            "title": "Uri"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "mimeType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mimetype"
          },
          "size": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Size"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "Updatedat"
          },
          "isActive": {
            "type": "boolean",
            "title": "Isactive"
          },
          "metrics": {
            "$ref": "#/components/schemas/ResourceMetrics"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorizing the resource"
          },
          "createdBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdby",
            "description": "Username who created this entity"
          },
          "createdFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdfromip",
            "description": "IP address of creator"
          },
          "createdVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdvia",
            "description": "Creation method: ui|api|import|federation"
          },
          "createdUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createduseragent",
            "description": "User agent of creation request"
          },
          "modifiedBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedby",
            "description": "Username who last modified this entity"
          },
          "modifiedFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedfromip",
            "description": "IP address of last modifier"
          },
          "modifiedVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedvia",
            "description": "Modification method"
          },
          "modifiedUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifieduseragent",
            "description": "User agent of modification request"
          },
          "importBatchId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Importbatchid",
            "description": "UUID of bulk import batch"
          },
          "federationSource": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Federationsource",
            "description": "Source gateway for federated entities"
          },
          "version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "Entity version for change tracking",
            "default": 1
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "ID of the team that owns this resource"
          },
          "team": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team",
            "description": "Name of the team that owns this resource"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the user who owns this resource"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level: private, team, or public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "id",
          "uri",
          "name",
          "description",
          "mimeType",
          "size",
          "createdAt",
          "updatedAt",
          "isActive",
          "metrics"
        ],
        "title": "ResourceRead",
        "description": "Schema for reading resource information.\n\nIncludes all resource fields plus:\n- Database ID\n- Content size\n- Creation/update timestamps\n- Active status\n- Metrics: Aggregated metrics for the resource invocations.",
        "nullable": true
      },
      "ResourceTemplate": {
        "properties": {
          "uri_template": {
            "type": "string",
            "title": "Uri Template"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "mime_type": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mime Type"
          }
        },
        "type": "object",
        "required": [
          "uri_template",
          "name"
        ],
        "title": "ResourceTemplate",
        "description": "A template for constructing resource URIs.\n\nAttributes:\n    uri_template (str): The URI template string.\n    name (str): The unique name of the template.\n    description (Optional[str]): A description of the template.\n    mime_type (Optional[str]): The MIME type associated with the template."
      },
      "ResourceUpdate": {
        "properties": {
          "uri": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Uri",
            "description": "Unique URI for the resource"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Human-readable resource name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Resource description"
          },
          "mimeType": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Mimetype",
            "description": "Resource MIME type"
          },
          "template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Template",
            "description": "URI template for parameterized resources"
          },
          "content": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "format": "binary"
              },
              {
                "type": "null"
              }
            ],
            "title": "Content",
            "description": "Resource content (text or binary)"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the resource"
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "Team ID for resource organization"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the resource owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)"
          }
        },
        "type": "object",
        "title": "ResourceUpdate",
        "description": "Schema for updating an existing resource.\n\nSimilar to ResourceCreate but URI is not required and all fields are optional.",
        "nullable": true
      },
      "RoleCreateRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "title": "Name",
            "description": "Unique role name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Role description"
          },
          "scope": {
            "type": "string",
            "pattern": "^(global|team|personal)$",
            "title": "Scope",
            "description": "Role scope"
          },
          "permissions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Permissions",
            "description": "List of permission strings"
          },
          "inherits_from": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inherits From",
            "description": "Parent role ID for inheritance"
          },
          "is_system_role": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is System Role",
            "description": "Whether this is a system role",
            "default": false
          }
        },
        "type": "object",
        "required": [
          "name",
          "scope",
          "permissions"
        ],
        "title": "RoleCreateRequest",
        "description": "Schema for creating a new role.\n\nAttributes:\n    name: Unique role name\n    description: Role description\n    scope: Role scope (global, team, personal)\n    permissions: List of permission strings\n    inherits_from: Optional parent role ID\n    is_system_role: Whether this is a system role\n\nExamples:\n    >>> request = RoleCreateRequest(\n    ...     name=\"team_admin\",\n    ...     description=\"Team administrator with member management\",\n    ...     scope=\"team\",\n    ...     permissions=[\"teams.manage_members\", \"resources.create\"]\n    ... )\n    >>> request.name\n    'team_admin'"
      },
      "RoleResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Role identifier"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Role name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Role description"
          },
          "scope": {
            "type": "string",
            "title": "Scope",
            "description": "Role scope"
          },
          "permissions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Permissions",
            "description": "Direct permissions"
          },
          "effective_permissions": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Effective Permissions",
            "description": "All permissions including inherited"
          },
          "inherits_from": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inherits From",
            "description": "Parent role ID"
          },
          "created_by": {
            "type": "string",
            "title": "Created By",
            "description": "Creator email"
          },
          "is_system_role": {
            "type": "boolean",
            "title": "Is System Role",
            "description": "Whether system role"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether role is active"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Update timestamp"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "scope",
          "permissions",
          "created_by",
          "is_system_role",
          "is_active",
          "created_at",
          "updated_at"
        ],
        "title": "RoleResponse",
        "description": "Schema for role response.\n\nAttributes:\n    id: Role identifier\n    name: Role name\n    description: Role description\n    scope: Role scope\n    permissions: List of permissions\n    effective_permissions: All permissions including inherited\n    inherits_from: Parent role ID\n    created_by: Creator email\n    is_system_role: Whether system role\n    is_active: Whether role is active\n    created_at: Creation timestamp\n    updated_at: Update timestamp\n\nExamples:\n    >>> role = RoleResponse(\n    ...     id=\"role-123\",\n    ...     name=\"admin\",\n    ...     scope=\"global\",\n    ...     permissions=[\"*\"],\n    ...     effective_permissions=[\"*\"],\n    ...     created_by=\"admin@example.com\",\n    ...     is_system_role=True,\n    ...     is_active=True,\n    ...     created_at=datetime.now(),\n    ...     updated_at=datetime.now()\n    ... )\n    >>> role.name\n    'admin'"
      },
      "RoleUpdateRequest": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Role name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Role description"
          },
          "permissions": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Permissions",
            "description": "List of permission strings"
          },
          "inherits_from": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inherits From",
            "description": "Parent role ID for inheritance"
          },
          "is_active": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Is Active",
            "description": "Whether role is active"
          }
        },
        "type": "object",
        "title": "RoleUpdateRequest",
        "description": "Schema for updating an existing role.\n\nAttributes:\n    name: Optional new name\n    description: Optional new description\n    permissions: Optional new permissions list\n    inherits_from: Optional new parent role\n    is_active: Optional active status\n\nExamples:\n    >>> request = RoleUpdateRequest(\n    ...     description=\"Updated role description\",\n    ...     permissions=[\"new.permission\"]\n    ... )\n    >>> request.description\n    'Updated role description'"
      },
      "Root": {
        "properties": {
          "uri": {
            "type": "string",
            "minLength": 1,
            "format": "uri",
            "title": "Uri",
            "description": "Unique identifier for the root"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Optional human-readable name"
          }
        },
        "type": "object",
        "required": [
          "uri"
        ],
        "title": "Root",
        "description": "A root directory or file.\n\nAttributes:\n    uri (Union[FileUrl, AnyUrl]): The unique identifier for the root.\n    name (Optional[str]): An optional human-readable name."
      },
      "ServerCapabilities": {
        "properties": {
          "prompts": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "boolean"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Prompts"
          },
          "resources": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "boolean"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Resources"
          },
          "tools": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "boolean"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tools"
          },
          "logging": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Logging"
          },
          "experimental": {
            "anyOf": [
              {
                "additionalProperties": {
                  "additionalProperties": true,
                  "type": "object"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Experimental"
          }
        },
        "type": "object",
        "title": "ServerCapabilities",
        "description": "Capabilities that a server may support.\n\nAttributes:\n    prompts (Optional[Dict[str, bool]]): Capability for prompt support.\n    resources (Optional[Dict[str, bool]]): Capability for resource support.\n    tools (Optional[Dict[str, bool]]): Capability for tool support.\n    logging (Optional[Dict[str, Any]]): Capability for logging support.\n    experimental (Optional[Dict[str, Dict[str, Any]]]): Experimental capabilities."
      },
      "ServerCreate": {
        "properties": {
          "id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Id",
            "description": "Custom UUID for the server (if not provided, one will be generated)"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The server's name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Server description"
          },
          "icon": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Icon",
            "description": "URL for the server's icon"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the server"
          },
          "associated_tools": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associated Tools",
            "description": "Comma-separated tool IDs"
          },
          "associated_resources": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associated Resources",
            "description": "Comma-separated resource IDs"
          },
          "associated_prompts": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associated Prompts",
            "description": "Comma-separated prompt IDs"
          },
          "associated_a2a_agents": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associated A2A Agents",
            "description": "Comma-separated A2A agent IDs"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID for resource organization"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Email of the server owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ServerCreate",
        "description": "Schema for creating a new server.\n\nAttributes:\n    model_config (ConfigDict): Configuration for the model, such as stripping whitespace from strings.\n    name (str): The server's name.\n    description (Optional[str]): Optional description of the server.\n    icon (Optional[str]): Optional URL for the server's icon.\n    associated_tools (Optional[List[str]]): Optional list of associated tool IDs.\n    associated_resources (Optional[List[str]]): Optional list of associated resource IDs.\n    associated_prompts (Optional[List[str]]): Optional list of associated prompt IDs."
      },
      "ServerMetrics": {
        "properties": {
          "totalExecutions": {
            "type": "integer",
            "title": "Totalexecutions",
            "description": "Total number of server invocations"
          },
          "successfulExecutions": {
            "type": "integer",
            "title": "Successfulexecutions",
            "description": "Number of successful server invocations"
          },
          "failedExecutions": {
            "type": "integer",
            "title": "Failedexecutions",
            "description": "Number of failed server invocations"
          },
          "failureRate": {
            "type": "number",
            "title": "Failurerate",
            "description": "Failure rate (failed invocations / total invocations)"
          },
          "minResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Minresponsetime",
            "description": "Minimum response time in seconds"
          },
          "maxResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Maxresponsetime",
            "description": "Maximum response time in seconds"
          },
          "avgResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avgresponsetime",
            "description": "Average response time in seconds"
          },
          "lastExecutionTime": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastexecutiontime",
            "description": "Timestamp of the most recent invocation"
          }
        },
        "type": "object",
        "required": [
          "totalExecutions",
          "successfulExecutions",
          "failedExecutions",
          "failureRate"
        ],
        "title": "ServerMetrics",
        "description": "Represents the performance and execution statistics for a server.\n\nAttributes:\n    total_executions (int): Total number of server invocations.\n    successful_executions (int): Number of successful server invocations.\n    failed_executions (int): Number of failed server invocations.\n    failure_rate (float): Failure rate (failed invocations / total invocations).\n    min_response_time (Optional[float]): Minimum response time in seconds.\n    max_response_time (Optional[float]): Maximum response time in seconds.\n    avg_response_time (Optional[float]): Average response time in seconds.\n    last_execution_time (Optional[datetime]): Timestamp of the most recent invocation.",
        "nullable": true
      },
      "ServerRead": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "icon": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Icon"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "Updatedat"
          },
          "isActive": {
            "type": "boolean",
            "title": "Isactive"
          },
          "associatedTools": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Associatedtools",
            "default": []
          },
          "associatedResources": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Associatedresources",
            "default": []
          },
          "associatedPrompts": {
            "items": {
              "type": "integer"
            },
            "type": "array",
            "title": "Associatedprompts",
            "default": []
          },
          "associatedA2aAgents": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Associateda2Aagents",
            "default": []
          },
          "metrics": {
            "$ref": "#/components/schemas/ServerMetrics"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorizing the server"
          },
          "createdBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdby",
            "description": "Username who created this entity"
          },
          "createdFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdfromip",
            "description": "IP address of creator"
          },
          "createdVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdvia",
            "description": "Creation method: ui|api|import|federation"
          },
          "createdUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createduseragent",
            "description": "User agent of creation request"
          },
          "modifiedBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedby",
            "description": "Username who last modified this entity"
          },
          "modifiedFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedfromip",
            "description": "IP address of last modifier"
          },
          "modifiedVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedvia",
            "description": "Modification method"
          },
          "modifiedUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifieduseragent",
            "description": "User agent of modification request"
          },
          "importBatchId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Importbatchid",
            "description": "UUID of bulk import batch"
          },
          "federationSource": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Federationsource",
            "description": "Source gateway for federated entities"
          },
          "version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "Entity version for change tracking",
            "default": 1
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "ID of the team that owns this resource"
          },
          "team": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team",
            "description": "Name of the team that owns this resource"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the user who owns this resource"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level: private, team, or public",
            "default": "public"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "description",
          "icon",
          "createdAt",
          "updatedAt",
          "isActive",
          "metrics"
        ],
        "title": "ServerRead",
        "description": "Schema for reading server information.\n\nIncludes all server fields plus:\n- Database ID\n- Associated tool, resource, and prompt IDs\n- Creation/update timestamps\n- Active status\n- Metrics: Aggregated metrics for the server invocations.",
        "nullable": true
      },
      "ServerUpdate": {
        "properties": {
          "id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Id",
            "description": "Custom UUID for the server"
          },
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "The server's name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Server description"
          },
          "icon": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Icon",
            "description": "URL for the server's icon"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the server"
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "Team ID for resource organization"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the server owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)"
          },
          "associatedTools": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associatedtools",
            "description": "Comma-separated tool IDs"
          },
          "associatedResources": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associatedresources",
            "description": "Comma-separated resource IDs"
          },
          "associatedPrompts": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associatedprompts",
            "description": "Comma-separated prompt IDs"
          },
          "associatedA2aAgents": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Associateda2Aagents",
            "description": "Comma-separated A2A agent IDs"
          }
        },
        "type": "object",
        "title": "ServerUpdate",
        "description": "Schema for updating an existing server.\n\nAll fields are optional to allow partial updates.",
        "nullable": true
      },
      "SuccessResponse": {
        "properties": {
          "success": {
            "type": "boolean",
            "title": "Success",
            "description": "Operation success status",
            "default": true
          },
          "message": {
            "type": "string",
            "title": "Message",
            "description": "Human-readable success message"
          }
        },
        "type": "object",
        "required": [
          "message"
        ],
        "title": "SuccessResponse",
        "description": "Standard success response schema.\n\nAttributes:\n    success: Whether operation was successful\n    message: Human-readable success message\n\nExamples:\n    >>> response = SuccessResponse(\n    ...     success=True,\n    ...     message=\"Password changed successfully\"\n    ... )\n    >>> response.success\n    True\n    >>> response.message\n    'Password changed successfully'"
      },
      "TagInfo": {
        "properties": {
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The tag name"
          },
          "stats": {
            "$ref": "#/components/schemas/TagStats",
            "description": "Statistics for this tag"
          },
          "entities": {
            "anyOf": [
              {
                "items": {
                  "$ref": "#/components/schemas/TaggedEntity"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Entities",
            "description": "Entities that have this tag"
          }
        },
        "type": "object",
        "required": [
          "name",
          "stats"
        ],
        "title": "TagInfo",
        "description": "Information about a single tag.",
        "nullable": true
      },
      "TagStats": {
        "properties": {
          "tools": {
            "type": "integer",
            "title": "Tools",
            "description": "Number of tools with this tag",
            "default": 0
          },
          "resources": {
            "type": "integer",
            "title": "Resources",
            "description": "Number of resources with this tag",
            "default": 0
          },
          "prompts": {
            "type": "integer",
            "title": "Prompts",
            "description": "Number of prompts with this tag",
            "default": 0
          },
          "servers": {
            "type": "integer",
            "title": "Servers",
            "description": "Number of servers with this tag",
            "default": 0
          },
          "gateways": {
            "type": "integer",
            "title": "Gateways",
            "description": "Number of gateways with this tag",
            "default": 0
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total occurrences of this tag",
            "default": 0
          }
        },
        "type": "object",
        "title": "TagStats",
        "description": "Statistics for a single tag across all entity types.",
        "nullable": true
      },
      "TaggedEntity": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "The entity's ID"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "The entity's name"
          },
          "type": {
            "type": "string",
            "title": "Type",
            "description": "The entity type (tool, resource, prompt, server, gateway)"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "The entity's description"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "type"
        ],
        "title": "TaggedEntity",
        "description": "A simplified representation of an entity that has a tag.",
        "nullable": true
      },
      "TeamCreateRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "Team display name"
          },
          "slug": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 2,
                "pattern": "^[a-z0-9-]+$"
              },
              {
                "type": "null"
              }
            ],
            "title": "Slug",
            "description": "URL-friendly team identifier"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 1000
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Team description"
          },
          "visibility": {
            "type": "string",
            "enum": [
              "private",
              "public"
            ],
            "title": "Visibility",
            "description": "Team visibility level",
            "default": "private"
          },
          "max_members": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Members",
            "description": "Maximum number of team members"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "TeamCreateRequest",
        "description": "Schema for creating a new team.\n\nAttributes:\n    name: Team display name\n    slug: URL-friendly team identifier (optional, auto-generated if not provided)\n    description: Team description\n    visibility: Team visibility level\n    max_members: Maximum number of members allowed\n\nExamples:\n    >>> request = TeamCreateRequest(\n    ...     name=\"Engineering Team\",\n    ...     description=\"Software development team\"\n    ... )\n    >>> request.name\n    'Engineering Team'\n    >>> request.visibility\n    'private'\n    >>> request.slug is None\n    True\n    >>>\n    >>> # Test with all fields\n    >>> full_request = TeamCreateRequest(\n    ...     name=\"DevOps Team\",\n    ...     slug=\"devops-team\",\n    ...     description=\"Infrastructure and deployment team\",\n    ...     visibility=\"public\",\n    ...     max_members=50\n    ... )\n    >>> full_request.slug\n    'devops-team'\n    >>> full_request.max_members\n    50\n    >>> full_request.visibility\n    'public'\n    >>>\n    >>> # Test validation\n    >>> try:\n    ...     TeamCreateRequest(name=\"   \", description=\"test\")\n    ... except ValueError as e:\n    ...     \"empty\" in str(e).lower()\n    True\n    >>>\n    >>> # Test slug validation\n    >>> try:\n    ...     TeamCreateRequest(name=\"Test\", slug=\"Invalid_Slug\")\n    ... except ValueError:\n    ...     True\n    True\n    >>>\n    >>> # Test valid slug patterns\n    >>> valid_slug = TeamCreateRequest(name=\"Test\", slug=\"valid-slug-123\")\n    >>> valid_slug.slug\n    'valid-slug-123'"
      },
      "TeamDiscoveryResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Team ID"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Team name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Team description"
          },
          "member_count": {
            "type": "integer",
            "title": "Member Count",
            "description": "Number of team members"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Team creation timestamp"
          },
          "is_joinable": {
            "type": "boolean",
            "title": "Is Joinable",
            "description": "Whether the current user can join this team"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "member_count",
          "created_at",
          "is_joinable"
        ],
        "title": "TeamDiscoveryResponse",
        "description": "Schema for public team discovery response.\n\nProvides limited metadata about public teams for discovery purposes.\n\nAttributes:\n    id: Team ID\n    name: Team name\n    description: Team description\n    member_count: Number of members\n    created_at: Team creation timestamp\n    is_joinable: Whether the current user can join this team"
      },
      "TeamInvitationResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Invitation UUID"
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "description": "Team UUID"
          },
          "team_name": {
            "type": "string",
            "title": "Team Name",
            "description": "Team display name"
          },
          "email": {
            "type": "string",
            "title": "Email",
            "description": "Email address of invited user"
          },
          "role": {
            "type": "string",
            "title": "Role",
            "description": "Role the user will have when they accept"
          },
          "invited_by": {
            "type": "string",
            "title": "Invited By",
            "description": "Email of user who sent the invitation"
          },
          "invited_at": {
            "type": "string",
            "format": "date-time",
            "title": "Invited At",
            "description": "When the invitation was sent"
          },
          "expires_at": {
            "type": "string",
            "format": "date-time",
            "title": "Expires At",
            "description": "When the invitation expires"
          },
          "token": {
            "type": "string",
            "title": "Token",
            "description": "Invitation token"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether the invitation is active"
          },
          "is_expired": {
            "type": "boolean",
            "title": "Is Expired",
            "description": "Whether the invitation has expired"
          }
        },
        "type": "object",
        "required": [
          "id",
          "team_id",
          "team_name",
          "email",
          "role",
          "invited_by",
          "invited_at",
          "expires_at",
          "token",
          "is_active",
          "is_expired"
        ],
        "title": "TeamInvitationResponse",
        "description": "Schema for team invitation response data.\n\nAttributes:\n    id: Invitation UUID\n    team_id: Team UUID\n    team_name: Team display name\n    email: Email address of invited user\n    role: Role the user will have when they accept\n    invited_by: Email of user who sent the invitation\n    invited_at: When the invitation was sent\n    expires_at: When the invitation expires\n    token: Invitation token\n    is_active: Whether the invitation is active\n    is_expired: Whether the invitation has expired\n\nExamples:\n    >>> invitation = TeamInvitationResponse(\n    ...     id=\"invite-123\",\n    ...     team_id=\"team-123\",\n    ...     team_name=\"Engineering Team\",\n    ...     email=\"newuser@example.com\",\n    ...     role=\"member\",\n    ...     invited_by=\"admin@example.com\",\n    ...     invited_at=datetime.now(timezone.utc),\n    ...     expires_at=datetime.now(timezone.utc),\n    ...     token=\"invitation-token\",\n    ...     is_active=True,\n    ...     is_expired=False\n    ... )\n    >>> invitation.role\n    'member'"
      },
      "TeamInviteRequest": {
        "properties": {
          "email": {
            "type": "string",
            "format": "email",
            "title": "Email",
            "description": "Email address of user to invite"
          },
          "role": {
            "type": "string",
            "enum": [
              "owner",
              "member"
            ],
            "title": "Role",
            "description": "Role to assign to the user",
            "default": "member"
          }
        },
        "type": "object",
        "required": [
          "email"
        ],
        "title": "TeamInviteRequest",
        "description": "Schema for inviting users to a team.\n\nAttributes:\n    email: Email address of user to invite\n    role: Role to assign to the user\n\nExamples:\n    >>> invite = TeamInviteRequest(\n    ...     email=\"newuser@example.com\",\n    ...     role=\"member\"\n    ... )\n    >>> invite.email\n    'newuser@example.com'"
      },
      "TeamJoinRequest": {
        "properties": {
          "message": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 500
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Optional message to team owners"
          }
        },
        "type": "object",
        "title": "TeamJoinRequest",
        "description": "Schema for requesting to join a public team.\n\nAttributes:\n    message: Optional message to team owners"
      },
      "TeamJoinRequestResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Join request ID"
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "description": "Target team ID"
          },
          "team_name": {
            "type": "string",
            "title": "Team Name",
            "description": "Target team name"
          },
          "user_email": {
            "type": "string",
            "title": "User Email",
            "description": "Requesting user email"
          },
          "message": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Message",
            "description": "Request message"
          },
          "status": {
            "type": "string",
            "title": "Status",
            "description": "Request status"
          },
          "requested_at": {
            "type": "string",
            "format": "date-time",
            "title": "Requested At",
            "description": "Request timestamp"
          },
          "expires_at": {
            "type": "string",
            "format": "date-time",
            "title": "Expires At",
            "description": "Request expiration"
          }
        },
        "type": "object",
        "required": [
          "id",
          "team_id",
          "team_name",
          "user_email",
          "status",
          "requested_at",
          "expires_at"
        ],
        "title": "TeamJoinRequestResponse",
        "description": "Schema for team join request response.\n\nAttributes:\n    id: Join request ID\n    team_id: Target team ID\n    team_name: Target team name\n    user_email: Requesting user email\n    message: Request message\n    status: Request status (pending, approved, rejected)\n    requested_at: Request timestamp\n    expires_at: Request expiration timestamp"
      },
      "TeamListResponse": {
        "properties": {
          "teams": {
            "items": {
              "$ref": "#/components/schemas/TeamResponse"
            },
            "type": "array",
            "title": "Teams",
            "description": "List of teams"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of teams"
          }
        },
        "type": "object",
        "required": [
          "teams",
          "total"
        ],
        "title": "TeamListResponse",
        "description": "Schema for team list response.\n\nAttributes:\n    teams: List of teams\n    total: Total number of teams\n\nExamples:\n    >>> response = TeamListResponse(teams=[], total=0)\n    >>> response.total\n    0"
      },
      "TeamMemberResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Member UUID"
          },
          "team_id": {
            "type": "string",
            "title": "Team Id",
            "description": "Team UUID"
          },
          "user_email": {
            "type": "string",
            "title": "User Email",
            "description": "Member email address"
          },
          "role": {
            "type": "string",
            "title": "Role",
            "description": "Member role in the team"
          },
          "joined_at": {
            "type": "string",
            "format": "date-time",
            "title": "Joined At",
            "description": "When the member joined"
          },
          "invited_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Invited By",
            "description": "Email of user who invited this member"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether the membership is active"
          }
        },
        "type": "object",
        "required": [
          "id",
          "team_id",
          "user_email",
          "role",
          "joined_at",
          "is_active"
        ],
        "title": "TeamMemberResponse",
        "description": "Schema for team member response data.\n\nAttributes:\n    id: Member UUID\n    team_id: Team UUID\n    user_email: Member email address\n    role: Member role in the team\n    joined_at: When the member joined\n    invited_by: Email of user who invited this member\n    is_active: Whether the membership is active\n\nExamples:\n    >>> member = TeamMemberResponse(\n    ...     id=\"member-123\",\n    ...     team_id=\"team-123\",\n    ...     user_email=\"user@example.com\",\n    ...     role=\"member\",\n    ...     joined_at=datetime.now(timezone.utc),\n    ...     is_active=True\n    ... )\n    >>> member.role\n    'member'"
      },
      "TeamMemberUpdateRequest": {
        "properties": {
          "role": {
            "type": "string",
            "enum": [
              "owner",
              "member"
            ],
            "title": "Role",
            "description": "New role for the team member"
          }
        },
        "type": "object",
        "required": [
          "role"
        ],
        "title": "TeamMemberUpdateRequest",
        "description": "Schema for updating a team member's role.\n\nAttributes:\n    role: New role for the team member\n\nExamples:\n    >>> update = TeamMemberUpdateRequest(role=\"member\")\n    >>> update.role\n    'member'"
      },
      "TeamResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Team UUID"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Team display name"
          },
          "slug": {
            "type": "string",
            "title": "Slug",
            "description": "URL-friendly team identifier"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Team description"
          },
          "created_by": {
            "type": "string",
            "title": "Created By",
            "description": "Email of team creator"
          },
          "is_personal": {
            "type": "boolean",
            "title": "Is Personal",
            "description": "Whether this is a personal team"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Team visibility level"
          },
          "max_members": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Members",
            "description": "Maximum number of members allowed"
          },
          "member_count": {
            "type": "integer",
            "title": "Member Count",
            "description": "Current number of team members"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Team creation timestamp"
          },
          "updated_at": {
            "type": "string",
            "format": "date-time",
            "title": "Updated At",
            "description": "Last update timestamp"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether the team is active"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "slug",
          "created_by",
          "is_personal",
          "visibility",
          "member_count",
          "created_at",
          "updated_at",
          "is_active"
        ],
        "title": "TeamResponse",
        "description": "Schema for team response data.\n\nAttributes:\n    id: Team UUID\n    name: Team display name\n    slug: URL-friendly team identifier\n    description: Team description\n    created_by: Email of team creator\n    is_personal: Whether this is a personal team\n    visibility: Team visibility level\n    max_members: Maximum number of members allowed\n    member_count: Current number of team members\n    created_at: Team creation timestamp\n    updated_at: Last update timestamp\n    is_active: Whether the team is active\n\nExamples:\n    >>> team = TeamResponse(\n    ...     id=\"team-123\",\n    ...     name=\"Engineering Team\",\n    ...     slug=\"engineering-team\",\n    ...     created_by=\"admin@example.com\",\n    ...     is_personal=False,\n    ...     visibility=\"private\",\n    ...     member_count=5,\n    ...     created_at=datetime.now(timezone.utc),\n    ...     updated_at=datetime.now(timezone.utc),\n    ...     is_active=True\n    ... )\n    >>> team.name\n    'Engineering Team'"
      },
      "TeamUpdateRequest": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Team display name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 1000
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Team description"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "private",
                  "public"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Team visibility level"
          },
          "max_members": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Max Members",
            "description": "Maximum number of team members"
          }
        },
        "type": "object",
        "title": "TeamUpdateRequest",
        "description": "Schema for updating a team.\n\nAttributes:\n    name: Team display name\n    description: Team description\n    visibility: Team visibility level\n    max_members: Maximum number of members allowed\n\nExamples:\n    >>> request = TeamUpdateRequest(\n    ...     name=\"Updated Engineering Team\",\n    ...     description=\"Updated description\"\n    ... )\n    >>> request.name\n    'Updated Engineering Team'"
      },
      "TokenCreateRequest": {
        "properties": {
          "name": {
            "type": "string",
            "maxLength": 255,
            "minLength": 1,
            "title": "Name",
            "description": "Human-readable token name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 1000
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Token description"
          },
          "expires_in_days": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires In Days",
            "description": "Expiry in days"
          },
          "scope": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TokenScopeRequest"
              },
              {
                "type": "null"
              }
            ],
            "description": "Token scoping configuration"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Organizational tags"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID for team-scoped tokens"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "TokenCreateRequest",
        "description": "Schema for creating a new API token.\n\nAttributes:\n    name: Human-readable token name\n    description: Optional token description\n    expires_in_days: Optional expiry in days\n    scope: Optional token scoping configuration\n    tags: Optional organizational tags\n\nExamples:\n    >>> request = TokenCreateRequest(\n    ...     name=\"Production Access\",\n    ...     description=\"Read-only production access\",\n    ...     expires_in_days=30,\n    ...     tags=[\"production\", \"readonly\"]\n    ... )\n    >>> request.name\n    'Production Access'"
      },
      "TokenCreateResponse": {
        "properties": {
          "token": {
            "$ref": "#/components/schemas/TokenResponse",
            "description": "Token information"
          },
          "access_token": {
            "type": "string",
            "title": "Access Token",
            "description": "The actual token string"
          }
        },
        "type": "object",
        "required": [
          "token",
          "access_token"
        ],
        "title": "TokenCreateResponse",
        "description": "Schema for token creation response.\n\nAttributes:\n    token: Token information\n    access_token: The actual token string (only returned on creation)\n\nExamples:\n    >>> from datetime import datetime\n    >>> token_info = TokenResponse(\n    ...     id=\"token-123\", name=\"Test Token\", description=None,\n    ...     user_email=\"test@example.com\", server_id=None, resource_scopes=[], ip_restrictions=[],\n    ...     time_restrictions={}, usage_limits={}, created_at=datetime.now(),\n    ...     expires_at=None, last_used=None, is_active=True, tags=[]\n    ... )\n    >>> response = TokenCreateResponse(\n    ...     token=token_info,\n    ...     access_token=\"abc123xyz\"\n    ... )\n    >>> response.access_token\n    'abc123xyz'"
      },
      "TokenListResponse": {
        "properties": {
          "tokens": {
            "items": {
              "$ref": "#/components/schemas/TokenResponse"
            },
            "type": "array",
            "title": "Tokens",
            "description": "List of tokens"
          },
          "total": {
            "type": "integer",
            "title": "Total",
            "description": "Total number of tokens"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Request limit"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Request offset"
          }
        },
        "type": "object",
        "required": [
          "tokens",
          "total",
          "limit",
          "offset"
        ],
        "title": "TokenListResponse",
        "description": "Schema for token list response.\n\nAttributes:\n    tokens: List of tokens\n    total: Total number of tokens\n    limit: Request limit\n    offset: Request offset\n\nExamples:\n    >>> response = TokenListResponse(\n    ...     tokens=[],\n    ...     total=0,\n    ...     limit=10,\n    ...     offset=0\n    ... )\n    >>> response.total\n    0"
      },
      "TokenResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Token ID"
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Token name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Token description"
          },
          "user_email": {
            "type": "string",
            "title": "User Email",
            "description": "Token creator's email"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID for team-scoped tokens"
          },
          "server_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Server Id",
            "description": "Server scope limitation"
          },
          "resource_scopes": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Resource Scopes",
            "description": "Permission scopes"
          },
          "ip_restrictions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Ip Restrictions",
            "description": "IP restrictions"
          },
          "time_restrictions": {
            "additionalProperties": true,
            "type": "object",
            "title": "Time Restrictions",
            "description": "Time-based restrictions"
          },
          "usage_limits": {
            "additionalProperties": true,
            "type": "object",
            "title": "Usage Limits",
            "description": "Usage limits"
          },
          "created_at": {
            "type": "string",
            "format": "date-time",
            "title": "Created At",
            "description": "Creation timestamp"
          },
          "expires_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires At",
            "description": "Expiry timestamp"
          },
          "last_used": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Last Used",
            "description": "Last usage timestamp"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Active status"
          },
          "is_revoked": {
            "type": "boolean",
            "title": "Is Revoked",
            "description": "Whether token is revoked",
            "default": false
          },
          "revoked_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Revoked At",
            "description": "Revocation timestamp"
          },
          "revoked_by": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Revoked By",
            "description": "Email of user who revoked token"
          },
          "revocation_reason": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Revocation Reason",
            "description": "Reason for revocation"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Organizational tags"
          }
        },
        "type": "object",
        "required": [
          "id",
          "name",
          "user_email",
          "resource_scopes",
          "ip_restrictions",
          "time_restrictions",
          "usage_limits",
          "created_at",
          "is_active",
          "tags"
        ],
        "title": "TokenResponse",
        "description": "Schema for API token response.\n\nAttributes:\n    id: Token ID\n    name: Token name\n    description: Token description\n    server_id: Server scope limitation\n    resource_scopes: Permission scopes\n    ip_restrictions: IP restrictions\n    time_restrictions: Time-based restrictions\n    usage_limits: Usage limits\n    created_at: Creation timestamp\n    expires_at: Expiry timestamp\n    last_used: Last usage timestamp\n    is_active: Active status\n    tags: Organizational tags\n\nExamples:\n    >>> from datetime import datetime\n    >>> token = TokenResponse(\n    ...     id=\"token-123\",\n    ...     name=\"Test Token\",\n    ...     description=\"Test description\",\n    ...     user_email=\"test@example.com\",\n    ...     server_id=None,\n    ...     resource_scopes=[\"tools.read\"],\n    ...     ip_restrictions=[],\n    ...     time_restrictions={},\n    ...     usage_limits={},\n    ...     created_at=datetime.now(),\n    ...     expires_at=None,\n    ...     last_used=None,\n    ...     is_active=True,\n    ...     tags=[]\n    ... )\n    >>> token.name\n    'Test Token'"
      },
      "TokenRevokeRequest": {
        "properties": {
          "reason": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255
              },
              {
                "type": "null"
              }
            ],
            "title": "Reason",
            "description": "Reason for revocation"
          }
        },
        "type": "object",
        "title": "TokenRevokeRequest",
        "description": "Schema for token revocation.\n\nAttributes:\n    reason: Optional reason for revocation\n\nExamples:\n    >>> request = TokenRevokeRequest(reason=\"Security incident\")\n    >>> request.reason\n    'Security incident'"
      },
      "TokenScopeRequest": {
        "properties": {
          "server_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Server Id",
            "description": "Limit token to specific server"
          },
          "permissions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Permissions",
            "description": "Permission scopes"
          },
          "ip_restrictions": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Ip Restrictions",
            "description": "IP address restrictions"
          },
          "time_restrictions": {
            "additionalProperties": true,
            "type": "object",
            "title": "Time Restrictions",
            "description": "Time-based restrictions"
          },
          "usage_limits": {
            "additionalProperties": true,
            "type": "object",
            "title": "Usage Limits",
            "description": "Usage limits and quotas"
          }
        },
        "type": "object",
        "title": "TokenScopeRequest",
        "description": "Schema for token scoping configuration.\n\nAttributes:\n    server_id: Optional server ID limitation\n    permissions: List of permission scopes\n    ip_restrictions: List of IP address/CIDR restrictions\n    time_restrictions: Time-based access limitations\n    usage_limits: Rate limiting and quota settings\n\nExamples:\n    >>> scope = TokenScopeRequest(\n    ...     server_id=\"server-123\",\n    ...     permissions=[\"tools.read\", \"resources.read\"],\n    ...     ip_restrictions=[\"192.168.1.0/24\"]\n    ... )\n    >>> scope.server_id\n    'server-123'"
      },
      "TokenUpdateRequest": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 255,
                "minLength": 1
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "New token name"
          },
          "description": {
            "anyOf": [
              {
                "type": "string",
                "maxLength": 1000
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "New token description"
          },
          "scope": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/TokenScopeRequest"
              },
              {
                "type": "null"
              }
            ],
            "description": "New token scoping configuration"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "New organizational tags"
          }
        },
        "type": "object",
        "title": "TokenUpdateRequest",
        "description": "Schema for updating an existing API token.\n\nAttributes:\n    name: New token name\n    description: New token description\n    scope: New token scoping configuration\n    tags: New organizational tags\n\nExamples:\n    >>> request = TokenUpdateRequest(\n    ...     name=\"Updated Token Name\",\n    ...     description=\"Updated description\"\n    ... )\n    >>> request.name\n    'Updated Token Name'"
      },
      "TokenUsageStatsResponse": {
        "properties": {
          "period_days": {
            "type": "integer",
            "title": "Period Days",
            "description": "Number of days analyzed"
          },
          "total_requests": {
            "type": "integer",
            "title": "Total Requests",
            "description": "Total number of requests"
          },
          "successful_requests": {
            "type": "integer",
            "title": "Successful Requests",
            "description": "Number of successful requests"
          },
          "blocked_requests": {
            "type": "integer",
            "title": "Blocked Requests",
            "description": "Number of blocked requests"
          },
          "success_rate": {
            "type": "number",
            "title": "Success Rate",
            "description": "Success rate (0-1)"
          },
          "average_response_time_ms": {
            "type": "number",
            "title": "Average Response Time Ms",
            "description": "Average response time in milliseconds"
          },
          "top_endpoints": {
            "items": {
              "prefixItems": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ],
              "type": "array",
              "maxItems": 2,
              "minItems": 2
            },
            "type": "array",
            "title": "Top Endpoints",
            "description": "Most accessed endpoints with counts"
          }
        },
        "type": "object",
        "required": [
          "period_days",
          "total_requests",
          "successful_requests",
          "blocked_requests",
          "success_rate",
          "average_response_time_ms",
          "top_endpoints"
        ],
        "title": "TokenUsageStatsResponse",
        "description": "Schema for token usage statistics.\n\nAttributes:\n    period_days: Number of days analyzed\n    total_requests: Total number of requests\n    successful_requests: Number of successful requests\n    blocked_requests: Number of blocked requests\n    success_rate: Success rate percentage\n    average_response_time_ms: Average response time\n    top_endpoints: Most accessed endpoints\n\nExamples:\n    >>> stats = TokenUsageStatsResponse(\n    ...     period_days=30,\n    ...     total_requests=100,\n    ...     successful_requests=95,\n    ...     blocked_requests=5,\n    ...     success_rate=0.95,\n    ...     average_response_time_ms=150.5,\n    ...     top_endpoints=[(\"/tools\", 50), (\"/resources\", 30)]\n    ... )\n    >>> stats.success_rate\n    0.95"
      },
      "ToolCreate": {
        "properties": {
          "allow_auto": {
            "type": "boolean",
            "title": "Allow Auto",
            "default": false
          },
          "name": {
            "type": "string",
            "title": "Name",
            "description": "Unique name for the tool"
          },
          "displayName": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Displayname",
            "description": "Display name for the tool (shown in UI)"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "null"
              }
            ],
            "title": "Url",
            "description": "Tool endpoint URL"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Tool description"
          },
          "integration_type": {
            "type": "string",
            "enum": [
              "REST",
              "MCP",
              "A2A"
            ],
            "title": "Integration Type",
            "description": "'REST' for individual endpoints, 'MCP' for gateway-discovered tools, 'A2A' for A2A agents",
            "default": "REST"
          },
          "request_type": {
            "type": "string",
            "enum": [
              "GET",
              "POST",
              "PUT",
              "DELETE",
              "PATCH",
              "SSE",
              "STDIO",
              "STREAMABLEHTTP"
            ],
            "title": "Request Type",
            "description": "HTTP method to be used for invoking the tool",
            "default": "SSE"
          },
          "headers": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Headers",
            "description": "Additional headers to send when invoking the tool"
          },
          "inputSchema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inputschema",
            "description": "JSON Schema for validating tool parameters"
          },
          "outputSchema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Outputschema",
            "description": "JSON Schema for validating tool output"
          },
          "annotations": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Annotations",
            "description": "Tool annotations for behavior hints (title, readOnlyHint, destructiveHint, idempotentHint, openWorldHint)"
          },
          "jsonpath_filter": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Jsonpath Filter",
            "description": "JSON modification filter",
            "default": ""
          },
          "auth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AuthenticationValues"
              },
              {
                "type": "null"
              }
            ],
            "description": "Authentication credentials (Basic or Bearer Token or custom headers) if required"
          },
          "gateway_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gateway Id",
            "description": "id of gateway for the tool"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the tool"
          },
          "team_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team Id",
            "description": "Team ID for resource organization"
          },
          "owner_email": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owner Email",
            "description": "Email of the tool owner"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level (private, team, public)",
            "default": "public"
          },
          "base_url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Base Url",
            "description": "Base URL for REST passthrough"
          },
          "path_template": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Path Template",
            "description": "Path template for REST passthrough"
          },
          "query_mapping": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Query Mapping",
            "description": "Query mapping for REST passthrough"
          },
          "header_mapping": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Header Mapping",
            "description": "Header mapping for REST passthrough"
          },
          "timeout_ms": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Timeout Ms",
            "description": "Timeout in milliseconds for REST passthrough (20000 if integration_type='REST', else None)"
          },
          "expose_passthrough": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expose Passthrough",
            "description": "Expose passthrough endpoint for this tool",
            "default": true
          },
          "allowlist": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Allowlist",
            "description": "Allowed upstream hosts/schemes for passthrough"
          },
          "plugin_chain_pre": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Plugin Chain Pre",
            "description": "Pre-plugin chain for passthrough"
          },
          "plugin_chain_post": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Plugin Chain Post",
            "description": "Post-plugin chain for passthrough"
          }
        },
        "type": "object",
        "required": [
          "name"
        ],
        "title": "ToolCreate",
        "description": "Represents the configuration for creating a tool with various attributes and settings.\n\nAttributes:\n    model_config (ConfigDict): Configuration for the model.\n    name (str): Unique name for the tool.\n    url (Union[str, AnyHttpUrl]): Tool endpoint URL.\n    description (Optional[str]): Tool description.\n    integration_type (Literal[\"REST\", \"MCP\"]): Tool integration type - REST for individual endpoints, MCP for gateway-discovered tools.\n    request_type (Literal[\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\"]): HTTP method to be used for invoking the tool.\n    headers (Optional[Dict[str, str]]): Additional headers to send when invoking the tool.\n    input_schema (Optional[Dict[str, Any]]): JSON Schema for validating tool parameters. Alias 'inputSchema'.\n    output_schema (Optional[Dict[str, Any]]): JSON Schema for validating tool output. Alias 'outputSchema'.\n    annotations (Optional[Dict[str, Any]]): Tool annotations for behavior hints such as title, readOnlyHint, destructiveHint, idempotentHint, openWorldHint.\n    jsonpath_filter (Optional[str]): JSON modification filter.\n    auth (Optional[AuthenticationValues]): Authentication credentials (Basic or Bearer Token or custom headers) if required.\n    gateway_id (Optional[str]): ID of the gateway for the tool."
      },
      "ToolMetrics": {
        "properties": {
          "totalExecutions": {
            "type": "integer",
            "title": "Totalexecutions",
            "description": "Total number of tool invocations"
          },
          "successfulExecutions": {
            "type": "integer",
            "title": "Successfulexecutions",
            "description": "Number of successful tool invocations"
          },
          "failedExecutions": {
            "type": "integer",
            "title": "Failedexecutions",
            "description": "Number of failed tool invocations"
          },
          "failureRate": {
            "type": "number",
            "title": "Failurerate",
            "description": "Failure rate (failed invocations / total invocations)"
          },
          "minResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Minresponsetime",
            "description": "Minimum response time in seconds"
          },
          "maxResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Maxresponsetime",
            "description": "Maximum response time in seconds"
          },
          "avgResponseTime": {
            "anyOf": [
              {
                "type": "number"
              },
              {
                "type": "null"
              }
            ],
            "title": "Avgresponsetime",
            "description": "Average response time in seconds"
          },
          "lastExecutionTime": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Lastexecutiontime",
            "description": "Timestamp of the most recent invocation"
          }
        },
        "type": "object",
        "required": [
          "totalExecutions",
          "successfulExecutions",
          "failedExecutions",
          "failureRate"
        ],
        "title": "ToolMetrics",
        "description": "Represents the performance and execution statistics for a tool.\n\nAttributes:\n    total_executions (int): Total number of tool invocations.\n    successful_executions (int): Number of successful tool invocations.\n    failed_executions (int): Number of failed tool invocations.\n    failure_rate (float): Failure rate (failed invocations / total invocations).\n    min_response_time (Optional[float]): Minimum response time in seconds.\n    max_response_time (Optional[float]): Maximum response time in seconds.\n    avg_response_time (Optional[float]): Average response time in seconds.\n    last_execution_time (Optional[datetime]): Timestamp of the most recent invocation.\n\nExamples:\n    >>> from datetime import datetime\n    >>> metrics = ToolMetrics(\n    ...     total_executions=100,\n    ...     successful_executions=95,\n    ...     failed_executions=5,\n    ...     failure_rate=0.05,\n    ...     min_response_time=0.1,\n    ...     max_response_time=2.5,\n    ...     avg_response_time=0.8\n    ... )\n    >>> metrics.total_executions\n    100\n    >>> metrics.failure_rate\n    0.05\n    >>> metrics.successful_executions + metrics.failed_executions == metrics.total_executions\n    True\n    >>> # Test with minimal data\n    >>> minimal_metrics = ToolMetrics(\n    ...     total_executions=10,\n    ...     successful_executions=8,\n    ...     failed_executions=2,\n    ...     failure_rate=0.2\n    ... )\n    >>> minimal_metrics.min_response_time is None\n    True\n    >>> # Test model dump functionality\n    >>> data = metrics.model_dump()\n    >>> isinstance(data, dict)\n    True\n    >>> data['total_executions']\n    100",
        "nullable": true
      },
      "ToolRead": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id"
          },
          "originalName": {
            "type": "string",
            "title": "Originalname"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Url"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description"
          },
          "requestType": {
            "type": "string",
            "title": "Requesttype"
          },
          "integrationType": {
            "type": "string",
            "title": "Integrationtype"
          },
          "headers": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Headers"
          },
          "inputSchema": {
            "additionalProperties": true,
            "type": "object",
            "title": "Inputschema"
          },
          "outputSchema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Outputschema"
          },
          "annotations": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Annotations"
          },
          "jsonpathFilter": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Jsonpathfilter"
          },
          "auth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AuthenticationValues"
              },
              {
                "type": "null"
              }
            ]
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "title": "Createdat"
          },
          "updatedAt": {
            "type": "string",
            "format": "date-time",
            "title": "Updatedat"
          },
          "enabled": {
            "type": "boolean",
            "title": "Enabled"
          },
          "reachable": {
            "type": "boolean",
            "title": "Reachable"
          },
          "gatewayId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gatewayid"
          },
          "executionCount": {
            "type": "integer",
            "title": "Executioncount"
          },
          "metrics": {
            "$ref": "#/components/schemas/ToolMetrics"
          },
          "name": {
            "type": "string",
            "title": "Name"
          },
          "displayName": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Displayname",
            "description": "Display name for the tool (shown in UI)"
          },
          "gatewaySlug": {
            "type": "string",
            "title": "Gatewayslug"
          },
          "customName": {
            "type": "string",
            "title": "Customname"
          },
          "customNameSlug": {
            "type": "string",
            "title": "Customnameslug"
          },
          "tags": {
            "items": {
              "type": "string"
            },
            "type": "array",
            "title": "Tags",
            "description": "Tags for categorizing the tool"
          },
          "createdBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdby",
            "description": "Username who created this entity"
          },
          "createdFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdfromip",
            "description": "IP address of creator"
          },
          "createdVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createdvia",
            "description": "Creation method: ui|api|import|federation"
          },
          "createdUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Createduseragent",
            "description": "User agent of creation request"
          },
          "modifiedBy": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedby",
            "description": "Username who last modified this entity"
          },
          "modifiedFromIp": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedfromip",
            "description": "IP address of last modifier"
          },
          "modifiedVia": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifiedvia",
            "description": "Modification method"
          },
          "modifiedUserAgent": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Modifieduseragent",
            "description": "User agent of modification request"
          },
          "importBatchId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Importbatchid",
            "description": "UUID of bulk import batch"
          },
          "federationSource": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Federationsource",
            "description": "Source gateway for federated entities"
          },
          "version": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Version",
            "description": "Entity version for change tracking",
            "default": 1
          },
          "teamId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Teamid",
            "description": "ID of the team that owns this resource"
          },
          "team": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Team",
            "description": "Name of the team that owns this resource"
          },
          "ownerEmail": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Owneremail",
            "description": "Email of the user who owns this resource"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level: private, team, or public",
            "default": "public"
          },
          "baseUrl": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Baseurl",
            "description": "Base URL for REST passthrough"
          },
          "pathTemplate": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pathtemplate",
            "description": "Path template for REST passthrough"
          },
          "queryMapping": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Querymapping",
            "description": "Query mapping for REST passthrough"
          },
          "headerMapping": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Headermapping",
            "description": "Header mapping for REST passthrough"
          },
          "timeoutMs": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Timeoutms",
            "description": "Timeout in milliseconds for REST passthrough",
            "default": 20000
          },
          "exposePassthrough": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Exposepassthrough",
            "description": "Expose passthrough endpoint for this tool",
            "default": true
          },
          "allowlist": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Allowlist",
            "description": "Allowed upstream hosts/schemes for passthrough"
          },
          "pluginChainPre": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pluginchainpre",
            "description": "Pre-plugin chain for passthrough"
          },
          "pluginChainPost": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pluginchainpost",
            "description": "Post-plugin chain for passthrough"
          }
        },
        "type": "object",
        "required": [
          "id",
          "originalName",
          "url",
          "description",
          "requestType",
          "integrationType",
          "headers",
          "inputSchema",
          "annotations",
          "jsonpathFilter",
          "auth",
          "createdAt",
          "updatedAt",
          "enabled",
          "reachable",
          "gatewayId",
          "executionCount",
          "metrics",
          "name",
          "gatewaySlug",
          "customName",
          "customNameSlug"
        ],
        "title": "ToolRead",
        "description": "Schema for reading tool information.\n\nIncludes all tool fields plus:\n- Database ID\n- Creation/update timestamps\n- enabled: If Tool is enabled or disabled.\n- reachable: If Tool is reachable or not.\n- Gateway ID for federation\n- Execution count indicating the number of times the tool has been executed.\n- Metrics: Aggregated metrics for the tool invocations.\n- Request type and authentication settings.",
        "nullable": true
      },
      "ToolUpdate": {
        "properties": {
          "name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Name",
            "description": "Unique name for the tool"
          },
          "displayName": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Displayname",
            "description": "Display name for the tool (shown in UI)"
          },
          "customName": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Customname",
            "description": "Custom name for the tool"
          },
          "url": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "string",
                "minLength": 1,
                "format": "uri"
              },
              {
                "type": "null"
              }
            ],
            "title": "Url",
            "description": "Tool endpoint URL"
          },
          "description": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Description",
            "description": "Tool description"
          },
          "integrationType": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "REST",
                  "MCP",
                  "A2A"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Integrationtype",
            "description": "Tool integration type"
          },
          "requestType": {
            "anyOf": [
              {
                "type": "string",
                "enum": [
                  "GET",
                  "POST",
                  "PUT",
                  "DELETE",
                  "PATCH"
                ]
              },
              {
                "type": "null"
              }
            ],
            "title": "Requesttype",
            "description": "HTTP method to be used for invoking the tool"
          },
          "headers": {
            "anyOf": [
              {
                "additionalProperties": {
                  "type": "string"
                },
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Headers",
            "description": "Additional headers to send when invoking the tool"
          },
          "inputSchema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Inputschema",
            "description": "JSON Schema for validating tool parameters"
          },
          "outputSchema": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Outputschema",
            "description": "JSON Schema for validating tool output"
          },
          "annotations": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Annotations",
            "description": "Tool annotations for behavior hints"
          },
          "jsonpathFilter": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Jsonpathfilter",
            "description": "JSON path filter for rpc tool calls"
          },
          "auth": {
            "anyOf": [
              {
                "$ref": "#/components/schemas/AuthenticationValues"
              },
              {
                "type": "null"
              }
            ],
            "description": "Authentication credentials (Basic or Bearer Token or custom headers) if required"
          },
          "gatewayId": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Gatewayid",
            "description": "id of gateway for the tool"
          },
          "tags": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Tags",
            "description": "Tags for categorizing the tool"
          },
          "visibility": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Visibility",
            "description": "Visibility level: private, team, or public",
            "default": "public"
          },
          "baseUrl": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Baseurl",
            "description": "Base URL for REST passthrough"
          },
          "pathTemplate": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pathtemplate",
            "description": "Path template for REST passthrough"
          },
          "queryMapping": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Querymapping",
            "description": "Query mapping for REST passthrough"
          },
          "headerMapping": {
            "anyOf": [
              {
                "additionalProperties": true,
                "type": "object"
              },
              {
                "type": "null"
              }
            ],
            "title": "Headermapping",
            "description": "Header mapping for REST passthrough"
          },
          "timeoutMs": {
            "anyOf": [
              {
                "type": "integer"
              },
              {
                "type": "null"
              }
            ],
            "title": "Timeoutms",
            "description": "Timeout in milliseconds for REST passthrough (20000 if integration_type='REST', else None)"
          },
          "exposePassthrough": {
            "anyOf": [
              {
                "type": "boolean"
              },
              {
                "type": "null"
              }
            ],
            "title": "Exposepassthrough",
            "description": "Expose passthrough endpoint for this tool",
            "default": true
          },
          "allowlist": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Allowlist",
            "description": "Allowed upstream hosts/schemes for passthrough"
          },
          "pluginChainPre": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pluginchainpre",
            "description": "Pre-plugin chain for passthrough"
          },
          "pluginChainPost": {
            "anyOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "null"
              }
            ],
            "title": "Pluginchainpost",
            "description": "Post-plugin chain for passthrough"
          }
        },
        "type": "object",
        "title": "ToolUpdate",
        "description": "Schema for updating an existing tool.\n\nSimilar to ToolCreate but all fields are optional to allow partial updates.",
        "nullable": true
      },
      "UserListResponse": {
        "properties": {
          "users": {
            "items": {
              "$ref": "#/components/schemas/EmailUserResponse"
            },
            "type": "array",
            "title": "Users",
            "description": "List of users"
          },
          "total_count": {
            "type": "integer",
            "title": "Total Count",
            "description": "Total number of users"
          },
          "limit": {
            "type": "integer",
            "title": "Limit",
            "description": "Request limit"
          },
          "offset": {
            "type": "integer",
            "title": "Offset",
            "description": "Request offset"
          }
        },
        "type": "object",
        "required": [
          "users",
          "total_count",
          "limit",
          "offset"
        ],
        "title": "UserListResponse",
        "description": "Response schema for user list.\n\nAttributes:\n    users: List of users\n    total_count: Total number of users\n    limit: Request limit\n    offset: Request offset\n\nExamples:\n    >>> user_list = UserListResponse(\n    ...     users=[],\n    ...     total_count=0,\n    ...     limit=10,\n    ...     offset=0\n    ... )\n    >>> user_list.total_count\n    0\n    >>> len(user_list.users)\n    0"
      },
      "UserRoleAssignRequest": {
        "properties": {
          "role_id": {
            "type": "string",
            "title": "Role Id",
            "description": "Role ID to assign"
          },
          "scope": {
            "type": "string",
            "pattern": "^(global|team|personal)$",
            "title": "Scope",
            "description": "Assignment scope"
          },
          "scope_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Scope Id",
            "description": "Team ID if team-scoped"
          },
          "expires_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires At",
            "description": "Optional expiration timestamp"
          }
        },
        "type": "object",
        "required": [
          "role_id",
          "scope"
        ],
        "title": "UserRoleAssignRequest",
        "description": "Schema for assigning a role to a user.\n\nAttributes:\n    role_id: Role to assign\n    scope: Assignment scope\n    scope_id: Team ID if team-scoped\n    expires_at: Optional expiration timestamp\n\nExamples:\n    >>> request = UserRoleAssignRequest(\n    ...     role_id=\"role-123\",\n    ...     scope=\"team\",\n    ...     scope_id=\"team-456\"\n    ... )\n    >>> request.scope\n    'team'"
      },
      "UserRoleResponse": {
        "properties": {
          "id": {
            "type": "string",
            "title": "Id",
            "description": "Assignment identifier"
          },
          "user_email": {
            "type": "string",
            "title": "User Email",
            "description": "User email"
          },
          "role_id": {
            "type": "string",
            "title": "Role Id",
            "description": "Role identifier"
          },
          "role_name": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Role Name",
            "description": "Role name for convenience"
          },
          "scope": {
            "type": "string",
            "title": "Scope",
            "description": "Assignment scope"
          },
          "scope_id": {
            "anyOf": [
              {
                "type": "string"
              },
              {
                "type": "null"
              }
            ],
            "title": "Scope Id",
            "description": "Team ID if applicable"
          },
          "granted_by": {
            "type": "string",
            "title": "Granted By",
            "description": "Who granted the role"
          },
          "granted_at": {
            "type": "string",
            "format": "date-time",
            "title": "Granted At",
            "description": "When role was granted"
          },
          "expires_at": {
            "anyOf": [
              {
                "type": "string",
                "format": "date-time"
              },
              {
                "type": "null"
              }
            ],
            "title": "Expires At",
            "description": "Optional expiration"
          },
          "is_active": {
            "type": "boolean",
            "title": "Is Active",
            "description": "Whether assignment is active"
          }
        },
        "type": "object",
        "required": [
          "id",
          "user_email",
          "role_id",
          "scope",
          "granted_by",
          "granted_at",
          "is_active"
        ],
        "title": "UserRoleResponse",
        "description": "Schema for user role assignment response.\n\nAttributes:\n    id: Assignment identifier\n    user_email: User email\n    role_id: Role identifier\n    role_name: Role name for convenience\n    scope: Assignment scope\n    scope_id: Team ID if applicable\n    granted_by: Who granted the role\n    granted_at: When role was granted\n    expires_at: Optional expiration\n    is_active: Whether assignment is active\n\nExamples:\n    >>> user_role = UserRoleResponse(\n    ...     id=\"assignment-123\",\n    ...     user_email=\"user@example.com\",\n    ...     role_id=\"role-456\",\n    ...     role_name=\"team_admin\",\n    ...     scope=\"team\",\n    ...     scope_id=\"team-789\",\n    ...     granted_by=\"admin@example.com\",\n    ...     granted_at=datetime.now(),\n    ...     is_active=True\n    ... )\n    >>> user_role.scope\n    'team'"
      },
      "ValidationError": {
        "properties": {
          "loc": {
            "items": {
              "anyOf": [
                {
                  "type": "string"
                },
                {
                  "type": "integer"
                }
              ]
            },
            "type": "array",
            "title": "Location"
          },
          "msg": {
            "type": "string",
            "title": "Message"
          },
          "type": {
            "type": "string",
            "title": "Error Type"
          }
        },
        "type": "object",
        "required": [
          "loc",
          "msg",
          "type"
        ],
        "title": "ValidationError"
      }
    },
    "securitySchemes": {
      "HTTPBearer": {
        "type": "http",
        "scheme": "bearer"
      }
    }
  }
}
